{"ast":null,"code":"import { OPENLOGIN_NETWORK, UX_MODE, SUPPORTED_KEY_CURVES } from '@toruslabs/openlogin-utils';\nexport * from '@toruslabs/openlogin-utils';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport OpenLogin from '@toruslabs/openlogin';\nimport { BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, log, ADAPTER_EVENTS, WalletLoginError, Web3AuthError } from '@web3auth/base';\nimport merge from 'lodash.merge';\nconst getOpenloginDefaultOptions = () => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP\n    },\n    loginSettings: {},\n    privateKeyProvider: undefined\n  };\n};\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass OpenloginAdapter extends BaseAdapter {\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(params);\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.OPENLOGIN);\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.MULTICHAIN);\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.IN_APP);\n    _defineProperty(this, \"openloginInstance\", null);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n    _defineProperty(this, \"privateKeyProvider\", null);\n    _defineProperty(this, \"openloginOptions\", void 0);\n    _defineProperty(this, \"loginSettings\", {\n      loginProvider: \"\"\n    });\n    this.setAdapterSettings(_objectSpread(_objectSpread({}, params.adapterSettings), {}, {\n      chainConfig: params.chainConfig,\n      clientId: params.clientId || \"\",\n      sessionTime: params.sessionTime,\n      web3AuthNetwork: params.web3AuthNetwork,\n      useCoreKitKey: params.useCoreKitKey,\n      privateKeyProvider: params.privateKeyProvider\n    }));\n    this.loginSettings = params.loginSettings || {\n      loginProvider: \"\"\n    };\n    this.privateKeyProvider = params.privateKeyProvider || null;\n  }\n  get chainConfigProxy() {\n    return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;\n  }\n  get provider() {\n    if (this.status !== ADAPTER_STATUS.NOT_READY && this.privateKeyProvider) {\n      return this.privateKeyProvider.provider;\n    }\n    return null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init(options) {\n    super.checkInitializationRequirements();\n    if (!this.clientId) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.openloginOptions) throw WalletInitializationError.invalidParams(\"openloginOptions is required before openlogin's initialization\");\n    const isRedirectResult = this.openloginOptions.uxMode === UX_MODE.REDIRECT;\n    this.openloginOptions = _objectSpread(_objectSpread({}, this.openloginOptions), {}, {\n      replaceUrlOnRedirect: isRedirectResult\n    });\n    this.openloginInstance = new OpenLogin(_objectSpread(_objectSpread({}, this.openloginOptions), {}, {\n      clientId: this.clientId,\n      network: this.openloginOptions.network || this.web3AuthNetwork || OPENLOGIN_NETWORK.MAINNET\n    }));\n    log.debug(\"initializing openlogin adapter init\");\n    await this.openloginInstance.init();\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n    try {\n      log.debug(\"initializing openlogin adapter\");\n      const finalPrivKey = this._getFinalPrivKey();\n      // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n      if (finalPrivKey && (options.autoConnect || isRedirectResult)) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n  async connect() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      loginProvider: \"\"\n    };\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread(_objectSpread({}, params), {}, {\n      adapter: WALLET_ADAPTERS.OPENLOGIN\n    }));\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error) {\n      log.error(\"Failed to connect with openlogin provider\", error);\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      if (error !== null && error !== void 0 && error.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      } else if (error instanceof Web3AuthError) {\n        throw error;\n      }\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privateKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n    this.rehydrated = false;\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n  async authenticateUser() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const userInfo = await this.getUserInfo();\n    return {\n      idToken: userInfo.idToken\n    };\n  }\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = this.openloginInstance.getUserInfo();\n    return userInfo;\n  }\n  // should be called only before initialization.\n  setAdapterSettings(adapterSettings) {\n    super.setAdapterSettings(adapterSettings);\n    const defaultOptions = getOpenloginDefaultOptions();\n    log.info(\"setting adapter settings\", adapterSettings);\n    this.openloginOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultOptions.adapterSettings), this.openloginOptions), adapterSettings);\n    if (adapterSettings.web3AuthNetwork) {\n      this.openloginOptions.network = adapterSettings.web3AuthNetwork;\n    }\n    if (adapterSettings.useCoreKitKey !== undefined) {\n      this.openloginOptions.useCoreKitKey = adapterSettings.useCoreKitKey;\n    }\n    if (adapterSettings.privateKeyProvider) {\n      this.privateKeyProvider = adapterSettings.privateKeyProvider;\n    }\n  }\n  async addChain(chainConfig) {\n    var _this$privateKeyProvi;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkAddChainRequirements(chainConfig, init);\n    (_this$privateKeyProvi = this.privateKeyProvider) === null || _this$privateKeyProvi === void 0 ? void 0 : _this$privateKeyProvi.addChain(chainConfig);\n    this.addChainConfig(chainConfig);\n  }\n  async switchChain(params) {\n    var _this$privateKeyProvi2;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkSwitchChainRequirements(params, init);\n    await ((_this$privateKeyProvi2 = this.privateKeyProvider) === null || _this$privateKeyProvi2 === void 0 ? void 0 : _this$privateKeyProvi2.switchChain(params));\n    this.setAdapterSettings({\n      chainConfig: this.getChainConfig(params.chainId)\n    });\n  }\n  _getFinalPrivKey() {\n    var _this$openloginOption;\n    if (!this.openloginInstance) return \"\";\n    let finalPrivKey = this.openloginInstance.privKey;\n    // coreKitKey is available only for custom verifiers by default\n    if ((_this$openloginOption = this.openloginOptions) !== null && _this$openloginOption !== void 0 && _this$openloginOption.useCoreKitKey) {\n      // this is to check if the user has already logged in but coreKitKey is not available.\n      // when useCoreKitKey is set to true.\n      // This is to ensure that when there is no user session active, we don't throw an exception.\n      if (this.openloginInstance.privKey && !this.openloginInstance.coreKitKey) {\n        throw WalletLoginError.coreKitKeyNotFound();\n      }\n      finalPrivKey = this.openloginInstance.coreKitKey;\n    }\n    return finalPrivKey;\n  }\n  _getFinalEd25519PrivKey() {\n    var _this$openloginOption2;\n    if (!this.openloginInstance) return \"\";\n    let finalPrivKey = this.openloginInstance.ed25519PrivKey;\n    // coreKitKey is available only for custom verifiers by default\n    if ((_this$openloginOption2 = this.openloginOptions) !== null && _this$openloginOption2 !== void 0 && _this$openloginOption2.useCoreKitKey) {\n      // this is to check if the user has already logged in but coreKitKey is not available.\n      // when useCoreKitKey is set to true.\n      // This is to ensure that when there is no user session active, we don't throw an exception.\n      if (this.openloginInstance.ed25519PrivKey && !this.openloginInstance.coreKitEd25519Key) {\n        throw WalletLoginError.coreKitKeyNotFound();\n      }\n      finalPrivKey = this.openloginInstance.coreKitEd25519Key;\n    }\n    return finalPrivKey;\n  }\n  async connectWithProvider() {\n    var _params$extraLoginOpt;\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      loginProvider: \"\"\n    };\n    if (!this.privateKeyProvider) throw WalletInitializationError.invalidParams(\"PrivateKey Provider is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const keyAvailable = this._getFinalPrivKey();\n    // if not logged in then login\n    if (!keyAvailable || (_params$extraLoginOpt = params.extraLoginOptions) !== null && _params$extraLoginOpt !== void 0 && _params$extraLoginOpt.id_token) {\n      var _params$extraLoginOpt2;\n      if (!this.loginSettings.curve) {\n        this.loginSettings.curve = this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA ? SUPPORTED_KEY_CURVES.ED25519 : SUPPORTED_KEY_CURVES.SECP256K1;\n      }\n      if (!params.loginProvider && !this.loginSettings.loginProvider) throw WalletInitializationError.invalidParams(\"loginProvider is required for login\");\n      await this.openloginInstance.login(merge(this.loginSettings, params, {\n        extraLoginOptions: _objectSpread(_objectSpread({}, params.extraLoginOptions || {}), {}, {\n          login_hint: params.login_hint || ((_params$extraLoginOpt2 = params.extraLoginOptions) === null || _params$extraLoginOpt2 === void 0 ? void 0 : _params$extraLoginOpt2.login_hint)\n        })\n      }));\n    }\n    let finalPrivKey = this._getFinalPrivKey();\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        finalPrivKey = this._getFinalEd25519PrivKey();\n      }\n      await this.privateKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.OPENLOGIN,\n        reconnected: this.rehydrated\n      });\n    }\n  }\n}\nexport { OpenloginAdapter, getOpenloginDefaultOptions };","map":{"version":3,"names":["getOpenloginDefaultOptions","adapterSettings","network","OPENLOGIN_NETWORK","MAINNET","clientId","uxMode","UX_MODE","POPUP","loginSettings","privateKeyProvider","undefined","OpenloginAdapter","BaseAdapter","constructor","params","arguments","length","_defineProperty","WALLET_ADAPTERS","OPENLOGIN","ADAPTER_NAMESPACES","MULTICHAIN","ADAPTER_CATEGORY","IN_APP","ADAPTER_STATUS","NOT_READY","CHAIN_NAMESPACES","EIP155","loginProvider","setAdapterSettings","_objectSpread","chainConfig","sessionTime","web3AuthNetwork","useCoreKitKey","chainConfigProxy","provider","status","_","Error","init","options","checkInitializationRequirements","WalletInitializationError","invalidParams","openloginOptions","isRedirectResult","REDIRECT","replaceUrlOnRedirect","openloginInstance","OpenLogin","log","debug","READY","emit","ADAPTER_EVENTS","finalPrivKey","_getFinalPrivKey","autoConnect","rehydrated","connect","error","checkConnectionRequirements","CONNECTING","adapter","connectWithProvider","ERRORED","message","includes","WalletLoginError","popupClosed","Web3AuthError","connectionError","disconnect","cleanup","CONNECTED","notConnectedError","notReady","logout","DISCONNECTED","authenticateUser","userInfo","getUserInfo","idToken","defaultOptions","info","addChain","_this$privateKeyProvi","checkAddChainRequirements","addChainConfig","switchChain","_this$privateKeyProvi2","checkSwitchChainRequirements","getChainConfig","chainId","_this$openloginOption","privKey","coreKitKey","coreKitKeyNotFound","_getFinalEd25519PrivKey","_this$openloginOption2","ed25519PrivKey","coreKitEd25519Key","_params$extraLoginOpt","keyAvailable","extraLoginOptions","id_token","_params$extraLoginOpt2","curve","currentChainNamespace","SOLANA","SUPPORTED_KEY_CURVES","ED25519","SECP256K1","login","merge","login_hint","setupProvider","reconnected"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/openlogin-adapter/src/config.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/openlogin-adapter/src/openloginAdapter.ts"],"sourcesContent":["import { OPENLOGIN_NETWORK, UX_MODE } from \"@toruslabs/openlogin-utils\";\n\nimport { OpenloginAdapterOptions } from \"./interface\";\n\nexport const getOpenloginDefaultOptions = (): OpenloginAdapterOptions => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP,\n    },\n    loginSettings: {},\n    privateKeyProvider: undefined,\n  };\n};\n","import OpenLogin from \"@toruslabs/openlogin\";\nimport { LoginParams, OPENLOGIN_NETWORK, OpenLoginOptions, SUPPORTED_KEY_CURVES, UX_MODE } from \"@toruslabs/openlogin-utils\";\nimport {\n  ADAPTER_CATEGORY,\n  ADAPTER_CATEGORY_TYPE,\n  ADAPTER_EVENTS,\n  ADAPTER_NAMESPACES,\n  ADAPTER_STATUS,\n  ADAPTER_STATUS_TYPE,\n  AdapterInitOptions,\n  AdapterNamespaceType,\n  BaseAdapter,\n  BaseAdapterSettings,\n  CHAIN_NAMESPACES,\n  ChainNamespaceType,\n  CONNECTED_EVENT_DATA,\n  CustomChainConfig,\n  log,\n  SafeEventEmitterProvider,\n  UserInfo,\n  WALLET_ADAPTERS,\n  WalletInitializationError,\n  WalletLoginError,\n  Web3AuthError,\n} from \"@web3auth/base\";\nimport merge from \"lodash.merge\";\n\nimport { getOpenloginDefaultOptions } from \"./config\";\nimport type { LoginSettings, OpenloginAdapterOptions, PrivateKeyProvider } from \"./interface\";\n\nexport type OpenloginLoginParams = LoginParams & {\n  // to maintain backward compatibility\n  login_hint?: string;\n};\n\nexport class OpenloginAdapter extends BaseAdapter<OpenloginLoginParams> {\n  readonly name: string = WALLET_ADAPTERS.OPENLOGIN;\n\n  readonly adapterNamespace: AdapterNamespaceType = ADAPTER_NAMESPACES.MULTICHAIN;\n\n  readonly type: ADAPTER_CATEGORY_TYPE = ADAPTER_CATEGORY.IN_APP;\n\n  public openloginInstance: OpenLogin | null = null;\n\n  public status: ADAPTER_STATUS_TYPE = ADAPTER_STATUS.NOT_READY;\n\n  public currentChainNamespace: ChainNamespaceType = CHAIN_NAMESPACES.EIP155;\n\n  public privateKeyProvider: PrivateKeyProvider | null = null;\n\n  private openloginOptions: OpenloginAdapterOptions[\"adapterSettings\"];\n\n  private loginSettings: LoginSettings = { loginProvider: \"\" };\n\n  constructor(params: OpenloginAdapterOptions = {}) {\n    super(params);\n    this.setAdapterSettings({\n      ...params.adapterSettings,\n      chainConfig: params.chainConfig,\n      clientId: params.clientId || \"\",\n      sessionTime: params.sessionTime,\n      web3AuthNetwork: params.web3AuthNetwork,\n      useCoreKitKey: params.useCoreKitKey,\n      privateKeyProvider: params.privateKeyProvider,\n    });\n    this.loginSettings = params.loginSettings || { loginProvider: \"\" };\n    this.privateKeyProvider = params.privateKeyProvider || null;\n  }\n\n  get chainConfigProxy(): CustomChainConfig | null {\n    return this.chainConfig ? { ...this.chainConfig } : null;\n  }\n\n  get provider(): SafeEventEmitterProvider | null {\n    if (this.status !== ADAPTER_STATUS.NOT_READY && this.privateKeyProvider) {\n      return this.privateKeyProvider.provider;\n    }\n    return null;\n  }\n\n  set provider(_: SafeEventEmitterProvider | null) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options: AdapterInitOptions): Promise<void> {\n    super.checkInitializationRequirements();\n    if (!this.clientId) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.openloginOptions) throw WalletInitializationError.invalidParams(\"openloginOptions is required before openlogin's initialization\");\n    const isRedirectResult = this.openloginOptions.uxMode === UX_MODE.REDIRECT;\n\n    this.openloginOptions = {\n      ...this.openloginOptions,\n      replaceUrlOnRedirect: isRedirectResult,\n    };\n    this.openloginInstance = new OpenLogin({\n      ...this.openloginOptions,\n      clientId: this.clientId,\n      network: this.openloginOptions.network || this.web3AuthNetwork || OPENLOGIN_NETWORK.MAINNET,\n    });\n    log.debug(\"initializing openlogin adapter init\");\n\n    await this.openloginInstance.init();\n\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n\n    try {\n      log.debug(\"initializing openlogin adapter\");\n\n      const finalPrivKey = this._getFinalPrivKey();\n      // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n      if (finalPrivKey && (options.autoConnect || isRedirectResult)) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect(params: OpenloginLoginParams = { loginProvider: \"\" }): Promise<SafeEventEmitterProvider | null> {\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, { ...params, adapter: WALLET_ADAPTERS.OPENLOGIN });\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error: unknown) {\n      log.error(\"Failed to connect with openlogin provider\", error);\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      if ((error as Error)?.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      } else if (error instanceof Web3AuthError) {\n        throw error;\n      }\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n\n  async disconnect(options: { cleanup: boolean } = { cleanup: false }): Promise<void> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privateKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.rehydrated = false;\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async authenticateUser(): Promise<{ idToken: string }> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const userInfo = await this.getUserInfo();\n    return {\n      idToken: userInfo.idToken as string,\n    };\n  }\n\n  async getUserInfo(): Promise<Partial<UserInfo>> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = this.openloginInstance.getUserInfo();\n    return userInfo;\n  }\n\n  // should be called only before initialization.\n  setAdapterSettings(adapterSettings: Partial<OpenLoginOptions & BaseAdapterSettings> & { privateKeyProvider?: PrivateKeyProvider }): void {\n    super.setAdapterSettings(adapterSettings);\n    const defaultOptions = getOpenloginDefaultOptions();\n    log.info(\"setting adapter settings\", adapterSettings);\n    this.openloginOptions = {\n      ...defaultOptions.adapterSettings,\n      ...this.openloginOptions,\n      ...adapterSettings,\n    };\n    if (adapterSettings.web3AuthNetwork) {\n      this.openloginOptions.network = adapterSettings.web3AuthNetwork;\n    }\n    if (adapterSettings.useCoreKitKey !== undefined) {\n      this.openloginOptions.useCoreKitKey = adapterSettings.useCoreKitKey;\n    }\n    if (adapterSettings.privateKeyProvider) {\n      this.privateKeyProvider = adapterSettings.privateKeyProvider;\n    }\n  }\n\n  public async addChain(chainConfig: CustomChainConfig, init = false): Promise<void> {\n    super.checkAddChainRequirements(chainConfig, init);\n    this.privateKeyProvider?.addChain(chainConfig);\n    this.addChainConfig(chainConfig);\n  }\n\n  public async switchChain(params: { chainId: string }, init = false): Promise<void> {\n    super.checkSwitchChainRequirements(params, init);\n    await this.privateKeyProvider?.switchChain(params);\n    this.setAdapterSettings({ chainConfig: this.getChainConfig(params.chainId) as CustomChainConfig });\n  }\n\n  private _getFinalPrivKey() {\n    if (!this.openloginInstance) return \"\";\n    let finalPrivKey = this.openloginInstance.privKey;\n    // coreKitKey is available only for custom verifiers by default\n    if (this.openloginOptions?.useCoreKitKey) {\n      // this is to check if the user has already logged in but coreKitKey is not available.\n      // when useCoreKitKey is set to true.\n      // This is to ensure that when there is no user session active, we don't throw an exception.\n      if (this.openloginInstance.privKey && !this.openloginInstance.coreKitKey) {\n        throw WalletLoginError.coreKitKeyNotFound();\n      }\n      finalPrivKey = this.openloginInstance.coreKitKey;\n    }\n    return finalPrivKey;\n  }\n\n  private _getFinalEd25519PrivKey() {\n    if (!this.openloginInstance) return \"\";\n    let finalPrivKey = this.openloginInstance.ed25519PrivKey;\n    // coreKitKey is available only for custom verifiers by default\n    if (this.openloginOptions?.useCoreKitKey) {\n      // this is to check if the user has already logged in but coreKitKey is not available.\n      // when useCoreKitKey is set to true.\n      // This is to ensure that when there is no user session active, we don't throw an exception.\n      if (this.openloginInstance.ed25519PrivKey && !this.openloginInstance.coreKitEd25519Key) {\n        throw WalletLoginError.coreKitKeyNotFound();\n      }\n      finalPrivKey = this.openloginInstance.coreKitEd25519Key;\n    }\n    return finalPrivKey;\n  }\n\n  private async connectWithProvider(params: OpenloginLoginParams = { loginProvider: \"\" }): Promise<void> {\n    if (!this.privateKeyProvider) throw WalletInitializationError.invalidParams(\"PrivateKey Provider is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n\n    const keyAvailable = this._getFinalPrivKey();\n    // if not logged in then login\n    if (!keyAvailable || params.extraLoginOptions?.id_token) {\n      if (!this.loginSettings.curve) {\n        this.loginSettings.curve =\n          this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA ? SUPPORTED_KEY_CURVES.ED25519 : SUPPORTED_KEY_CURVES.SECP256K1;\n      }\n      if (!params.loginProvider && !this.loginSettings.loginProvider)\n        throw WalletInitializationError.invalidParams(\"loginProvider is required for login\");\n      await this.openloginInstance.login(\n        merge(this.loginSettings, params, {\n          extraLoginOptions: { ...(params.extraLoginOptions || {}), login_hint: params.login_hint || params.extraLoginOptions?.login_hint },\n        })\n      );\n    }\n    let finalPrivKey = this._getFinalPrivKey();\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        finalPrivKey = this._getFinalEd25519PrivKey();\n      }\n\n      await this.privateKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, { adapter: WALLET_ADAPTERS.OPENLOGIN, reconnected: this.rehydrated } as CONNECTED_EVENT_DATA);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}