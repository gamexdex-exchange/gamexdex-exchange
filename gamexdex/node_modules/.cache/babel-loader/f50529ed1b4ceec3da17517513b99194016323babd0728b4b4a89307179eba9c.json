{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { BaseController, createEventEmitterProxy, createFetchMiddleware } from '@toruslabs/base-controllers';\nimport { WalletInitializationError, CHAIN_NAMESPACES } from '@web3auth/base';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { mergeMiddleware, JRPCEngine, providerFromEngine, createScaffoldMiddleware, createAsyncMiddleware } from '@toruslabs/openlogin-jrpc';\nimport getCreateRandomId from 'json-rpc-random-id';\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass BaseProvider extends BaseController {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    // should be Assigned in setupProvider\n    _defineProperty(this, \"_providerEngineProxy\", null);\n    if (!config.chainConfig) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainConfig\");\n    if (!config.chainConfig.chainId) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainId inside chainConfig\");\n    if (!config.chainConfig.rpcTarget) throw WalletInitializationError.invalidProviderConfigError(\"Please provide rpcTarget inside chainConfig\");\n    this.defaultState = {\n      chainId: \"loading\"\n    };\n    this.defaultConfig = {\n      chainConfig: config.chainConfig,\n      networks: {\n        [config.chainConfig.chainId]: config.chainConfig\n      }\n    };\n    super.initialize();\n  }\n  get currentChainConfig() {\n    return this.config.chainConfig;\n  }\n  get provider() {\n    return this._providerEngineProxy;\n  }\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n  addChain(chainConfig) {\n    if (!chainConfig.chainId) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    if (!chainConfig.rpcTarget) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    this.configure({\n      networks: _objectSpread$1(_objectSpread$1({}, this.config.networks), {}, {\n        [chainConfig.chainId]: chainConfig\n      })\n    });\n  }\n  getChainConfig(chainId) {\n    var _this$config$networks;\n    const chainConfig = (_this$config$networks = this.config.networks) === null || _this$config$networks === void 0 ? void 0 : _this$config$networks[chainId];\n    if (!chainConfig) throw ethErrors.rpc.invalidRequest(`Chain ${chainId} is not supported, please add chainConfig for it`);\n    return chainConfig;\n  }\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n  updateProviderEngineProxy(provider) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(provider);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(provider);\n    }\n  }\n}\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"chainId\") {\n      res.result = chainId;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\nclass CommonJRPCProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n  }\n  async setupProvider() {\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    const engine = new JRPCEngine();\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n  }\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    await this.setupProvider();\n  }\n  updateProviderEngineProxy(provider) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(provider);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(provider);\n    }\n  }\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n  lookupNetwork() {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n_defineProperty(CommonJRPCProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new CommonJRPCProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider();\n  return providerFactory;\n});\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass CommonPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.OTHER\n        })\n      },\n      state\n    });\n    // should be Assigned in setupProvider\n    _defineProperty(this, \"_providerEngineProxy\", null);\n  }\n  get provider() {\n    return this._providerEngineProxy;\n  }\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n  addChain(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n  async setupProvider(privKey) {\n    const privKeyMiddleware = this.getPrivKeyMiddleware(privKey);\n    const engine = new JRPCEngine();\n    engine.push(privKeyMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n  }\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n  async lookupNetwork() {\n    return Promise.resolve(\"\");\n  }\n  updateProviderEngineProxy(provider) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(provider);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(provider);\n    }\n  }\n  getPrivKeyMiddleware(privKey) {\n    const middleware = {\n      getPrivatekey: async () => {\n        return privKey;\n      }\n    };\n    return this.createPrivKeyMiddleware(middleware);\n  }\n  createPrivKeyMiddleware(_ref2) {\n    let {\n      getPrivatekey\n    } = _ref2;\n    async function getPrivatekeyHandler(_, res) {\n      res.result = await getPrivatekey();\n    }\n    return createScaffoldMiddleware({\n      private_key: createAsyncMiddleware(getPrivatekeyHandler)\n    });\n  }\n}\n_defineProperty(CommonPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new CommonPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\nconst createRandomId = getCreateRandomId();\nexport { BaseProvider, CommonJRPCProvider, CommonPrivateKeyProvider, createRandomId };","map":{"version":3,"names":["BaseProvider","BaseController","constructor","_ref","config","state","_defineProperty","chainConfig","WalletInitializationError","invalidProviderConfigError","chainId","rpcTarget","defaultState","defaultConfig","networks","initialize","currentChainConfig","provider","_providerEngineProxy","_","Error","addChain","ethErrors","rpc","invalidParams","configure","_objectSpread$1","getChainConfig","_this$config$networks","invalidRequest","getProviderEngineProxy","updateProviderEngineProxy","setTarget","createEventEmitterProxy","createChainIdMiddleware","req","res","next","end","method","result","createProviderConfigMiddleware","providerConfig","createJsonRpcClient","fetchMiddleware","createFetchMiddleware","networkMiddleware","mergeMiddleware","CommonJRPCProvider","setupProvider","engine","JRPCEngine","push","providerFromEngine","switchChain","params","custom","message","code","update","lookupNetwork","providerFactory","CommonPrivateKeyProvider","_objectSpread","chainNamespace","CHAIN_NAMESPACES","OTHER","privKey","privKeyMiddleware","getPrivKeyMiddleware","Promise","resolve","middleware","getPrivatekey","createPrivKeyMiddleware","_ref2","getPrivatekeyHandler","createScaffoldMiddleware","private_key","createAsyncMiddleware","createRandomId","getCreateRandomId"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/base-provider/src/baseProvider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/base-provider/src/jrpcClient.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/base-provider/src/CommonJRPCProvider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/base-provider/src/commonPrivateKeyProvider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/base-provider/src/utils.ts"],"sourcesContent":["import { BaseConfig, BaseController, BaseState, createEventEmitterProxy } from \"@toruslabs/base-controllers\";\nimport { CustomChainConfig, SafeEventEmitterProvider, WalletInitializationError } from \"@web3auth/base\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { IBaseProvider } from \"./IBaseProvider\";\n\nexport interface BaseProviderState extends BaseState {\n  chainId: string;\n}\n\nexport interface BaseProviderConfig extends BaseConfig {\n  chainConfig: Partial<CustomChainConfig>;\n  networks?: Record<string, CustomChainConfig>;\n  skipLookupNetwork?: boolean;\n}\n\nexport abstract class BaseProvider<C extends BaseProviderConfig, S extends BaseProviderState, P>\n  extends BaseController<C, S>\n  implements IBaseProvider<P>\n{\n  // should be Assigned in setupProvider\n  public _providerEngineProxy: SafeEventEmitterProvider | null = null;\n\n  constructor({ config, state }: { config: C; state?: S }) {\n    super({ config, state });\n    if (!config.chainConfig) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainConfig\");\n    if (!config.chainConfig.chainId) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainId inside chainConfig\");\n    if (!config.chainConfig.rpcTarget) throw WalletInitializationError.invalidProviderConfigError(\"Please provide rpcTarget inside chainConfig\");\n    this.defaultState = {\n      chainId: \"loading\",\n    } as S;\n    this.defaultConfig = {\n      chainConfig: config.chainConfig,\n      networks: { [config.chainConfig.chainId]: config.chainConfig },\n    } as C;\n    super.initialize();\n  }\n\n  get currentChainConfig(): Partial<CustomChainConfig> {\n    return this.config.chainConfig;\n  }\n\n  get provider(): SafeEventEmitterProvider | null {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  public addChain(chainConfig: CustomChainConfig): void {\n    if (!chainConfig.chainId) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    if (!chainConfig.rpcTarget) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    this.configure({\n      networks: { ...this.config.networks, [chainConfig.chainId]: chainConfig },\n    } as C);\n  }\n\n  public getChainConfig(chainId: string): CustomChainConfig | null {\n    const chainConfig = this.config.networks?.[chainId];\n    if (!chainConfig) throw ethErrors.rpc.invalidRequest(`Chain ${chainId} is not supported, please add chainConfig for it`);\n    return chainConfig;\n  }\n\n  protected getProviderEngineProxy(): SafeEventEmitterProvider | null {\n    return this._providerEngineProxy;\n  }\n\n  protected updateProviderEngineProxy(provider: SafeEventEmitterProvider) {\n    if (this._providerEngineProxy) {\n      (this._providerEngineProxy as any).setTarget(provider);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy<SafeEventEmitterProvider>(provider);\n    }\n  }\n\n  abstract setupProvider(provider: P): Promise<void>;\n\n  abstract switchChain(params: { chainId: string }): Promise<void>;\n\n  protected abstract lookupNetwork(provider?: P): Promise<string | void>;\n}\n","import { createFetchMiddleware } from \"@toruslabs/base-controllers\";\nimport { JRPCEngineEndCallback, JRPCEngineNextCallback, JRPCMiddleware, JRPCRequest, JRPCResponse, mergeMiddleware } from \"@toruslabs/openlogin-jrpc\";\nimport type { CustomChainConfig } from \"@web3auth/base\";\n\nexport function createChainIdMiddleware(chainId: string): JRPCMiddleware<unknown, unknown> {\n  return (req: JRPCRequest<unknown>, res: JRPCResponse<string>, next: JRPCEngineNextCallback, end: JRPCEngineEndCallback) => {\n    if (req.method === \"chainId\") {\n      res.result = chainId;\n      return end();\n    }\n    return next();\n  };\n}\n\nexport function createProviderConfigMiddleware(providerConfig: CustomChainConfig): JRPCMiddleware<unknown, unknown> {\n  return (req: JRPCRequest<unknown>, res: JRPCResponse<CustomChainConfig>, next: JRPCEngineNextCallback, end: JRPCEngineEndCallback) => {\n    if (req.method === \"provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n    return next();\n  };\n}\n\nexport function createJsonRpcClient(providerConfig: CustomChainConfig): {\n  networkMiddleware: JRPCMiddleware<unknown, unknown>;\n  fetchMiddleware: JRPCMiddleware<unknown, unknown>;\n} {\n  const { chainId, rpcTarget } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({ rpcTarget });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return { networkMiddleware, fetchMiddleware };\n}\n","import { createEventEmitterProxy } from \"@toruslabs/base-controllers\";\nimport { JRPCEngine, providerFromEngine } from \"@toruslabs/openlogin-jrpc\";\nimport { CustomChainConfig, SafeEventEmitterProvider } from \"@web3auth/base\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { BaseProvider, BaseProviderConfig, BaseProviderState } from \"./baseProvider\";\nimport { createJsonRpcClient } from \"./jrpcClient\";\n\nexport type CommonJRPCProviderConfig = BaseProviderConfig;\n\nexport type CommonJRPCProviderState = BaseProviderState;\n\nexport class CommonJRPCProvider extends BaseProvider<CommonJRPCProviderConfig, CommonJRPCProviderState, never> {\n  constructor({ config, state }: { config: CommonJRPCProviderConfig; state?: CommonJRPCProviderState }) {\n    super({ config, state });\n  }\n\n  public static getProviderInstance = async (params: { chainConfig: CustomChainConfig }): Promise<CommonJRPCProvider> => {\n    const providerFactory = new CommonJRPCProvider({ config: { chainConfig: params.chainConfig } });\n    await providerFactory.setupProvider();\n    return providerFactory;\n  };\n\n  public async setupProvider(): Promise<void> {\n    const { networkMiddleware } = createJsonRpcClient(this.config.chainConfig as CustomChainConfig);\n    const engine = new JRPCEngine();\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n  }\n\n  public async switchChain(params: { chainId: string }): Promise<void> {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\",\n    });\n    this.configure({ chainConfig });\n    await this.setupProvider();\n  }\n\n  public updateProviderEngineProxy(provider: SafeEventEmitterProvider) {\n    if (this._providerEngineProxy) {\n      (this._providerEngineProxy as any).setTarget(provider);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy<SafeEventEmitterProvider>(provider);\n    }\n  }\n\n  protected getProviderEngineProxy(): SafeEventEmitterProvider | null {\n    return this._providerEngineProxy;\n  }\n\n  protected lookupNetwork(): Promise<string | void> {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n","import { createEventEmitterProxy } from \"@toruslabs/base-controllers\";\nimport {\n  createAsyncMiddleware,\n  createScaffoldMiddleware,\n  JRPCEngine,\n  JRPCMiddleware,\n  JRPCRequest,\n  JRPCResponse,\n  providerFromEngine,\n} from \"@toruslabs/openlogin-jrpc\";\nimport { CHAIN_NAMESPACES, CustomChainConfig, SafeEventEmitterProvider } from \"@web3auth/base\";\n\nimport { BaseProvider, BaseProviderConfig, BaseProviderState } from \"./baseProvider\";\nimport { IBaseProvider } from \"./IBaseProvider\";\n\nexport interface CommonPrivKeyProviderConfig extends BaseProviderConfig {\n  chainConfig: Omit<CustomChainConfig, \"chainNamespace\">;\n}\n\nexport interface CommonPrivKeyProviderState extends BaseProviderState {\n  privateKey?: string;\n}\n\nexport class CommonPrivateKeyProvider extends BaseProvider<BaseProviderConfig, CommonPrivKeyProviderState, string> implements IBaseProvider<string> {\n  // should be Assigned in setupProvider\n  public _providerEngineProxy: SafeEventEmitterProvider | null = null;\n\n  constructor({ config, state }: { config: CommonPrivKeyProviderConfig; state?: CommonPrivKeyProviderState }) {\n    super({ config: { chainConfig: { ...config.chainConfig, chainNamespace: CHAIN_NAMESPACES.OTHER } }, state });\n  }\n\n  get provider(): SafeEventEmitterProvider | null {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  public static getProviderInstance = async (params: {\n    privKey: string;\n    chainConfig: Omit<CustomChainConfig, \"chainNamespace\">;\n  }): Promise<CommonPrivateKeyProvider> => {\n    const providerFactory = new CommonPrivateKeyProvider({ config: { chainConfig: params.chainConfig } });\n    await providerFactory.setupProvider(params.privKey);\n    return providerFactory;\n  };\n\n  addChain(_: CustomChainConfig): void {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  public async setupProvider(privKey: string): Promise<void> {\n    const privKeyMiddleware = this.getPrivKeyMiddleware(privKey);\n    const engine = new JRPCEngine();\n    engine.push(privKeyMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n  }\n\n  public async switchChain(_: { chainId: string }): Promise<void> {\n    return Promise.resolve();\n  }\n\n  protected getProviderEngineProxy(): SafeEventEmitterProvider | null {\n    return this._providerEngineProxy;\n  }\n\n  protected async lookupNetwork(): Promise<string> {\n    return Promise.resolve(\"\");\n  }\n\n  protected updateProviderEngineProxy(provider: SafeEventEmitterProvider) {\n    if (this._providerEngineProxy) {\n      (this._providerEngineProxy as any).setTarget(provider);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy<SafeEventEmitterProvider>(provider);\n    }\n  }\n\n  private getPrivKeyMiddleware(privKey: string): JRPCMiddleware<unknown, unknown> {\n    const middleware = {\n      getPrivatekey: async (): Promise<string> => {\n        return privKey;\n      },\n    };\n    return this.createPrivKeyMiddleware(middleware);\n  }\n\n  private createPrivKeyMiddleware({ getPrivatekey }): JRPCMiddleware<unknown, unknown> {\n    async function getPrivatekeyHandler(_: JRPCRequest<{ privateKey: string }[]>, res: JRPCResponse<unknown>): Promise<void> {\n      res.result = await getPrivatekey();\n    }\n\n    return createScaffoldMiddleware({\n      private_key: createAsyncMiddleware(getPrivatekeyHandler),\n    });\n  }\n}\n","import getCreateRandomId from \"json-rpc-random-id\";\nexport const createRandomId = getCreateRandomId();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}