{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Common = void 0;\nconst util_1 = require(\"@ethereumjs/util\");\nconst crc_32_1 = require(\"crc-32\");\nconst events_1 = require(\"events\");\nconst goerli = require(\"./chains/goerli.json\");\nconst mainnet = require(\"./chains/mainnet.json\");\nconst rinkeby = require(\"./chains/rinkeby.json\");\nconst ropsten = require(\"./chains/ropsten.json\");\nconst sepolia = require(\"./chains/sepolia.json\");\nconst eips_1 = require(\"./eips\");\nconst enums_1 = require(\"./enums\");\nconst hardforks_1 = require(\"./hardforks\");\nconst utils_1 = require(\"./utils\");\n/**\n * Common class to access chain and hardfork parameters and to provide\n * a unified and shared view on the network and hardfork state.\n *\n * Use the {@link Common.custom} static constructor for creating simple\n * custom chain {@link Common} objects (more complete custom chain setups\n * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).\n */\nclass Common extends events_1.EventEmitter {\n  constructor(opts) {\n    super();\n    this._eips = [];\n    this._customChains = opts.customChains ?? [];\n    this._chainParams = this.setChain(opts.chain);\n    this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? enums_1.Hardfork.Merge;\n    // Assign hardfork changes in the sequence of the applied hardforks\n    this.HARDFORK_CHANGES = this.hardforks().map(hf => [hf.name, hardforks_1.hardforks[hf.name]]);\n    this._hardfork = this.DEFAULT_HARDFORK;\n    if (opts.hardfork !== undefined) {\n      this.setHardfork(opts.hardfork);\n    }\n    if (opts.eips) {\n      this.setEIPs(opts.eips);\n    }\n  }\n  /**\n   * Creates a {@link Common} object for a custom chain, based on a standard one.\n   *\n   * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden\n   * in a provided {@link chainParamsOrName} dictionary. Some usage example:\n   *\n   * ```javascript\n   * Common.custom({chainId: 123})\n   * ```\n   *\n   * There are also selected supported custom chains which can be initialized by using one of the\n   * {@link CustomChains} for {@link chainParamsOrName}, e.g.:\n   *\n   * ```javascript\n   * Common.custom(CustomChains.MaticMumbai)\n   * ```\n   *\n   * Note that these supported custom chains only provide some base parameters (usually the chain and\n   * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with\n   * the `@ethereumjs/tx` library to a Layer-2 chain).\n   *\n   * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain\n   * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others\n   */\n  static custom(chainParamsOrName, opts = {}) {\n    const baseChain = opts.baseChain ?? 'mainnet';\n    const standardChainParams = {\n      ...Common._getChainParams(baseChain)\n    };\n    standardChainParams['name'] = 'custom-chain';\n    if (typeof chainParamsOrName !== 'string') {\n      return new Common({\n        chain: {\n          ...standardChainParams,\n          ...chainParamsOrName\n        },\n        ...opts\n      });\n    } else {\n      if (chainParamsOrName === enums_1.CustomChain.PolygonMainnet) {\n        return Common.custom({\n          name: enums_1.CustomChain.PolygonMainnet,\n          chainId: 137,\n          networkId: 137\n        }, opts);\n      }\n      if (chainParamsOrName === enums_1.CustomChain.PolygonMumbai) {\n        return Common.custom({\n          name: enums_1.CustomChain.PolygonMumbai,\n          chainId: 80001,\n          networkId: 80001\n        }, opts);\n      }\n      if (chainParamsOrName === enums_1.CustomChain.ArbitrumRinkebyTestnet) {\n        return Common.custom({\n          name: enums_1.CustomChain.ArbitrumRinkebyTestnet,\n          chainId: 421611,\n          networkId: 421611\n        }, opts);\n      }\n      if (chainParamsOrName === enums_1.CustomChain.ArbitrumOne) {\n        return Common.custom({\n          name: enums_1.CustomChain.ArbitrumOne,\n          chainId: 42161,\n          networkId: 42161\n        }, opts);\n      }\n      if (chainParamsOrName === enums_1.CustomChain.xDaiChain) {\n        return Common.custom({\n          name: enums_1.CustomChain.xDaiChain,\n          chainId: 100,\n          networkId: 100\n        }, opts);\n      }\n      if (chainParamsOrName === enums_1.CustomChain.OptimisticKovan) {\n        return Common.custom({\n          name: enums_1.CustomChain.OptimisticKovan,\n          chainId: 69,\n          networkId: 69\n        },\n        // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n        {\n          hardfork: enums_1.Hardfork.Berlin,\n          ...opts\n        });\n      }\n      if (chainParamsOrName === enums_1.CustomChain.OptimisticEthereum) {\n        return Common.custom({\n          name: enums_1.CustomChain.OptimisticEthereum,\n          chainId: 10,\n          networkId: 10\n        },\n        // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n        {\n          hardfork: enums_1.Hardfork.Berlin,\n          ...opts\n        });\n      }\n      throw new Error(`Custom chain ${chainParamsOrName} not supported`);\n    }\n  }\n  /**\n   * Static method to load and set common from a geth genesis json\n   * @param genesisJson json of geth configuration\n   * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance\n   * @returns Common\n   */\n  static fromGethGenesis(genesisJson, {\n    chain,\n    eips,\n    genesisHash,\n    hardfork,\n    mergeForkIdPostMerge\n  }) {\n    const genesisParams = (0, utils_1.parseGethGenesis)(genesisJson, chain, mergeForkIdPostMerge);\n    const common = new Common({\n      chain: genesisParams.name ?? 'custom',\n      customChains: [genesisParams],\n      eips,\n      hardfork: hardfork ?? genesisParams.hardfork\n    });\n    if (genesisHash !== undefined) {\n      common.setForkHashes(genesisHash);\n    }\n    return common;\n  }\n  /**\n   * Static method to determine if a {@link chainId} is supported as a standard chain\n   * @param chainId bigint id (`1`) of a standard chain\n   * @returns boolean\n   */\n  static isSupportedChainId(chainId) {\n    const initializedChains = this._getInitializedChains();\n    return Boolean(initializedChains['names'][chainId.toString()]);\n  }\n  static _getChainParams(chain, customChains) {\n    const initializedChains = this._getInitializedChains(customChains);\n    if (typeof chain === 'number' || typeof chain === 'bigint') {\n      chain = chain.toString();\n      if (initializedChains['names'][chain]) {\n        const name = initializedChains['names'][chain];\n        return initializedChains[name];\n      }\n      throw new Error(`Chain with ID ${chain} not supported`);\n    }\n    if (initializedChains[chain] !== undefined) {\n      return initializedChains[chain];\n    }\n    throw new Error(`Chain with name ${chain} not supported`);\n  }\n  /**\n   * Sets the chain\n   * @param chain String ('mainnet') or Number (1) chain representation.\n   *              Or, a Dictionary of chain parameters for a private network.\n   * @returns The dictionary with parameters set as chain\n   */\n  setChain(chain) {\n    if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {\n      this._chainParams = Common._getChainParams(chain, this._customChains);\n    } else if (typeof chain === 'object') {\n      if (this._customChains.length > 0) {\n        throw new Error('Chain must be a string, number, or bigint when initialized with customChains passed in');\n      }\n      const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];\n      for (const param of required) {\n        if (!(param in chain)) {\n          throw new Error(`Missing required chain parameter: ${param}`);\n        }\n      }\n      this._chainParams = chain;\n    } else {\n      throw new Error('Wrong input format');\n    }\n    for (const hf of this.hardforks()) {\n      if (hf.block === undefined) {\n        throw new Error(`Hardfork cannot have undefined block number`);\n      }\n    }\n    return this._chainParams;\n  }\n  /**\n   * Sets the hardfork to get params for\n   * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum\n   */\n  setHardfork(hardfork) {\n    let existing = false;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if (hfChanges[0] === hardfork) {\n        if (this._hardfork !== hardfork) {\n          this._hardfork = hardfork;\n          this.emit('hardforkChanged', hardfork);\n        }\n        existing = true;\n      }\n    }\n    if (!existing) {\n      throw new Error(`Hardfork with name ${hardfork} not supported`);\n    }\n  }\n  /**\n   * Returns the hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)\n   * @param timestamp: timestamp in seconds at which block was/is to be minted\n   * @returns The name of the HF\n   */\n  getHardforkByBlockNumber(blockNumber, td, timestamp) {\n    blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n    td = (0, util_1.toType)(td, util_1.TypeOutput.BigInt);\n    timestamp = (0, util_1.toType)(timestamp, util_1.TypeOutput.Number);\n    // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)\n    const hfs = this.hardforks().filter(hf => hf.block !== null || hf.ttd !== null && hf.ttd !== undefined || hf.timestamp !== undefined);\n    const mergeIndex = hfs.findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n    const doubleTTDHF = hfs.slice(mergeIndex + 1).findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n    if (doubleTTDHF >= 0) {\n      throw Error(`More than one merge hardforks found with ttd specified`);\n    }\n    // Find the first hardfork that has a block number greater than `blockNumber`\n    // (skips the merge hardfork since it cannot have a block number specified).\n    // If timestamp is not provided, it also skips timestamps hardforks to continue\n    // discovering/checking number hardforks.\n    let hfIndex = hfs.findIndex(hf => hf.block !== null && hf.block > blockNumber || timestamp !== undefined && Number(hf.timestamp) > timestamp);\n    if (hfIndex === -1) {\n      // all hardforks apply, set hfIndex to the last one as that's the candidate\n      hfIndex = hfs.length;\n    } else if (hfIndex === 0) {\n      // cannot have a case where a block number is before all applied hardforks\n      // since the chain has to start with a hardfork\n      throw Error('Must have at least one hardfork at block 0');\n    }\n    // If timestamp is not provided, we need to rollback to the last hf with block or ttd\n    if (timestamp === undefined) {\n      const stepBack = hfs.slice(0, hfIndex).reverse().findIndex(hf => hf.block !== null || hf.ttd !== undefined);\n      hfIndex = hfIndex - stepBack;\n    }\n    // Move hfIndex one back to arrive at candidate hardfork\n    hfIndex = hfIndex - 1;\n    // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number\n    // hardforks. so it will now be needed to rollback\n    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {\n      // We're on the merge hardfork.  Let's check the TTD\n      if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd) > td) {\n        // Merge ttd greater than current td so we're on hardfork before merge\n        hfIndex -= 1;\n      }\n    } else {\n      if (mergeIndex >= 0 && td !== undefined && td !== null) {\n        if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {\n          throw Error('Maximum HF determined by total difficulty is lower than the block number HF');\n        } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {\n          throw Error('HF determined by block number is lower than the minimum total difficulty HF');\n        }\n      }\n    }\n    const hfStartIndex = hfIndex;\n    // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp\n    // This won't anyway be the case with Merge hfs\n    for (; hfIndex < hfs.length - 1; hfIndex++) {\n      // break out if hfIndex + 1 is not scheduled at hfIndex\n      if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {\n        break;\n      }\n    }\n    if (timestamp) {\n      const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => Math.max(Number(hf.timestamp ?? '0'), acc), 0);\n      if (minTimeStamp > timestamp) {\n        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);\n      }\n      const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => Math.min(Number(hf.timestamp ?? timestamp), acc), timestamp);\n      if (maxTimeStamp < timestamp) {\n        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);\n      }\n    }\n    const hardfork = hfs[hfIndex];\n    return hardfork.name;\n  }\n  /**\n   * Sets a new hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td\n   * @param timestamp\n   * @returns The name of the HF set\n   */\n  setHardforkByBlockNumber(blockNumber, td, timestamp) {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);\n    this.setHardfork(hardfork);\n    return hardfork;\n  }\n  /**\n   * Internal helper function, returns the params for the given hardfork for the chain set\n   * @param hardfork Hardfork name\n   * @returns Dictionary with hardfork params or null if hardfork not on chain\n   */\n  _getHardfork(hardfork) {\n    const hfs = this.hardforks();\n    for (const hf of hfs) {\n      if (hf['name'] === hardfork) return hf;\n    }\n    return null;\n  }\n  /**\n   * Sets the active EIPs\n   * @param eips\n   */\n  setEIPs(eips = []) {\n    for (const eip of eips) {\n      if (!(eip in eips_1.EIPs)) {\n        throw new Error(`${eip} not supported`);\n      }\n      const minHF = this.gteHardfork(eips_1.EIPs[eip]['minimumHardfork']);\n      if (!minHF) {\n        throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);\n      }\n      if (eips_1.EIPs[eip].requiredEIPs !== undefined) {\n        for (const elem of eips_1.EIPs[eip].requiredEIPs) {\n          if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {\n            throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);\n          }\n        }\n      }\n    }\n    this._eips = eips;\n  }\n  /**\n   * Returns a parameter for the current chain setup\n   *\n   * If the parameter is present in an EIP, the EIP always takes precedence.\n   * Otherwise the parameter if taken from the latest applied HF with\n   * a change on the respective parameter.\n   *\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  param(topic, name) {\n    // TODO: consider the case that different active EIPs\n    // can change the same parameter\n    let value;\n    for (const eip of this._eips) {\n      value = this.paramByEIP(topic, name, eip);\n      if (value !== undefined) return value;\n    }\n    return this.paramByHardfork(topic, name, this._hardfork);\n  }\n  /**\n   * Returns the parameter corresponding to a hardfork\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param hardfork Hardfork name\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByHardfork(topic, name, hardfork) {\n    let value = null;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // EIP-referencing HF file (e.g. berlin.json)\n      if ('eips' in hfChanges[1]) {\n        const hfEIPs = hfChanges[1]['eips'];\n        for (const eip of hfEIPs) {\n          const valueEIP = this.paramByEIP(topic, name, eip);\n          value = typeof valueEIP === 'bigint' ? valueEIP : value;\n        }\n        // Parameter-inlining HF file (e.g. istanbul.json)\n      } else {\n        if (hfChanges[1][topic] === undefined) {\n          throw new Error(`Topic ${topic} not defined`);\n        }\n        if (hfChanges[1][topic][name] !== undefined) {\n          value = hfChanges[1][topic][name].v;\n        }\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    return BigInt(value ?? 0);\n  }\n  /**\n   * Returns a parameter corresponding to an EIP\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param eip Number of the EIP\n   * @returns The value requested or `undefined` if not found\n   */\n  paramByEIP(topic, name, eip) {\n    if (!(eip in eips_1.EIPs)) {\n      throw new Error(`${eip} not supported`);\n    }\n    const eipParams = eips_1.EIPs[eip];\n    if (!(topic in eipParams)) {\n      throw new Error(`Topic ${topic} not defined`);\n    }\n    if (eipParams[topic][name] === undefined) {\n      return undefined;\n    }\n    const value = eipParams[topic][name].v;\n    return BigInt(value);\n  }\n  /**\n   * Returns a parameter for the hardfork active on block number or\n   * optional provided total difficulty (Merge HF)\n   * @param topic Parameter topic\n   * @param name Parameter name\n   * @param blockNumber Block number\n   * @param td Total difficulty\n   *    * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByBlock(topic, name, blockNumber, td, timestamp) {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);\n    return this.paramByHardfork(topic, name, hardfork);\n  }\n  /**\n   * Checks if an EIP is activated by either being included in the EIPs\n   * manually passed in with the {@link CommonOpts.eips} or in a\n   * hardfork currently being active\n   *\n   * Note: this method only works for EIPs being supported\n   * by the {@link CommonOpts.eips} constructor option\n   * @param eip\n   */\n  isActivatedEIP(eip) {\n    if (this.eips().includes(eip)) {\n      return true;\n    }\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1];\n      if (this.gteHardfork(hf['name']) && 'eips' in hf) {\n        if (hf['eips'].includes(eip)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks if set or provided hardfork is active on block number\n   * @param hardfork Hardfork name or null (for HF set)\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  hardforkIsActiveOnBlock(hardfork, blockNumber) {\n    blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n    hardfork = hardfork ?? this._hardfork;\n    const hfBlock = this.hardforkBlock(hardfork);\n    if (typeof hfBlock === 'bigint' && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Alias to hardforkIsActiveOnBlock when hardfork is set\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  activeOnBlock(blockNumber) {\n    return this.hardforkIsActiveOnBlock(null, blockNumber);\n  }\n  /**\n   * Sequence based check if given or set HF1 is greater than or equal HF2\n   * @param hardfork1 Hardfork name or null (if set)\n   * @param hardfork2 Hardfork name\n   * @param opts Hardfork options\n   * @returns True if HF1 gte HF2\n   */\n  hardforkGteHardfork(hardfork1, hardfork2) {\n    hardfork1 = hardfork1 ?? this._hardfork;\n    const hardforks = this.hardforks();\n    let posHf1 = -1,\n      posHf2 = -1;\n    let index = 0;\n    for (const hf of hardforks) {\n      if (hf['name'] === hardfork1) posHf1 = index;\n      if (hf['name'] === hardfork2) posHf2 = index;\n      index += 1;\n    }\n    return posHf1 >= posHf2 && posHf2 !== -1;\n  }\n  /**\n   * Alias to hardforkGteHardfork when hardfork is set\n   * @param hardfork Hardfork name\n   * @returns True if hardfork set is greater than hardfork provided\n   */\n  gteHardfork(hardfork) {\n    return this.hardforkGteHardfork(null, hardfork);\n  }\n  /**\n   * Returns the hardfork change block for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if unscheduled\n   */\n  hardforkBlock(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    const block = this._getHardfork(hardfork)?.['block'];\n    if (block === undefined || block === null) {\n      return null;\n    }\n    return BigInt(block);\n  }\n  hardforkTimestamp(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    const timestamp = this._getHardfork(hardfork)?.['timestamp'];\n    if (timestamp === undefined || timestamp === null) {\n      return null;\n    }\n    return BigInt(timestamp);\n  }\n  /**\n   * Returns the hardfork change block for eip\n   * @param eip EIP number\n   * @returns Block number or null if unscheduled\n   */\n  eipBlock(eip) {\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1];\n      if ('eips' in hf) {\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (hf['eips'].includes(eip)) {\n          return this.hardforkBlock(hfChanges[0]);\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Total difficulty or null if no set\n   */\n  hardforkTTD(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    const ttd = this._getHardfork(hardfork)?.['ttd'];\n    if (ttd === undefined || ttd === null) {\n      return null;\n    }\n    return BigInt(ttd);\n  }\n  /**\n   * True if block number provided is the hardfork (given or set) change block\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n  isHardforkBlock(blockNumber, hardfork) {\n    blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n    hardfork = hardfork ?? this._hardfork;\n    const block = this.hardforkBlock(hardfork);\n    return typeof block === 'bigint' && block !== BigInt(0) ? block === blockNumber : false;\n  }\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block timestamp, number or null if not available\n   */\n  nextHardforkBlockOrTimestamp(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    const hfs = this.hardforks();\n    let hfIndex = hfs.findIndex(hf => hf.name === hardfork);\n    // If the current hardfork is merge, go one behind as merge hf is not part of these\n    // calcs even if the merge hf block is set\n    if (hardfork === enums_1.Hardfork.Merge) {\n      hfIndex -= 1;\n    }\n    // Hardfork not found\n    if (hfIndex < 0) {\n      return null;\n    }\n    let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block;\n    currHfTimeOrBlock = currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined ? Number(currHfTimeOrBlock) : null;\n    const nextHf = hfs.slice(hfIndex + 1).find(hf => {\n      let hfTimeOrBlock = hf.timestamp ?? hf.block;\n      hfTimeOrBlock = hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null;\n      return hf.name !== enums_1.Hardfork.Merge && hfTimeOrBlock !== null && hfTimeOrBlock !== undefined && hfTimeOrBlock !== currHfTimeOrBlock;\n    });\n    // If no next hf found with valid block or timestamp return null\n    if (nextHf === undefined) {\n      return null;\n    }\n    const nextHfBlock = nextHf.timestamp ?? nextHf.block;\n    if (nextHfBlock === null || nextHfBlock === undefined) {\n      return null;\n    }\n    return BigInt(nextHfBlock);\n  }\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if not available\n   * @deprecated\n   */\n  nextHardforkBlock(hardfork) {\n    hardfork = hardfork ?? this._hardfork;\n    let hfBlock = this.hardforkBlock(hardfork);\n    // If this is a merge hardfork with block not set, then we fallback to previous hardfork\n    // to find the nextHardforkBlock\n    if (hfBlock === null && hardfork === enums_1.Hardfork.Merge) {\n      const hfs = this.hardforks();\n      const mergeIndex = hfs.findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n      if (mergeIndex < 0) {\n        throw Error(`Merge hardfork should have been found`);\n      }\n      hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);\n    }\n    if (hfBlock === null) {\n      return null;\n    }\n    // Next fork block number or null if none available\n    // Logic: if accumulator is still null and on the first occurrence of\n    // a block greater than the current hfBlock set the accumulator,\n    // pass on the accumulator as the final result from this time on\n    const nextHfBlock = this.hardforks().reduce((acc, hf) => {\n      // We need to ignore the merge block in our next hardfork calc\n      const block = BigInt(hf.block === null || hf.ttd !== undefined && hf.ttd !== null ? 0 : hf.block);\n      // Typescript can't seem to follow that the hfBlock is not null at this point\n      return block > hfBlock && acc === null ? block : acc;\n    }, null);\n    return nextHfBlock;\n  }\n  /**\n   * True if block number provided is the hardfork change block following the hardfork given or set\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n  isNextHardforkBlock(blockNumber, hardfork) {\n    blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);\n    hardfork = hardfork ?? this._hardfork;\n    const nextHardforkBlock = this.nextHardforkBlock(hardfork);\n    return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;\n  }\n  /**\n   * Internal helper function to calculate a fork hash\n   * @param hardfork Hardfork name\n   * @param genesisHash Genesis block hash of the chain\n   * @returns Fork hash as hex string\n   */\n  _calcForkHash(hardfork, genesisHash) {\n    let hfBuffer = Buffer.alloc(0);\n    let prevBlockOrTime = 0;\n    for (const hf of this.hardforks()) {\n      const {\n        block,\n        timestamp,\n        name\n      } = hf;\n      // Timestamp to be used for timestamp based hfs even if we may bundle\n      // block number with them retrospectively\n      let blockOrTime = timestamp ?? block;\n      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;\n      // Skip for chainstart (0), not applied HFs (null) and\n      // when already applied on same blockOrTime HFs\n      // and on the merge since forkhash doesn't change on merge hf\n      if (typeof blockOrTime === 'number' && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name !== enums_1.Hardfork.Merge) {\n        const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, '0'), 'hex');\n        hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer]);\n        prevBlockOrTime = blockOrTime;\n      }\n      if (hf.name === hardfork) break;\n    }\n    const inputBuffer = Buffer.concat([genesisHash, hfBuffer]);\n    // CRC32 delivers result as signed (negative) 32-bit integer,\n    // convert to hex string\n    const forkhash = (0, util_1.intToBuffer)((0, crc_32_1.buf)(inputBuffer) >>> 0).toString('hex');\n    return `0x${forkhash}`;\n  }\n  /**\n   * Returns an eth/64 compliant fork hash (EIP-2124)\n   * @param hardfork Hardfork name, optional if HF set\n   * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated\n   */\n  forkHash(hardfork, genesisHash) {\n    hardfork = hardfork ?? this._hardfork;\n    const data = this._getHardfork(hardfork);\n    if (data === null || data?.block === null && data?.timestamp === undefined && data?.ttd === undefined) {\n      const msg = 'No fork hash calculation possible for future hardfork';\n      throw new Error(msg);\n    }\n    if (data?.forkHash !== null && data?.forkHash !== undefined) {\n      return data.forkHash;\n    }\n    if (!genesisHash) throw new Error('genesisHash required for forkHash calculation');\n    return this._calcForkHash(hardfork, genesisHash);\n  }\n  /**\n   *\n   * @param forkHash Fork hash as a hex string\n   * @returns Array with hardfork data (name, block, forkHash)\n   */\n  hardforkForForkHash(forkHash) {\n    const resArray = this.hardforks().filter(hf => {\n      return hf.forkHash === forkHash;\n    });\n    return resArray.length >= 1 ? resArray[resArray.length - 1] : null;\n  }\n  /**\n   * Sets any missing forkHashes on the passed-in {@link Common} instance\n   * @param common The {@link Common} to set the forkHashes for\n   * @param genesisHash The genesis block hash\n   */\n  setForkHashes(genesisHash) {\n    for (const hf of this.hardforks()) {\n      const blockOrTime = hf.timestamp ?? hf.block;\n      if ((hf.forkHash === null || hf.forkHash === undefined) && (blockOrTime !== null && blockOrTime !== undefined || typeof hf.ttd !== 'undefined')) {\n        hf.forkHash = this.forkHash(hf.name, genesisHash);\n      }\n    }\n  }\n  /**\n   * Returns the Genesis parameters of the current chain\n   * @returns Genesis dictionary\n   */\n  genesis() {\n    return this._chainParams.genesis;\n  }\n  /**\n   * Returns the hardforks for current chain\n   * @returns {Array} Array with arrays of hardforks\n   */\n  hardforks() {\n    return this._chainParams.hardforks;\n  }\n  /**\n   * Returns bootstrap nodes for the current chain\n   * @returns {Dictionary} Dict with bootstrap nodes\n   */\n  bootstrapNodes() {\n    return this._chainParams.bootstrapNodes;\n  }\n  /**\n   * Returns DNS networks for the current chain\n   * @returns {String[]} Array of DNS ENR urls\n   */\n  dnsNetworks() {\n    return this._chainParams.dnsNetworks;\n  }\n  /**\n   * Returns the hardfork set\n   * @returns Hardfork name\n   */\n  hardfork() {\n    return this._hardfork;\n  }\n  /**\n   * Returns the Id of current chain\n   * @returns chain Id\n   */\n  chainId() {\n    return BigInt(this._chainParams.chainId);\n  }\n  /**\n   * Returns the name of current chain\n   * @returns chain name (lower case)\n   */\n  chainName() {\n    return this._chainParams.name;\n  }\n  /**\n   * Returns the Id of current network\n   * @returns network Id\n   */\n  networkId() {\n    return BigInt(this._chainParams.networkId);\n  }\n  /**\n   * Returns the active EIPs\n   * @returns List of EIPs\n   */\n  eips() {\n    return this._eips;\n  }\n  /**\n   * Returns the consensus type of the network\n   * Possible values: \"pow\"|\"poa\"|\"pos\"\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusType() {\n    const hardfork = this.hardfork();\n    let value;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['type'];\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    return value ?? this._chainParams['consensus']['type'];\n  }\n  /**\n   * Returns the concrete consensus implementation\n   * algorithm or protocol for the network\n   * e.g. \"ethash\" for \"pow\" consensus type,\n   * \"clique\" for \"poa\" consensus type or\n   * \"casper\" for \"pos\" consensus type.\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusAlgorithm() {\n    const hardfork = this.hardfork();\n    let value;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['algorithm'];\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    return value ?? this._chainParams['consensus']['algorithm'];\n  }\n  /**\n   * Returns a dictionary with consensus configuration\n   * parameters based on the consensus algorithm\n   *\n   * Expected returns (parameters must be present in\n   * the respective chain json files):\n   *\n   * ethash: empty object\n   * clique: period, epoch\n   * casper: empty object\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusConfig() {\n    const hardfork = this.hardfork();\n    let value;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        // The config parameter is named after the respective consensus algorithm\n        value = hfChanges[1]['consensus'][hfChanges[1]['consensus']['algorithm']];\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    return value ?? this._chainParams['consensus'][this.consensusAlgorithm()] ?? {};\n  }\n  /**\n   * Returns a deep copy of this {@link Common} instance.\n   */\n  copy() {\n    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n    copy.removeAllListeners();\n    return copy;\n  }\n  static _getInitializedChains(customChains) {\n    const names = {};\n    for (const [name, id] of Object.entries(enums_1.Chain)) {\n      names[id] = name.toLowerCase();\n    }\n    const chains = {\n      mainnet,\n      ropsten,\n      rinkeby,\n      goerli,\n      sepolia\n    };\n    if (customChains) {\n      for (const chain of customChains) {\n        const {\n          name\n        } = chain;\n        names[chain.chainId.toString()] = name;\n        chains[name] = chain;\n      }\n    }\n    chains.names = names;\n    return chains;\n  }\n}\nexports.Common = Common;","map":{"version":3,"names":["util_1","require","crc_32_1","events_1","goerli","mainnet","rinkeby","ropsten","sepolia","eips_1","enums_1","hardforks_1","utils_1","Common","EventEmitter","constructor","opts","_eips","_customChains","customChains","_chainParams","setChain","chain","DEFAULT_HARDFORK","defaultHardfork","Hardfork","Merge","HARDFORK_CHANGES","hardforks","map","hf","name","_hardfork","hardfork","undefined","setHardfork","eips","setEIPs","custom","chainParamsOrName","baseChain","standardChainParams","_getChainParams","CustomChain","PolygonMainnet","chainId","networkId","PolygonMumbai","ArbitrumRinkebyTestnet","ArbitrumOne","xDaiChain","OptimisticKovan","Berlin","OptimisticEthereum","Error","fromGethGenesis","genesisJson","genesisHash","mergeForkIdPostMerge","genesisParams","parseGethGenesis","common","setForkHashes","isSupportedChainId","initializedChains","_getInitializedChains","Boolean","toString","length","required","param","block","existing","hfChanges","emit","getHardforkByBlockNumber","blockNumber","td","timestamp","toType","TypeOutput","BigInt","Number","hfs","filter","ttd","mergeIndex","findIndex","doubleTTDHF","slice","hfIndex","stepBack","reverse","hfStartIndex","minTimeStamp","reduce","acc","Math","max","maxTimeStamp","min","setHardforkByBlockNumber","_getHardfork","eip","EIPs","minHF","gteHardfork","requiredEIPs","elem","includes","isActivatedEIP","topic","value","paramByEIP","paramByHardfork","hfEIPs","valueEIP","v","eipParams","paramByBlock","hardforkIsActiveOnBlock","hfBlock","hardforkBlock","activeOnBlock","hardforkGteHardfork","hardfork1","hardfork2","posHf1","posHf2","index","hardforkTimestamp","eipBlock","hardforkTTD","isHardforkBlock","nextHardforkBlockOrTimestamp","currHfTimeOrBlock","nextHf","find","hfTimeOrBlock","nextHfBlock","nextHardforkBlock","isNextHardforkBlock","_calcForkHash","hfBuffer","Buffer","alloc","prevBlockOrTime","blockOrTime","hfBlockBuffer","from","padStart","concat","inputBuffer","forkhash","intToBuffer","buf","forkHash","data","msg","hardforkForForkHash","resArray","genesis","bootstrapNodes","dnsNetworks","chainName","consensusType","consensusAlgorithm","consensusConfig","copy","Object","assign","create","getPrototypeOf","removeAllListeners","names","id","entries","Chain","toLowerCase","chains","exports"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@ethereumjs/common/src/common.ts"],"sourcesContent":["import { TypeOutput, intToBuffer, toType } from '@ethereumjs/util'\nimport { buf as crc32Buffer } from 'crc-32'\nimport { EventEmitter } from 'events'\n\nimport * as goerli from './chains/goerli.json'\nimport * as mainnet from './chains/mainnet.json'\nimport * as rinkeby from './chains/rinkeby.json'\nimport * as ropsten from './chains/ropsten.json'\nimport * as sepolia from './chains/sepolia.json'\nimport { EIPs } from './eips'\nimport { Chain, CustomChain, Hardfork } from './enums'\nimport { hardforks as HARDFORK_SPECS } from './hardforks'\nimport { parseGethGenesis } from './utils'\n\nimport type { ConsensusAlgorithm, ConsensusType } from './enums'\nimport type {\n  BootstrapNodeConfig,\n  CasperConfig,\n  ChainConfig,\n  ChainName,\n  ChainsConfig,\n  CliqueConfig,\n  CommonOpts,\n  CustomCommonOpts,\n  EthashConfig,\n  GenesisBlockConfig,\n  GethConfigOpts,\n  HardforkConfig,\n} from './types'\nimport type { BigIntLike } from '@ethereumjs/util'\n\ntype HardforkSpecKeys = keyof typeof HARDFORK_SPECS\ntype HardforkSpecValues = typeof HARDFORK_SPECS[HardforkSpecKeys]\n/**\n * Common class to access chain and hardfork parameters and to provide\n * a unified and shared view on the network and hardfork state.\n *\n * Use the {@link Common.custom} static constructor for creating simple\n * custom chain {@link Common} objects (more complete custom chain setups\n * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).\n */\nexport class Common extends EventEmitter {\n  readonly DEFAULT_HARDFORK: string | Hardfork\n\n  private _chainParams: ChainConfig\n  private _hardfork: string | Hardfork\n  private _eips: number[] = []\n  private _customChains: ChainConfig[]\n\n  private HARDFORK_CHANGES: [HardforkSpecKeys, HardforkSpecValues][]\n\n  /**\n   * Creates a {@link Common} object for a custom chain, based on a standard one.\n   *\n   * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden\n   * in a provided {@link chainParamsOrName} dictionary. Some usage example:\n   *\n   * ```javascript\n   * Common.custom({chainId: 123})\n   * ```\n   *\n   * There are also selected supported custom chains which can be initialized by using one of the\n   * {@link CustomChains} for {@link chainParamsOrName}, e.g.:\n   *\n   * ```javascript\n   * Common.custom(CustomChains.MaticMumbai)\n   * ```\n   *\n   * Note that these supported custom chains only provide some base parameters (usually the chain and\n   * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with\n   * the `@ethereumjs/tx` library to a Layer-2 chain).\n   *\n   * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain\n   * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others\n   */\n  static custom(\n    chainParamsOrName: Partial<ChainConfig> | CustomChain,\n    opts: CustomCommonOpts = {}\n  ): Common {\n    const baseChain = opts.baseChain ?? 'mainnet'\n    const standardChainParams = { ...Common._getChainParams(baseChain) }\n    standardChainParams['name'] = 'custom-chain'\n\n    if (typeof chainParamsOrName !== 'string') {\n      return new Common({\n        chain: {\n          ...standardChainParams,\n          ...chainParamsOrName,\n        },\n        ...opts,\n      })\n    } else {\n      if (chainParamsOrName === CustomChain.PolygonMainnet) {\n        return Common.custom(\n          {\n            name: CustomChain.PolygonMainnet,\n            chainId: 137,\n            networkId: 137,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.PolygonMumbai) {\n        return Common.custom(\n          {\n            name: CustomChain.PolygonMumbai,\n            chainId: 80001,\n            networkId: 80001,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.ArbitrumRinkebyTestnet) {\n        return Common.custom(\n          {\n            name: CustomChain.ArbitrumRinkebyTestnet,\n            chainId: 421611,\n            networkId: 421611,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.ArbitrumOne) {\n        return Common.custom(\n          {\n            name: CustomChain.ArbitrumOne,\n            chainId: 42161,\n            networkId: 42161,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.xDaiChain) {\n        return Common.custom(\n          {\n            name: CustomChain.xDaiChain,\n            chainId: 100,\n            networkId: 100,\n          },\n          opts\n        )\n      }\n\n      if (chainParamsOrName === CustomChain.OptimisticKovan) {\n        return Common.custom(\n          {\n            name: CustomChain.OptimisticKovan,\n            chainId: 69,\n            networkId: 69,\n          },\n          // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n          { hardfork: Hardfork.Berlin, ...opts }\n        )\n      }\n\n      if (chainParamsOrName === CustomChain.OptimisticEthereum) {\n        return Common.custom(\n          {\n            name: CustomChain.OptimisticEthereum,\n            chainId: 10,\n            networkId: 10,\n          },\n          // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n          { hardfork: Hardfork.Berlin, ...opts }\n        )\n      }\n      throw new Error(`Custom chain ${chainParamsOrName} not supported`)\n    }\n  }\n\n  /**\n   * Static method to load and set common from a geth genesis json\n   * @param genesisJson json of geth configuration\n   * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance\n   * @returns Common\n   */\n  static fromGethGenesis(\n    genesisJson: any,\n    { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }: GethConfigOpts\n  ): Common {\n    const genesisParams = parseGethGenesis(genesisJson, chain, mergeForkIdPostMerge)\n    const common = new Common({\n      chain: genesisParams.name ?? 'custom',\n      customChains: [genesisParams],\n      eips,\n      hardfork: hardfork ?? genesisParams.hardfork,\n    })\n    if (genesisHash !== undefined) {\n      common.setForkHashes(genesisHash)\n    }\n    return common\n  }\n\n  /**\n   * Static method to determine if a {@link chainId} is supported as a standard chain\n   * @param chainId bigint id (`1`) of a standard chain\n   * @returns boolean\n   */\n  static isSupportedChainId(chainId: bigint): boolean {\n    const initializedChains = this._getInitializedChains()\n    return Boolean((initializedChains['names'] as ChainName)[chainId.toString()])\n  }\n\n  private static _getChainParams(\n    chain: string | number | Chain | bigint,\n    customChains?: ChainConfig[]\n  ): ChainConfig {\n    const initializedChains = this._getInitializedChains(customChains)\n    if (typeof chain === 'number' || typeof chain === 'bigint') {\n      chain = chain.toString()\n\n      if ((initializedChains['names'] as ChainName)[chain]) {\n        const name: string = (initializedChains['names'] as ChainName)[chain]\n        return initializedChains[name] as ChainConfig\n      }\n\n      throw new Error(`Chain with ID ${chain} not supported`)\n    }\n\n    if (initializedChains[chain] !== undefined) {\n      return initializedChains[chain] as ChainConfig\n    }\n\n    throw new Error(`Chain with name ${chain} not supported`)\n  }\n\n  constructor(opts: CommonOpts) {\n    super()\n    this._customChains = opts.customChains ?? []\n    this._chainParams = this.setChain(opts.chain)\n    this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? Hardfork.Merge\n    // Assign hardfork changes in the sequence of the applied hardforks\n    this.HARDFORK_CHANGES = this.hardforks().map((hf) => [\n      hf.name as HardforkSpecKeys,\n      HARDFORK_SPECS[hf.name as HardforkSpecKeys],\n    ])\n    this._hardfork = this.DEFAULT_HARDFORK\n    if (opts.hardfork !== undefined) {\n      this.setHardfork(opts.hardfork)\n    }\n    if (opts.eips) {\n      this.setEIPs(opts.eips)\n    }\n  }\n\n  /**\n   * Sets the chain\n   * @param chain String ('mainnet') or Number (1) chain representation.\n   *              Or, a Dictionary of chain parameters for a private network.\n   * @returns The dictionary with parameters set as chain\n   */\n  setChain(chain: string | number | Chain | bigint | object): ChainConfig {\n    if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {\n      this._chainParams = Common._getChainParams(chain, this._customChains)\n    } else if (typeof chain === 'object') {\n      if (this._customChains.length > 0) {\n        throw new Error(\n          'Chain must be a string, number, or bigint when initialized with customChains passed in'\n        )\n      }\n      const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes']\n      for (const param of required) {\n        if (!(param in chain)) {\n          throw new Error(`Missing required chain parameter: ${param}`)\n        }\n      }\n      this._chainParams = chain as ChainConfig\n    } else {\n      throw new Error('Wrong input format')\n    }\n    for (const hf of this.hardforks()) {\n      if (hf.block === undefined) {\n        throw new Error(`Hardfork cannot have undefined block number`)\n      }\n    }\n    return this._chainParams\n  }\n\n  /**\n   * Sets the hardfork to get params for\n   * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum\n   */\n  setHardfork(hardfork: string | Hardfork): void {\n    let existing = false\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if (hfChanges[0] === hardfork) {\n        if (this._hardfork !== hardfork) {\n          this._hardfork = hardfork\n          this.emit('hardforkChanged', hardfork)\n        }\n        existing = true\n      }\n    }\n    if (!existing) {\n      throw new Error(`Hardfork with name ${hardfork} not supported`)\n    }\n  }\n\n  /**\n   * Returns the hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)\n   * @param timestamp: timestamp in seconds at which block was/is to be minted\n   * @returns The name of the HF\n   */\n  getHardforkByBlockNumber(\n    blockNumber: BigIntLike,\n    td?: BigIntLike,\n    timestamp?: BigIntLike\n  ): string {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    td = toType(td, TypeOutput.BigInt)\n    timestamp = toType(timestamp, TypeOutput.Number)\n\n    // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)\n    const hfs = this.hardforks().filter(\n      (hf) =>\n        hf.block !== null || (hf.ttd !== null && hf.ttd !== undefined) || hf.timestamp !== undefined\n    )\n    const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n    const doubleTTDHF = hfs\n      .slice(mergeIndex + 1)\n      .findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n    if (doubleTTDHF >= 0) {\n      throw Error(`More than one merge hardforks found with ttd specified`)\n    }\n\n    // Find the first hardfork that has a block number greater than `blockNumber`\n    // (skips the merge hardfork since it cannot have a block number specified).\n    // If timestamp is not provided, it also skips timestamps hardforks to continue\n    // discovering/checking number hardforks.\n    let hfIndex = hfs.findIndex(\n      (hf) =>\n        (hf.block !== null && hf.block > blockNumber) ||\n        (timestamp !== undefined && Number(hf.timestamp) > timestamp)\n    )\n\n    if (hfIndex === -1) {\n      // all hardforks apply, set hfIndex to the last one as that's the candidate\n      hfIndex = hfs.length\n    } else if (hfIndex === 0) {\n      // cannot have a case where a block number is before all applied hardforks\n      // since the chain has to start with a hardfork\n      throw Error('Must have at least one hardfork at block 0')\n    }\n\n    // If timestamp is not provided, we need to rollback to the last hf with block or ttd\n    if (timestamp === undefined) {\n      const stepBack = hfs\n        .slice(0, hfIndex)\n        .reverse()\n        .findIndex((hf) => hf.block !== null || hf.ttd !== undefined)\n      hfIndex = hfIndex - stepBack\n    }\n    // Move hfIndex one back to arrive at candidate hardfork\n    hfIndex = hfIndex - 1\n\n    // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number\n    // hardforks. so it will now be needed to rollback\n    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {\n      // We're on the merge hardfork.  Let's check the TTD\n      if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd!) > td) {\n        // Merge ttd greater than current td so we're on hardfork before merge\n        hfIndex -= 1\n      }\n    } else {\n      if (mergeIndex >= 0 && td !== undefined && td !== null) {\n        if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd!) > td) {\n          throw Error('Maximum HF determined by total difficulty is lower than the block number HF')\n        } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd!) <= td) {\n          throw Error('HF determined by block number is lower than the minimum total difficulty HF')\n        }\n      }\n    }\n\n    const hfStartIndex = hfIndex\n    // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp\n    // This won't anyway be the case with Merge hfs\n    for (; hfIndex < hfs.length - 1; hfIndex++) {\n      // break out if hfIndex + 1 is not scheduled at hfIndex\n      if (\n        hfs[hfIndex].block !== hfs[hfIndex + 1].block ||\n        hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp\n      ) {\n        break\n      }\n    }\n\n    if (timestamp) {\n      const minTimeStamp = hfs\n        .slice(0, hfStartIndex)\n        .reduce((acc: number, hf: HardforkConfig) => Math.max(Number(hf.timestamp ?? '0'), acc), 0)\n      if (minTimeStamp > timestamp) {\n        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`)\n      }\n\n      const maxTimeStamp = hfs\n        .slice(hfIndex + 1)\n        .reduce(\n          (acc: number, hf: HardforkConfig) => Math.min(Number(hf.timestamp ?? timestamp), acc),\n          timestamp\n        )\n      if (maxTimeStamp < timestamp) {\n        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`)\n      }\n    }\n    const hardfork = hfs[hfIndex]\n    return hardfork.name\n  }\n\n  /**\n   * Sets a new hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td\n   * @param timestamp\n   * @returns The name of the HF set\n   */\n  setHardforkByBlockNumber(\n    blockNumber: BigIntLike,\n    td?: BigIntLike,\n    timestamp?: BigIntLike\n  ): string {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp)\n    this.setHardfork(hardfork)\n    return hardfork\n  }\n\n  /**\n   * Internal helper function, returns the params for the given hardfork for the chain set\n   * @param hardfork Hardfork name\n   * @returns Dictionary with hardfork params or null if hardfork not on chain\n   */\n  _getHardfork(hardfork: string | Hardfork): HardforkConfig | null {\n    const hfs = this.hardforks()\n    for (const hf of hfs) {\n      if (hf['name'] === hardfork) return hf\n    }\n    return null\n  }\n\n  /**\n   * Sets the active EIPs\n   * @param eips\n   */\n  setEIPs(eips: number[] = []) {\n    for (const eip of eips) {\n      if (!(eip in EIPs)) {\n        throw new Error(`${eip} not supported`)\n      }\n      const minHF = this.gteHardfork(EIPs[eip]['minimumHardfork'])\n      if (!minHF) {\n        throw new Error(\n          `${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`\n        )\n      }\n      if (EIPs[eip].requiredEIPs !== undefined) {\n        for (const elem of EIPs[eip].requiredEIPs) {\n          if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {\n            throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`)\n          }\n        }\n      }\n    }\n    this._eips = eips\n  }\n\n  /**\n   * Returns a parameter for the current chain setup\n   *\n   * If the parameter is present in an EIP, the EIP always takes precedence.\n   * Otherwise the parameter if taken from the latest applied HF with\n   * a change on the respective parameter.\n   *\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  param(topic: string, name: string): bigint {\n    // TODO: consider the case that different active EIPs\n    // can change the same parameter\n    let value\n    for (const eip of this._eips) {\n      value = this.paramByEIP(topic, name, eip)\n      if (value !== undefined) return value\n    }\n    return this.paramByHardfork(topic, name, this._hardfork)\n  }\n\n  /**\n   * Returns the parameter corresponding to a hardfork\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param hardfork Hardfork name\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByHardfork(topic: string, name: string, hardfork: string | Hardfork): bigint {\n    let value = null\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // EIP-referencing HF file (e.g. berlin.json)\n      if ('eips' in hfChanges[1]) {\n        const hfEIPs = hfChanges[1]['eips']\n        for (const eip of hfEIPs) {\n          const valueEIP = this.paramByEIP(topic, name, eip)\n          value = typeof valueEIP === 'bigint' ? valueEIP : value\n        }\n        // Parameter-inlining HF file (e.g. istanbul.json)\n      } else {\n        if (hfChanges[1][topic] === undefined) {\n          throw new Error(`Topic ${topic} not defined`)\n        }\n        if (hfChanges[1][topic][name] !== undefined) {\n          value = hfChanges[1][topic][name].v\n        }\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return BigInt(value ?? 0)\n  }\n\n  /**\n   * Returns a parameter corresponding to an EIP\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param eip Number of the EIP\n   * @returns The value requested or `undefined` if not found\n   */\n  paramByEIP(topic: string, name: string, eip: number): bigint | undefined {\n    if (!(eip in EIPs)) {\n      throw new Error(`${eip} not supported`)\n    }\n\n    const eipParams = EIPs[eip]\n    if (!(topic in eipParams)) {\n      throw new Error(`Topic ${topic} not defined`)\n    }\n    if (eipParams[topic][name] === undefined) {\n      return undefined\n    }\n    const value = eipParams[topic][name].v\n    return BigInt(value)\n  }\n\n  /**\n   * Returns a parameter for the hardfork active on block number or\n   * optional provided total difficulty (Merge HF)\n   * @param topic Parameter topic\n   * @param name Parameter name\n   * @param blockNumber Block number\n   * @param td Total difficulty\n   *    * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByBlock(\n    topic: string,\n    name: string,\n    blockNumber: BigIntLike,\n    td?: BigIntLike,\n    timestamp?: BigIntLike\n  ): bigint {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp)\n    return this.paramByHardfork(topic, name, hardfork)\n  }\n\n  /**\n   * Checks if an EIP is activated by either being included in the EIPs\n   * manually passed in with the {@link CommonOpts.eips} or in a\n   * hardfork currently being active\n   *\n   * Note: this method only works for EIPs being supported\n   * by the {@link CommonOpts.eips} constructor option\n   * @param eip\n   */\n  isActivatedEIP(eip: number): boolean {\n    if (this.eips().includes(eip)) {\n      return true\n    }\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1]\n      if (this.gteHardfork(hf['name']) && 'eips' in hf) {\n        if ((hf['eips'] as number[]).includes(eip)) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  /**\n   * Checks if set or provided hardfork is active on block number\n   * @param hardfork Hardfork name or null (for HF set)\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  hardforkIsActiveOnBlock(hardfork: string | Hardfork | null, blockNumber: BigIntLike): boolean {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    hardfork = hardfork ?? this._hardfork\n    const hfBlock = this.hardforkBlock(hardfork)\n    if (typeof hfBlock === 'bigint' && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Alias to hardforkIsActiveOnBlock when hardfork is set\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  activeOnBlock(blockNumber: BigIntLike): boolean {\n    return this.hardforkIsActiveOnBlock(null, blockNumber)\n  }\n\n  /**\n   * Sequence based check if given or set HF1 is greater than or equal HF2\n   * @param hardfork1 Hardfork name or null (if set)\n   * @param hardfork2 Hardfork name\n   * @param opts Hardfork options\n   * @returns True if HF1 gte HF2\n   */\n  hardforkGteHardfork(hardfork1: string | Hardfork | null, hardfork2: string | Hardfork): boolean {\n    hardfork1 = hardfork1 ?? this._hardfork\n    const hardforks = this.hardforks()\n\n    let posHf1 = -1,\n      posHf2 = -1\n    let index = 0\n    for (const hf of hardforks) {\n      if (hf['name'] === hardfork1) posHf1 = index\n      if (hf['name'] === hardfork2) posHf2 = index\n      index += 1\n    }\n    return posHf1 >= posHf2 && posHf2 !== -1\n  }\n\n  /**\n   * Alias to hardforkGteHardfork when hardfork is set\n   * @param hardfork Hardfork name\n   * @returns True if hardfork set is greater than hardfork provided\n   */\n  gteHardfork(hardfork: string | Hardfork): boolean {\n    return this.hardforkGteHardfork(null, hardfork)\n  }\n\n  /**\n   * Returns the hardfork change block for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if unscheduled\n   */\n  hardforkBlock(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const block = this._getHardfork(hardfork)?.['block']\n    if (block === undefined || block === null) {\n      return null\n    }\n    return BigInt(block)\n  }\n\n  hardforkTimestamp(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const timestamp = this._getHardfork(hardfork)?.['timestamp']\n    if (timestamp === undefined || timestamp === null) {\n      return null\n    }\n    return BigInt(timestamp)\n  }\n\n  /**\n   * Returns the hardfork change block for eip\n   * @param eip EIP number\n   * @returns Block number or null if unscheduled\n   */\n  eipBlock(eip: number): bigint | null {\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1]\n      if ('eips' in hf) {\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (hf['eips'].includes(eip)) {\n          return this.hardforkBlock(hfChanges[0])\n        }\n      }\n    }\n    return null\n  }\n\n  /**\n   * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Total difficulty or null if no set\n   */\n  hardforkTTD(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const ttd = this._getHardfork(hardfork)?.['ttd']\n    if (ttd === undefined || ttd === null) {\n      return null\n    }\n    return BigInt(ttd)\n  }\n\n  /**\n   * True if block number provided is the hardfork (given or set) change block\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n  isHardforkBlock(blockNumber: BigIntLike, hardfork?: string | Hardfork): boolean {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    hardfork = hardfork ?? this._hardfork\n    const block = this.hardforkBlock(hardfork)\n    return typeof block === 'bigint' && block !== BigInt(0) ? block === blockNumber : false\n  }\n\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block timestamp, number or null if not available\n   */\n  nextHardforkBlockOrTimestamp(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const hfs = this.hardforks()\n    let hfIndex = hfs.findIndex((hf) => hf.name === hardfork)\n    // If the current hardfork is merge, go one behind as merge hf is not part of these\n    // calcs even if the merge hf block is set\n    if (hardfork === Hardfork.Merge) {\n      hfIndex -= 1\n    }\n    // Hardfork not found\n    if (hfIndex < 0) {\n      return null\n    }\n\n    let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block\n    currHfTimeOrBlock =\n      currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined\n        ? Number(currHfTimeOrBlock)\n        : null\n\n    const nextHf = hfs.slice(hfIndex + 1).find((hf) => {\n      let hfTimeOrBlock = hf.timestamp ?? hf.block\n      hfTimeOrBlock =\n        hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null\n      return (\n        hf.name !== Hardfork.Merge &&\n        hfTimeOrBlock !== null &&\n        hfTimeOrBlock !== undefined &&\n        hfTimeOrBlock !== currHfTimeOrBlock\n      )\n    })\n    // If no next hf found with valid block or timestamp return null\n    if (nextHf === undefined) {\n      return null\n    }\n\n    const nextHfBlock = nextHf.timestamp ?? nextHf.block\n    if (nextHfBlock === null || nextHfBlock === undefined) {\n      return null\n    }\n\n    return BigInt(nextHfBlock)\n  }\n\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if not available\n   * @deprecated\n   */\n  nextHardforkBlock(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    let hfBlock = this.hardforkBlock(hardfork)\n    // If this is a merge hardfork with block not set, then we fallback to previous hardfork\n    // to find the nextHardforkBlock\n    if (hfBlock === null && hardfork === Hardfork.Merge) {\n      const hfs = this.hardforks()\n      const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n      if (mergeIndex < 0) {\n        throw Error(`Merge hardfork should have been found`)\n      }\n      hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name)\n    }\n    if (hfBlock === null) {\n      return null\n    }\n    // Next fork block number or null if none available\n    // Logic: if accumulator is still null and on the first occurrence of\n    // a block greater than the current hfBlock set the accumulator,\n    // pass on the accumulator as the final result from this time on\n    const nextHfBlock = this.hardforks().reduce((acc: bigint | null, hf: HardforkConfig) => {\n      // We need to ignore the merge block in our next hardfork calc\n      const block = BigInt(\n        hf.block === null || (hf.ttd !== undefined && hf.ttd !== null) ? 0 : hf.block\n      )\n      // Typescript can't seem to follow that the hfBlock is not null at this point\n      return block > hfBlock! && acc === null ? block : acc\n    }, null)\n    return nextHfBlock\n  }\n\n  /**\n   * True if block number provided is the hardfork change block following the hardfork given or set\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n  isNextHardforkBlock(blockNumber: BigIntLike, hardfork?: string | Hardfork): boolean {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    hardfork = hardfork ?? this._hardfork\n    const nextHardforkBlock = this.nextHardforkBlock(hardfork)\n\n    return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber\n  }\n\n  /**\n   * Internal helper function to calculate a fork hash\n   * @param hardfork Hardfork name\n   * @param genesisHash Genesis block hash of the chain\n   * @returns Fork hash as hex string\n   */\n  _calcForkHash(hardfork: string | Hardfork, genesisHash: Buffer) {\n    let hfBuffer = Buffer.alloc(0)\n    let prevBlockOrTime = 0\n    for (const hf of this.hardforks()) {\n      const { block, timestamp, name } = hf\n      // Timestamp to be used for timestamp based hfs even if we may bundle\n      // block number with them retrospectively\n      let blockOrTime = timestamp ?? block\n      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null\n\n      // Skip for chainstart (0), not applied HFs (null) and\n      // when already applied on same blockOrTime HFs\n      // and on the merge since forkhash doesn't change on merge hf\n      if (\n        typeof blockOrTime === 'number' &&\n        blockOrTime !== 0 &&\n        blockOrTime !== prevBlockOrTime &&\n        name !== Hardfork.Merge\n      ) {\n        const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, '0'), 'hex')\n        hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer])\n        prevBlockOrTime = blockOrTime\n      }\n\n      if (hf.name === hardfork) break\n    }\n    const inputBuffer = Buffer.concat([genesisHash, hfBuffer])\n\n    // CRC32 delivers result as signed (negative) 32-bit integer,\n    // convert to hex string\n    const forkhash = intToBuffer(crc32Buffer(inputBuffer) >>> 0).toString('hex')\n    return `0x${forkhash}`\n  }\n\n  /**\n   * Returns an eth/64 compliant fork hash (EIP-2124)\n   * @param hardfork Hardfork name, optional if HF set\n   * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated\n   */\n  forkHash(hardfork?: string | Hardfork, genesisHash?: Buffer): string {\n    hardfork = hardfork ?? this._hardfork\n    const data = this._getHardfork(hardfork)\n    if (\n      data === null ||\n      (data?.block === null && data?.timestamp === undefined && data?.ttd === undefined)\n    ) {\n      const msg = 'No fork hash calculation possible for future hardfork'\n      throw new Error(msg)\n    }\n    if (data?.forkHash !== null && data?.forkHash !== undefined) {\n      return data.forkHash\n    }\n    if (!genesisHash) throw new Error('genesisHash required for forkHash calculation')\n    return this._calcForkHash(hardfork, genesisHash)\n  }\n\n  /**\n   *\n   * @param forkHash Fork hash as a hex string\n   * @returns Array with hardfork data (name, block, forkHash)\n   */\n  hardforkForForkHash(forkHash: string): HardforkConfig | null {\n    const resArray = this.hardforks().filter((hf: HardforkConfig) => {\n      return hf.forkHash === forkHash\n    })\n    return resArray.length >= 1 ? resArray[resArray.length - 1] : null\n  }\n\n  /**\n   * Sets any missing forkHashes on the passed-in {@link Common} instance\n   * @param common The {@link Common} to set the forkHashes for\n   * @param genesisHash The genesis block hash\n   */\n  setForkHashes(genesisHash: Buffer) {\n    for (const hf of this.hardforks()) {\n      const blockOrTime = hf.timestamp ?? hf.block\n      if (\n        (hf.forkHash === null || hf.forkHash === undefined) &&\n        ((blockOrTime !== null && blockOrTime !== undefined) || typeof hf.ttd !== 'undefined')\n      ) {\n        hf.forkHash = this.forkHash(hf.name, genesisHash)\n      }\n    }\n  }\n\n  /**\n   * Returns the Genesis parameters of the current chain\n   * @returns Genesis dictionary\n   */\n  genesis(): GenesisBlockConfig {\n    return this._chainParams.genesis\n  }\n\n  /**\n   * Returns the hardforks for current chain\n   * @returns {Array} Array with arrays of hardforks\n   */\n  hardforks(): HardforkConfig[] {\n    return this._chainParams.hardforks\n  }\n\n  /**\n   * Returns bootstrap nodes for the current chain\n   * @returns {Dictionary} Dict with bootstrap nodes\n   */\n  bootstrapNodes(): BootstrapNodeConfig[] {\n    return this._chainParams.bootstrapNodes\n  }\n\n  /**\n   * Returns DNS networks for the current chain\n   * @returns {String[]} Array of DNS ENR urls\n   */\n  dnsNetworks(): string[] {\n    return this._chainParams.dnsNetworks!\n  }\n\n  /**\n   * Returns the hardfork set\n   * @returns Hardfork name\n   */\n  hardfork(): string | Hardfork {\n    return this._hardfork\n  }\n\n  /**\n   * Returns the Id of current chain\n   * @returns chain Id\n   */\n  chainId(): bigint {\n    return BigInt(this._chainParams.chainId)\n  }\n\n  /**\n   * Returns the name of current chain\n   * @returns chain name (lower case)\n   */\n  chainName(): string {\n    return this._chainParams.name\n  }\n\n  /**\n   * Returns the Id of current network\n   * @returns network Id\n   */\n  networkId(): bigint {\n    return BigInt(this._chainParams.networkId)\n  }\n\n  /**\n   * Returns the active EIPs\n   * @returns List of EIPs\n   */\n  eips(): number[] {\n    return this._eips\n  }\n\n  /**\n   * Returns the consensus type of the network\n   * Possible values: \"pow\"|\"poa\"|\"pos\"\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusType(): string | ConsensusType {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['type']\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return value ?? this._chainParams['consensus']['type']\n  }\n\n  /**\n   * Returns the concrete consensus implementation\n   * algorithm or protocol for the network\n   * e.g. \"ethash\" for \"pow\" consensus type,\n   * \"clique\" for \"poa\" consensus type or\n   * \"casper\" for \"pos\" consensus type.\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusAlgorithm(): string | ConsensusAlgorithm {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['algorithm']\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return value ?? (this._chainParams['consensus']['algorithm'] as ConsensusAlgorithm)\n  }\n\n  /**\n   * Returns a dictionary with consensus configuration\n   * parameters based on the consensus algorithm\n   *\n   * Expected returns (parameters must be present in\n   * the respective chain json files):\n   *\n   * ethash: empty object\n   * clique: period, epoch\n   * casper: empty object\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusConfig(): { [key: string]: CliqueConfig | EthashConfig | CasperConfig } {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        // The config parameter is named after the respective consensus algorithm\n        value = hfChanges[1]['consensus'][hfChanges[1]['consensus']['algorithm']]\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return (\n      value ?? this._chainParams['consensus'][this.consensusAlgorithm() as ConsensusAlgorithm] ?? {}\n    )\n  }\n\n  /**\n   * Returns a deep copy of this {@link Common} instance.\n   */\n  copy(): Common {\n    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this)\n    copy.removeAllListeners()\n    return copy\n  }\n\n  static _getInitializedChains(customChains?: ChainConfig[]): ChainsConfig {\n    const names: ChainName = {}\n    for (const [name, id] of Object.entries(Chain)) {\n      names[id] = name.toLowerCase()\n    }\n    const chains = { mainnet, ropsten, rinkeby, goerli, sepolia } as ChainsConfig\n    if (customChains) {\n      for (const chain of customChains) {\n        const { name } = chain\n        names[chain.chainId.toString()] = name\n        chains[name] = chain\n      }\n    }\n    chains.names = names\n    return chains\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}