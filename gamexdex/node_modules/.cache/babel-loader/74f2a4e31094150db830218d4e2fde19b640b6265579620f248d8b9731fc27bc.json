{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccessListEIP2930Transaction = void 0;\nconst rlp_1 = require(\"@ethereumjs/rlp\");\nconst util_1 = require(\"@ethereumjs/util\");\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst baseTransaction_1 = require(\"./baseTransaction\");\nconst util_2 = require(\"./util\");\nconst TRANSACTION_TYPE = 1;\nconst TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex');\n/**\n * Typed transaction with optional access lists\n *\n * - TransactionType: 1\n * - EIP: [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930)\n */\nclass AccessListEIP2930Transaction extends baseTransaction_1.BaseTransaction {\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  constructor(txData, opts = {}) {\n    super({\n      ...txData,\n      type: TRANSACTION_TYPE\n    }, opts);\n    /**\n     * The default HF if the tx type is active on that HF\n     * or the first greater HF where the tx is active.\n     *\n     * @hidden\n     */\n    this.DEFAULT_HARDFORK = 'berlin';\n    const {\n      chainId,\n      accessList,\n      gasPrice\n    } = txData;\n    this.common = this._getCommon(opts.common, chainId);\n    this.chainId = this.common.chainId();\n    // EIP-2718 check is done in Common\n    if (!this.common.isActivatedEIP(2930)) {\n      throw new Error('EIP-2930 not enabled on Common');\n    }\n    this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);\n    // Populate the access list fields\n    const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);\n    this.accessList = accessListData.accessList;\n    this.AccessListJSON = accessListData.AccessListJSON;\n    // Verify the access list format.\n    util_2.AccessLists.verifyAccessList(this.accessList);\n    this.gasPrice = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(gasPrice === '' ? '0x' : gasPrice));\n    this._validateCannotExceedMaxInteger({\n      gasPrice: this.gasPrice\n    });\n    baseTransaction_1.BaseTransaction._validateNotArray(txData);\n    if (this.gasPrice * this.gasLimit > util_1.MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * gasPrice cannot exceed MAX_INTEGER');\n      throw new Error(msg);\n    }\n    this._validateYParity();\n    this._validateHighS();\n    const freeze = opts?.freeze ?? true;\n    if (freeze) {\n      Object.freeze(this);\n    }\n  }\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * v, r, s }\n   *\n   * Notes:\n   * - `chainId` will be set automatically if not provided\n   * - All parameters are optional and have some basic default values\n   */\n  static fromTxData(txData, opts = {}) {\n    return new AccessListEIP2930Transaction(txData, opts);\n  }\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)])`\n   */\n  static fromSerializedTx(serialized, opts = {}) {\n    if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {\n      throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized.slice(0, 1).toString('hex')}`);\n    }\n    const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized.slice(1))));\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input: must be array');\n    }\n    return AccessListEIP2930Transaction.fromValuesArray(values, opts);\n  }\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)]`\n   */\n  static fromValuesArray(values, opts = {}) {\n    if (values.length !== 8 && values.length !== 11) {\n      throw new Error('Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).');\n    }\n    const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values;\n    this._validateNotArray({\n      chainId,\n      v\n    });\n    (0, util_1.validateNoLeadingZeroes)({\n      nonce,\n      gasPrice,\n      gasLimit,\n      value,\n      v,\n      r,\n      s\n    });\n    const emptyAccessList = [];\n    return new AccessListEIP2930Transaction({\n      chainId: (0, util_1.bufferToBigInt)(chainId),\n      nonce,\n      gasPrice,\n      gasLimit,\n      to,\n      value,\n      data,\n      accessList: accessList ?? emptyAccessList,\n      v: v !== undefined ? (0, util_1.bufferToBigInt)(v) : undefined,\n      r,\n      s\n    }, opts);\n  }\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee() {\n    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {\n      return this.cache.dataFee.value;\n    }\n    let cost = super.getDataFee();\n    cost += BigInt(util_2.AccessLists.getDataFeeEIP2930(this.accessList, this.common));\n    if (Object.isFrozen(this)) {\n      this.cache.dataFee = {\n        value: cost,\n        hardfork: this.common.hardfork()\n      };\n    }\n    return cost;\n  }\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  getUpfrontCost() {\n    return this.gasLimit * this.gasPrice + this.value;\n  }\n  /**\n   * Returns a Buffer Array of the raw Buffers of the EIP-2930 transaction, in order.\n   *\n   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)]`\n   *\n   * Use {@link AccessListEIP2930Transaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link AccessListEIP2930Transaction.getMessageToSign}.\n   */\n  raw() {\n    return [(0, util_1.bigIntToUnpaddedBuffer)(this.chainId), (0, util_1.bigIntToUnpaddedBuffer)(this.nonce), (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice), (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit), this.to !== undefined ? this.to.buf : Buffer.from([]), (0, util_1.bigIntToUnpaddedBuffer)(this.value), this.data, this.accessList, this.v !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]), this.r !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]), this.s !== undefined ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([])];\n  }\n  /**\n   * Returns the serialized encoding of the EIP-2930 transaction.\n   *\n   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)])`\n   *\n   * Note that in contrast to the legacy tx serialization format this is not\n   * valid RLP any more due to the raw tx type preceding and concatenated to\n   * the RLP encoding of the values.\n   */\n  serialize() {\n    const base = this.raw();\n    return Buffer.concat([TRANSACTION_TYPE_BUFFER, Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))]);\n  }\n  /**\n   * Returns the serialized unsigned tx (hashed or raw), which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   *\n   * ```javascript\n   * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input\n   * ```\n   *\n   * @param hashMessage - Return hashed message if set to true (default: true)\n   */\n  getMessageToSign(hashMessage = true) {\n    const base = this.raw().slice(0, 8);\n    const message = Buffer.concat([TRANSACTION_TYPE_BUFFER, Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))]);\n    if (hashMessage) {\n      return Buffer.from((0, keccak_1.keccak256)(message));\n    } else {\n      return message;\n    }\n  }\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link AccessListEIP2930Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  hash() {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call hash method if transaction is not signed');\n      throw new Error(msg);\n    }\n    if (Object.isFrozen(this)) {\n      if (!this.cache.hash) {\n        this.cache.hash = Buffer.from((0, keccak_1.keccak256)(this.serialize()));\n      }\n      return this.cache.hash;\n    }\n    return Buffer.from((0, keccak_1.keccak256)(this.serialize()));\n  }\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  getMessageToVerifySignature() {\n    return this.getMessageToSign();\n  }\n  /**\n   * Returns the public key of the sender\n   */\n  getSenderPublicKey() {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call this method if transaction is not signed');\n      throw new Error(msg);\n    }\n    const msgHash = this.getMessageToVerifySignature();\n    const {\n      v,\n      r,\n      s\n    } = this;\n    this._validateHighS();\n    try {\n      return (0, util_1.ecrecover)(msgHash, v + BigInt(27),\n      // Recover the 27 which was stripped from ecsign\n      (0, util_1.bigIntToUnpaddedBuffer)(r), (0, util_1.bigIntToUnpaddedBuffer)(s));\n    } catch (e) {\n      const msg = this._errorMsg('Invalid Signature');\n      throw new Error(msg);\n    }\n  }\n  _processSignature(v, r, s) {\n    const opts = {\n      ...this.txOptions,\n      common: this.common\n    };\n    return AccessListEIP2930Transaction.fromTxData({\n      chainId: this.chainId,\n      nonce: this.nonce,\n      gasPrice: this.gasPrice,\n      gasLimit: this.gasLimit,\n      to: this.to,\n      value: this.value,\n      data: this.data,\n      accessList: this.accessList,\n      v: v - BigInt(27),\n      r: (0, util_1.bufferToBigInt)(r),\n      s: (0, util_1.bufferToBigInt)(s)\n    }, opts);\n  }\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  toJSON() {\n    const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);\n    return {\n      chainId: (0, util_1.bigIntToHex)(this.chainId),\n      nonce: (0, util_1.bigIntToHex)(this.nonce),\n      gasPrice: (0, util_1.bigIntToHex)(this.gasPrice),\n      gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),\n      to: this.to !== undefined ? this.to.toString() : undefined,\n      value: (0, util_1.bigIntToHex)(this.value),\n      data: '0x' + this.data.toString('hex'),\n      accessList: accessListJSON,\n      v: this.v !== undefined ? (0, util_1.bigIntToHex)(this.v) : undefined,\n      r: this.r !== undefined ? (0, util_1.bigIntToHex)(this.r) : undefined,\n      s: this.s !== undefined ? (0, util_1.bigIntToHex)(this.s) : undefined\n    };\n  }\n  /**\n   * Return a compact error string representation of the object\n   */\n  errorStr() {\n    let errorStr = this._getSharedErrorPostfix();\n    // Keep ? for this.accessList since this otherwise causes Hardhat E2E tests to fail\n    errorStr += ` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length ?? 0}`;\n    return errorStr;\n  }\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  _errorMsg(msg) {\n    return `${msg} (${this.errorStr()})`;\n  }\n}\nexports.AccessListEIP2930Transaction = AccessListEIP2930Transaction;","map":{"version":3,"names":["rlp_1","require","util_1","keccak_1","baseTransaction_1","util_2","TRANSACTION_TYPE","TRANSACTION_TYPE_BUFFER","Buffer","from","toString","padStart","AccessListEIP2930Transaction","BaseTransaction","constructor","txData","opts","type","DEFAULT_HARDFORK","chainId","accessList","gasPrice","common","_getCommon","isActivatedEIP","Error","activeCapabilities","concat","accessListData","AccessLists","getAccessListData","AccessListJSON","verifyAccessList","bufferToBigInt","toBuffer","_validateCannotExceedMaxInteger","_validateNotArray","gasLimit","MAX_INTEGER","msg","_errorMsg","_validateYParity","_validateHighS","freeze","Object","fromTxData","fromSerializedTx","serialized","slice","equals","values","arrToBufArr","RLP","decode","Uint8Array","Array","isArray","fromValuesArray","length","nonce","to","value","data","v","r","s","validateNoLeadingZeroes","emptyAccessList","undefined","getDataFee","cache","dataFee","hardfork","cost","BigInt","getDataFeeEIP2930","isFrozen","getUpfrontCost","raw","bigIntToUnpaddedBuffer","buf","serialize","base","encode","bufArrToArr","getMessageToSign","hashMessage","message","keccak256","hash","isSigned","getMessageToVerifySignature","getSenderPublicKey","msgHash","ecrecover","e","_processSignature","txOptions","toJSON","accessListJSON","getAccessListJSON","bigIntToHex","errorStr","_getSharedErrorPostfix","exports"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@ethereumjs/tx/src/eip2930Transaction.ts"],"sourcesContent":["import { RLP } from '@ethereumjs/rlp'\nimport {\n  MAX_INTEGER,\n  arrToBufArr,\n  bigIntToHex,\n  bigIntToUnpaddedBuffer,\n  bufArrToArr,\n  bufferToBigInt,\n  ecrecover,\n  toBuffer,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\nimport { keccak256 } from 'ethereum-cryptography/keccak'\n\nimport { BaseTransaction } from './baseTransaction'\nimport { AccessLists } from './util'\n\nimport type {\n  AccessList,\n  AccessListBuffer,\n  AccessListEIP2930TxData,\n  AccessListEIP2930ValuesArray,\n  JsonTx,\n  TxOptions,\n} from './types'\nimport type { Common } from '@ethereumjs/common'\n\nconst TRANSACTION_TYPE = 1\nconst TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex')\n\n/**\n * Typed transaction with optional access lists\n *\n * - TransactionType: 1\n * - EIP: [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930)\n */\nexport class AccessListEIP2930Transaction extends BaseTransaction<AccessListEIP2930Transaction> {\n  public readonly chainId: bigint\n  public readonly accessList: AccessListBuffer\n  public readonly AccessListJSON: AccessList\n  public readonly gasPrice: bigint\n\n  public readonly common: Common\n\n  /**\n   * The default HF if the tx type is active on that HF\n   * or the first greater HF where the tx is active.\n   *\n   * @hidden\n   */\n  protected DEFAULT_HARDFORK = 'berlin'\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * v, r, s }\n   *\n   * Notes:\n   * - `chainId` will be set automatically if not provided\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: AccessListEIP2930TxData, opts: TxOptions = {}) {\n    return new AccessListEIP2930Transaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)])`\n   */\n  public static fromSerializedTx(serialized: Buffer, opts: TxOptions = {}) {\n    if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {\n      throw new Error(\n        `Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized\n          .slice(0, 1)\n          .toString('hex')}`\n      )\n    }\n\n    const values = arrToBufArr(RLP.decode(Uint8Array.from(serialized.slice(1))))\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input: must be array')\n    }\n\n    return AccessListEIP2930Transaction.fromValuesArray(values as any, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)]`\n   */\n  public static fromValuesArray(values: AccessListEIP2930ValuesArray, opts: TxOptions = {}) {\n    if (values.length !== 8 && values.length !== 11) {\n      throw new Error(\n        'Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).'\n      )\n    }\n\n    const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values\n\n    this._validateNotArray({ chainId, v })\n    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s })\n\n    const emptyAccessList: AccessList = []\n\n    return new AccessListEIP2930Transaction(\n      {\n        chainId: bufferToBigInt(chainId),\n        nonce,\n        gasPrice,\n        gasLimit,\n        to,\n        value,\n        data,\n        accessList: accessList ?? emptyAccessList,\n        v: v !== undefined ? bufferToBigInt(v) : undefined, // EIP2930 supports v's with value 0 (empty Buffer)\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: AccessListEIP2930TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TRANSACTION_TYPE }, opts)\n    const { chainId, accessList, gasPrice } = txData\n\n    this.common = this._getCommon(opts.common, chainId)\n    this.chainId = this.common.chainId()\n\n    // EIP-2718 check is done in Common\n    if (!this.common.isActivatedEIP(2930)) {\n      throw new Error('EIP-2930 not enabled on Common')\n    }\n    this.activeCapabilities = this.activeCapabilities.concat([2718, 2930])\n\n    // Populate the access list fields\n    const accessListData = AccessLists.getAccessListData(accessList ?? [])\n    this.accessList = accessListData.accessList\n    this.AccessListJSON = accessListData.AccessListJSON\n    // Verify the access list format.\n    AccessLists.verifyAccessList(this.accessList)\n\n    this.gasPrice = bufferToBigInt(toBuffer(gasPrice === '' ? '0x' : gasPrice))\n\n    this._validateCannotExceedMaxInteger({\n      gasPrice: this.gasPrice,\n    })\n\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * gasPrice cannot exceed MAX_INTEGER')\n      throw new Error(msg)\n    }\n\n    this._validateYParity()\n    this._validateHighS()\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {\n      return this.cache.dataFee.value\n    }\n\n    let cost = super.getDataFee()\n    cost += BigInt(AccessLists.getDataFeeEIP2930(this.accessList, this.common))\n\n    if (Object.isFrozen(this)) {\n      this.cache.dataFee = {\n        value: cost,\n        hardfork: this.common.hardfork(),\n      }\n    }\n\n    return cost\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  getUpfrontCost(): bigint {\n    return this.gasLimit * this.gasPrice + this.value\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of the EIP-2930 transaction, in order.\n   *\n   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)]`\n   *\n   * Use {@link AccessListEIP2930Transaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link AccessListEIP2930Transaction.getMessageToSign}.\n   */\n  raw(): AccessListEIP2930ValuesArray {\n    return [\n      bigIntToUnpaddedBuffer(this.chainId),\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.gasPrice),\n      bigIntToUnpaddedBuffer(this.gasLimit),\n      this.to !== undefined ? this.to.buf : Buffer.from([]),\n      bigIntToUnpaddedBuffer(this.value),\n      this.data,\n      this.accessList,\n      this.v !== undefined ? bigIntToUnpaddedBuffer(this.v) : Buffer.from([]),\n      this.r !== undefined ? bigIntToUnpaddedBuffer(this.r) : Buffer.from([]),\n      this.s !== undefined ? bigIntToUnpaddedBuffer(this.s) : Buffer.from([]),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the EIP-2930 transaction.\n   *\n   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)])`\n   *\n   * Note that in contrast to the legacy tx serialization format this is not\n   * valid RLP any more due to the raw tx type preceding and concatenated to\n   * the RLP encoding of the values.\n   */\n  serialize(): Buffer {\n    const base = this.raw()\n    return Buffer.concat([\n      TRANSACTION_TYPE_BUFFER,\n      Buffer.from(RLP.encode(bufArrToArr(base as Buffer[]))),\n    ])\n  }\n\n  /**\n   * Returns the serialized unsigned tx (hashed or raw), which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   *\n   * ```javascript\n   * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input\n   * ```\n   *\n   * @param hashMessage - Return hashed message if set to true (default: true)\n   */\n  getMessageToSign(hashMessage = true): Buffer {\n    const base = this.raw().slice(0, 8)\n    const message = Buffer.concat([\n      TRANSACTION_TYPE_BUFFER,\n      Buffer.from(RLP.encode(bufArrToArr(base as Buffer[]))),\n    ])\n    if (hashMessage) {\n      return Buffer.from(keccak256(message))\n    } else {\n      return message\n    }\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link AccessListEIP2930Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  public hash(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call hash method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    if (Object.isFrozen(this)) {\n      if (!this.cache.hash) {\n        this.cache.hash = Buffer.from(keccak256(this.serialize()))\n      }\n      return this.cache.hash\n    }\n\n    return Buffer.from(keccak256(this.serialize()))\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  public getMessageToVerifySignature(): Buffer {\n    return this.getMessageToSign()\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  public getSenderPublicKey(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call this method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    const msgHash = this.getMessageToVerifySignature()\n    const { v, r, s } = this\n\n    this._validateHighS()\n\n    try {\n      return ecrecover(\n        msgHash,\n        v! + BigInt(27), // Recover the 27 which was stripped from ecsign\n        bigIntToUnpaddedBuffer(r!),\n        bigIntToUnpaddedBuffer(s!)\n      )\n    } catch (e: any) {\n      const msg = this._errorMsg('Invalid Signature')\n      throw new Error(msg)\n    }\n  }\n\n  _processSignature(v: bigint, r: Buffer, s: Buffer) {\n    const opts = { ...this.txOptions, common: this.common }\n\n    return AccessListEIP2930Transaction.fromTxData(\n      {\n        chainId: this.chainId,\n        nonce: this.nonce,\n        gasPrice: this.gasPrice,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        accessList: this.accessList,\n        v: v - BigInt(27), // This looks extremely hacky: @ethereumjs/util actually adds 27 to the value, the recovery bit is either 0 or 1.\n        r: bufferToBigInt(r),\n        s: bufferToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  toJSON(): JsonTx {\n    const accessListJSON = AccessLists.getAccessListJSON(this.accessList)\n\n    return {\n      chainId: bigIntToHex(this.chainId),\n      nonce: bigIntToHex(this.nonce),\n      gasPrice: bigIntToHex(this.gasPrice),\n      gasLimit: bigIntToHex(this.gasLimit),\n      to: this.to !== undefined ? this.to.toString() : undefined,\n      value: bigIntToHex(this.value),\n      data: '0x' + this.data.toString('hex'),\n      accessList: accessListJSON,\n      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,\n      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,\n      s: this.s !== undefined ? bigIntToHex(this.s) : undefined,\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    // Keep ? for this.accessList since this otherwise causes Hardhat E2E tests to fail\n    errorStr += ` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length ?? 0}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return `${msg} (${this.errorStr()})`\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}