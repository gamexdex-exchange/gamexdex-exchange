{"ast":null,"code":"'use strict';\n\nvar helpers = require('./helpers');\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\nvar attribute = {};\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'additionalItems': true,\n  'then': true,\n  'else': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      if (!v) return;\n      var id = v.$id || v.id;\n      return id ? '<' + id + '>' : v + '';\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list\n    });\n  }\n  return result;\n};\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema) {\n  var throwError = options.throwError;\n  var throwAll = options.throwAll;\n  options.throwError = false;\n  options.throwAll = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n  options.throwAll = throwAll;\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)) {\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(testSchemaNoThrow.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  }))) {\n    var list = schema.anyOf.map(function (v, i) {\n      var id = v.$id || v.id;\n      if (id) return '<' + id + '>';\n      return v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(',')\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)) {\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function (v, i) {\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if (!valid.valid) {\n      var id = v.$id || v.id;\n      var msg = id || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n      result.addError({\n        name: 'allOf',\n        argument: {\n          id: msg,\n          length: valid.errors.length,\n          valid: valid\n        },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:'\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)) {\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(testSchemaNoThrow.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  })).length;\n  var list = schema.oneOf.map(function (v, i) {\n    var id = v.$id || v.id;\n    return id || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n  });\n  if (count !== 1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(',')\n    });\n  }\n  return result;\n};\n\n/**\n * Validates \"then\" or \"else\" depending on the result of validating \"if\"\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.if = function validateIf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) return null;\n  if (!helpers.isSchema(schema.if)) throw new Error('Expected \"if\" keyword to be a schema');\n  var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var res;\n  if (ifValid) {\n    if (schema.then === undefined) return;\n    if (!helpers.isSchema(schema.then)) throw new Error('Expected \"then\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));\n    result.importErrors(res);\n  } else {\n    if (schema.else === undefined) return;\n    if (!helpers.isSchema(schema.else)) throw new Error('Expected \"else\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));\n    result.importErrors(res);\n  }\n  return result;\n};\nfunction getEnumerableProperty(object, key) {\n  // Determine if `key` shows up in `for(var key in object)`\n  // First test Object.hasOwnProperty.call as an optimization: that guarantees it does\n  if (Object.hasOwnProperty.call(object, key)) return object[key];\n  // Test `key in object` as an optimization; false means it won't\n  if (!(key in object)) return;\n  while (object = Object.getPrototypeOf(object)) {\n    if (Object.propertyIsEnumerable.call(object, key)) return object[key];\n  }\n}\n\n/**\n * Validates propertyNames\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.propertyNames = function validatePropertyNames(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var subschema = schema.propertyNames !== undefined ? schema.propertyNames : {};\n  if (!helpers.isSchema(subschema)) throw new SchemaError('Expected \"propertyNames\" to be a schema (object or boolean)');\n  for (var property in instance) {\n    if (getEnumerableProperty(instance, property) !== undefined) {\n      var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));\n      result.importErrors(res);\n    }\n  }\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    var subschema = properties[property];\n    if (subschema === undefined) {\n      continue;\n    } else if (subschema === null) {\n      throw new SchemaError('Unexpected null, expected schema in \"properties\"');\n    }\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, subschema, options, ctx);\n    }\n    var prop = getEnumerableProperty(instance, property);\n    var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty(instance, schema, options, ctx, property, result) {\n  if (!this.types.object(instance)) return;\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"is not allowed to have the additional property \" + JSON.stringify(property)\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var subschema = patternProperties[pattern];\n      if (subschema === undefined) {\n        continue;\n      } else if (subschema === null) {\n        throw new SchemaError('Unexpected null, expected schema in \"patternProperties\"');\n      }\n      try {\n        var regexp = new RegExp(pattern, 'u');\n      } catch (_e) {\n        // In the event the stricter handling causes an error, fall back on the forgiving handling\n        // DEPRECATED\n        regexp = new RegExp(pattern);\n      }\n      if (!regexp.test(property)) {\n        continue;\n      }\n      test = false;\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, subschema, options, ctx);\n      }\n      var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));\n      if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems(instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (schema.items === undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    if (Array.isArray(schema.items)) {\n      var items = schema.items[i] === undefined ? schema.additionalItems : schema.items[i];\n    } else {\n      var items = schema.items;\n    }\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\"\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if (res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates the \"contains\" keyword\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.contains = function validateContains(instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (schema.contains === undefined) return;\n  if (!helpers.isSchema(schema.contains)) throw new Error('Expected \"contains\" keyword to be a schema');\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var count = instance.some(function (value, i) {\n    var res = self.validateSchema(value, schema.contains, options, ctx.makeChild(schema.contains, i));\n    return res.errors.length === 0;\n  });\n  if (count === false) {\n    result.addError({\n      name: 'contains',\n      argument: schema.contains,\n      message: \"must contain an item matching given schema\"\n    });\n  }\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum(instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    if (!(instance > schema.minimum)) {\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than \" + schema.minimum\n      });\n    }\n  } else {\n    if (!(instance >= schema.minimum)) {\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than or equal to \" + schema.minimum\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum(instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    if (!(instance < schema.maximum)) {\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than \" + schema.maximum\n      });\n    }\n  } else {\n    if (!(instance <= schema.maximum)) {\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than or equal to \" + schema.maximum\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Validates the number form of exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.exclusiveMinimum = function validateExclusiveMinimum(instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMinimum, which is handled by the \"minimum\" keyword.\n  if (typeof schema.exclusiveMinimum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance > schema.exclusiveMinimum;\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMinimum',\n      argument: schema.exclusiveMinimum,\n      message: \"must be strictly greater than \" + schema.exclusiveMinimum\n    });\n  }\n  return result;\n};\n\n/**\n * Validates the number form of exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.exclusiveMaximum = function validateExclusiveMaximum(instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMaximum, which is handled by the \"maximum\" keyword.\n  if (typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance < schema.exclusiveMaximum;\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMaximum',\n      argument: schema.exclusiveMaximum,\n      message: \"must be strictly less than \" + schema.exclusiveMaximum\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n  var maxDecimals = Math.max(instanceDecimals, divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument: validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatibility with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function (n) {\n      if (getEnumerableProperty(instance, n) === undefined) {\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n)\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var pattern = schema.pattern;\n  try {\n    var regexp = new RegExp(pattern, 'u');\n  } catch (_e) {\n    // In the event the stricter handling causes an error, fall back on the forgiving handling\n    // DEPRECATED\n    regexp = new RegExp(pattern);\n  }\n  if (!instance.match(regexp)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString())\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat(instance, schema, options, ctx) {\n  if (instance === undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\"\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems(instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems(instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays(v, i, a) {\n  var j,\n    len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {\n  if (schema.uniqueItems !== true) return;\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\"\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if (result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum(instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(',')\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum(instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const']\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {\n  var self = this;\n  if (instance === undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if (!notTypes) return null;\n  if (!Array.isArray(notTypes)) notTypes = [notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var id = type && (type.$id || type.id);\n      var schemaId = id || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId\n      });\n    }\n  });\n  return result;\n};\nmodule.exports = attribute;","map":{"version":3,"names":["helpers","require","ValidatorResult","SchemaError","attribute","ignoreProperties","validators","type","validateType","instance","schema","options","ctx","undefined","result","types","Array","isArray","some","testType","bind","list","map","v","id","$id","addError","name","argument","message","testSchemaNoThrow","callback","throwError","throwAll","res","validateSchema","valid","Function","anyOf","validateAnyOf","inner","importErrors","i","title","JSON","stringify","nestedErrors","join","allOf","validateAllOf","self","forEach","msg","length","errors","oneOf","validateOneOf","count","filter","if","validateIf","isSchema","Error","ifValid","call","then","makeChild","else","getEnumerableProperty","object","key","Object","hasOwnProperty","getPrototypeOf","propertyIsEnumerable","propertyNames","validatePropertyNames","subschema","property","properties","validateProperties","preValidateProperty","prop","testAdditionalProperty","additionalProperties","patternProperties","validatePatternProperties","test","pattern","regexp","RegExp","_e","validateAdditionalProperties","minProperties","validateMinProperties","keys","maxProperties","validateMaxProperties","items","validateItems","array","every","value","additionalItems","contains","validateContains","minimum","validateMinimum","number","exclusiveMinimum","maximum","validateMaximum","exclusiveMaximum","validateExclusiveMinimum","validateExclusiveMaximum","validateMultipleOfOrDivisbleBy","validationType","errorMessage","validationArgument","instanceDecimals","getDecimalPlaces","divisorDecimals","maxDecimals","Math","max","multiplier","pow","round","multipleOf","validateMultipleOf","divisibleBy","validateDivisibleBy","required","validateRequired","n","validatePattern","string","match","toString","format","validateFormat","disableFormat","isFormat","minLength","validateMinLength","hsp","maxLength","validateMaxLength","minItems","validateMinItems","maxItems","validateMaxItems","testArrays","a","j","len","deepCompareStrict","uniqueItems","validateUniqueItems","dependencies","validateDependencies","dep","childContext","propertyPath","validateEnum","String","not","disallow","validateNot","notTypes","schemaId","module","exports"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/jsonschema/lib/attribute.js"],"sourcesContent":["'use strict';\n\nvar helpers = require('./helpers');\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'additionalItems': true,\n  'then': true,\n  'else': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true,\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      if(!v) return;\n      var id = v.$id || v.id;\n      return id ? ('<' + id + '>') : (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema){\n  var throwError = options.throwError;\n  var throwAll = options.throwAll;\n  options.throwError = false;\n  options.throwAll = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n  options.throwAll = throwAll;\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n    ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      var id = v.$id || v.id;\n      if(id) return '<' + id + '>';\n      return(v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var id = v.$id || v.id;\n      var msg = id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n    ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    var id = v.$id || v.id;\n    return id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates \"then\" or \"else\" depending on the result of validating \"if\"\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.if = function validateIf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) return null;\n  if (!helpers.isSchema(schema.if)) throw new Error('Expected \"if\" keyword to be a schema');\n  var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var res;\n  if(ifValid){\n    if (schema.then === undefined) return;\n    if (!helpers.isSchema(schema.then)) throw new Error('Expected \"then\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));\n    result.importErrors(res);\n  }else{\n    if (schema.else === undefined) return;\n    if (!helpers.isSchema(schema.else)) throw new Error('Expected \"else\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));\n    result.importErrors(res);\n  }\n  return result;\n};\n\nfunction getEnumerableProperty(object, key){\n  // Determine if `key` shows up in `for(var key in object)`\n  // First test Object.hasOwnProperty.call as an optimization: that guarantees it does\n  if(Object.hasOwnProperty.call(object, key)) return object[key];\n  // Test `key in object` as an optimization; false means it won't\n  if(!(key in object)) return;\n  while( (object = Object.getPrototypeOf(object)) ){\n    if(Object.propertyIsEnumerable.call(object, key)) return object[key];\n  }\n}\n\n/**\n * Validates propertyNames\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.propertyNames = function validatePropertyNames (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var subschema = schema.propertyNames!==undefined ? schema.propertyNames : {};\n  if(!helpers.isSchema(subschema)) throw new SchemaError('Expected \"propertyNames\" to be a schema (object or boolean)');\n\n  for (var property in instance) {\n    if(getEnumerableProperty(instance, property) !== undefined){\n      var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));\n      result.importErrors(res);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    var subschema = properties[property];\n    if(subschema===undefined){\n      continue;\n    }else if(subschema===null){\n      throw new SchemaError('Unexpected null, expected schema in \"properties\"');\n    }\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, subschema, options, ctx);\n    }\n    var prop = getEnumerableProperty(instance, property);\n    var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if(!this.types.object(instance)) return;\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"is not allowed to have the additional property \" + JSON.stringify(property),\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var subschema = patternProperties[pattern];\n      if(subschema===undefined){\n        continue;\n      }else if(subschema===null){\n        throw new SchemaError('Unexpected null, expected schema in \"patternProperties\"');\n      }\n      try {\n        var regexp = new RegExp(pattern, 'u');\n      } catch(_e) {\n        // In the event the stricter handling causes an error, fall back on the forgiving handling\n        // DEPRECATED\n        regexp = new RegExp(pattern);\n      }\n      if (!regexp.test(property)) {\n        continue;\n      }\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, subschema, options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (schema.items===undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    if(Array.isArray(schema.items)){\n      var items =  schema.items[i]===undefined ? schema.additionalItems : schema.items[i];\n    }else{\n      var items = schema.items;\n    }\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates the \"contains\" keyword\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.contains = function validateContains (instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (schema.contains===undefined) return;\n  if (!helpers.isSchema(schema.contains)) throw new Error('Expected \"contains\" keyword to be a schema');\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var count = instance.some(function (value, i) {\n    var res = self.validateSchema(value, schema.contains, options, ctx.makeChild(schema.contains, i));\n    return res.errors.length===0;\n  });\n  if(count===false){\n    result.addError({\n      name: 'contains',\n      argument: schema.contains,\n      message: \"must contain an item matching given schema\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    if(!(instance > schema.minimum)){\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than \" + schema.minimum,\n      });\n    }\n  } else {\n    if(!(instance >= schema.minimum)){\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than or equal to \" + schema.minimum,\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    if(!(instance < schema.maximum)){\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than \" + schema.maximum,\n      });\n    }\n  } else {\n    if(!(instance <= schema.maximum)){\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than or equal to \" + schema.maximum,\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Validates the number form of exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.exclusiveMinimum = function validateExclusiveMinimum (instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMinimum, which is handled by the \"minimum\" keyword.\n  if(typeof schema.exclusiveMinimum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance > schema.exclusiveMinimum;\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMinimum',\n      argument: schema.exclusiveMinimum,\n      message: \"must be strictly greater than \" + schema.exclusiveMinimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates the number form of exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.exclusiveMaximum = function validateExclusiveMaximum (instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMaximum, which is handled by the \"maximum\" keyword.\n  if(typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance < schema.exclusiveMaximum;\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMaximum',\n      argument: schema.exclusiveMaximum,\n      message: \"must be strictly less than \" + schema.exclusiveMaximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument),\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatibility with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\",\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(getEnumerableProperty(instance, n)===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var pattern = schema.pattern;\n  try {\n    var regexp = new RegExp(pattern, 'u');\n  } catch(_e) {\n    // In the event the stricter handling causes an error, fall back on the forgiving handling\n    // DEPRECATED\n    regexp = new RegExp(pattern);\n  }\n  if (!instance.match(regexp)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString()),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  if (instance===undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (schema.uniqueItems!==true) return;\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var id = type && (type.$id || type.id);\n      var schemaId = id || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}