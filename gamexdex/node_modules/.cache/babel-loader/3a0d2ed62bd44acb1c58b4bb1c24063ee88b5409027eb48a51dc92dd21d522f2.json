{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine, providerFromEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, log, WalletInitializationError, WalletLoginError, isHexStrict, getChainConfig } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { createFetchMiddleware, signMessage } from '@toruslabs/base-controllers';\nimport { getAccountsFromNamespaces, parseAccountId, getChainsFromNamespaces, parseChainId } from '@walletconnect/utils';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { stripHexPrefix, isValidAddress, privateToAddress, addHexPrefix } from '@ethereumjs/util';\nimport { SignTypedDataVersion, TYPED_MESSAGE_SCHEMA, typedSignatureHash, personalSign, signTypedData, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';\nimport { get } from '@toruslabs/http-helpers';\nimport assert from 'assert';\nimport jsonschema from 'jsonschema';\nimport BigNumber, { BigNumber as BigNumber$1 } from 'bignumber.js';\nimport { Hardfork, Common } from '@ethereumjs/common';\nimport BN from 'bn.js';\nfunction ownKeys$6(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$6(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction resemblesAddress(str) {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\nfunction createWalletMiddleware(_ref) {\n  let {\n    getAccounts,\n    getPrivateKey,\n    processDecryptMessage,\n    processEncryptionPublicKey,\n    processEthSignMessage,\n    processPersonalMessage,\n    processTransaction,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4\n  } = _ref;\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  }\n  //\n  // utility\n  //\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n  async function validateAndNormalizeKeyholder(address, req) {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts = await getAccounts(req);\n      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());\n      const normalizedAddress = address.toLowerCase();\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n    throw ethErrors.rpc.invalidParams({\n      message: `Invalid parameters: must provide an Ethereum address.`\n    });\n  }\n  //\n  // account lookups\n  //\n  async function lookupAccounts(req, res) {\n    res.result = await getAccounts(req);\n  }\n  async function lookupDefaultAccount(req, res) {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  }\n  //\n  // transaction signatures\n  //\n  async function sendTransaction(req, res) {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processTransaction(txParams, req);\n  }\n  async function signTransaction(req, res) {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processSignTransaction(txParams, req);\n  }\n  //\n  // message signatures\n  //\n  async function ethSign(req, res) {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const extraParams = req.params[2] || {};\n    const msgParams = _objectSpread$6(_objectSpread$6({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n  async function signTypedData(req, res) {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const message = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const version = \"V1\";\n    const extraParams = req.params[2] || {};\n    const msgParams = _objectSpread$6(_objectSpread$6({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n  async function signTypedDataV3(req, res) {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V3\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n  async function signTypedDataV4(req, res) {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V4\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n  async function personalSign(req, res) {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    // process normally\n    const firstParam = req.params[0];\n    const secondParam = req.params[1];\n    // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n    const extraParams = req.params[2] || {};\n    // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n    let address, message;\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = `The eth_personalSign method requires params ordered `;\n      warning += `[message, address]. This was previously handled incorrectly, `;\n      warning += `and has been corrected automatically. `;\n      warning += `Please switch this param order for smooth behavior in the future.`;\n      res.warning = warning;\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n    address = await validateAndNormalizeKeyholder(address, req);\n    const msgParams = _objectSpread$6(_objectSpread$6({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n    // eslint-disable-next-line require-atomic-updates\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n  async function encryptionPublicKey(req, res) {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n  async function decryptMessage(req, res) {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    const ciphertext = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const extraParams = req.params[2] || {};\n    const msgParams = _objectSpread$6(_objectSpread$6({}, extraParams), {}, {\n      from: address,\n      data: ciphertext\n    });\n    res.result = processDecryptMessage(msgParams, req);\n  }\n  async function fetchPrivateKey(req, res) {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    res.result = getPrivateKey(req);\n  }\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage)\n  });\n}\nfunction createEthMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processSignTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([createScaffoldMiddleware({\n    eth_syncing: false\n  }), createWalletMiddleware({\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  })]);\n  return ethMiddleware;\n}\nfunction createChainSwitchMiddleware(_ref) {\n  let {\n    addChain,\n    switchChain\n  } = _ref;\n  async function addNewChain(req, res) {\n    var _req$params;\n    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n    res.result = await addChain(chainParams);\n  }\n  async function updateChain(req, res) {\n    var _req$params2;\n    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)\n  });\n}\n// #region account middlewares\nfunction createAccountMiddleware(_ref2) {\n  let {\n    updatePrivatekey\n  } = _ref2;\n  async function updateAccount(req, res) {\n    var _req$params3;\n    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;\n    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount)\n  });\n}\n// #endregion account middlewares\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\nfunction getProviderHandlers$2(_ref) {\n  let {\n    connector\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      const {\n        accounts\n      } = connector;\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams, _) => {\n      const result = await connector.sendTransaction(txParams);\n      return result;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const result = await connector.signTransaction(txParams);\n      return result;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async msgParams => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV4: async msgParams => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\nfunction ownKeys$5(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$5(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass WalletConnectProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$5(_objectSpread$5({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        }),\n        skipLookupNetwork: !!config.skipLookupNetwork\n      },\n      state: _objectSpread$5(_objectSpread$5({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n    _defineProperty(this, \"connector\", null);\n    this.connector = connector || null;\n  }\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n  async switchChain(_ref2) {\n    let {\n      chainId,\n      addChain = true,\n      lookup = true\n    } = _ref2;\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    const currentChainConfig = this.getChainConfig(chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    const {\n      rpcTarget,\n      displayName\n    } = currentChainConfig;\n    if (addChain) {\n      try {\n        await this.connector.sendCustomRequest({\n          method: \"wallet_addEthereumChain\",\n          params: [{\n            chainId,\n            chainName: displayName,\n            rpcUrls: [rpcTarget],\n            blockExplorerUrls: [currentChainConfig.blockExplorer],\n            nativeCurrency: {\n              name: currentChainConfig.tickerName,\n              symbol: currentChainConfig.ticker,\n              decimals: currentChainConfig.decimals || 18\n            }\n          }]\n        });\n      } catch (error) {\n        log.error(error);\n      }\n    }\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId\n        }]\n      });\n    } catch (error) {\n      log.error(error);\n      // ignore this error because metamask & others return provider.result as null\n      // wallet connect thinks this is wrong\n      if (error.message !== \"JSON RPC response format is invalid\") {\n        throw error;\n      }\n    }\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    if (lookup) await this.lookupNetwork(this.connector);\n  }\n  async addChain(chainConfig) {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const {\n      rpcTarget,\n      displayName\n    } = chainConfig;\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          chainId: chainConfig.chainId,\n          chainName: displayName,\n          rpcUrls: [rpcTarget],\n          blockExplorerUrls: [chainConfig.blockExplorer],\n          nativeCurrency: {\n            name: chainConfig.tickerName,\n            symbol: chainConfig.ticker,\n            decimals: chainConfig.decimals || 18\n          }\n        }]\n      });\n      super.addChain(chainConfig);\n    } catch (error) {\n      log.error(error);\n      throw error;\n    }\n  }\n  async lookupNetwork(connector) {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : `0x${connector.chainId.toString(16)}`;\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(`Invalid network, net_version is: ${connectedHexChainId}, expected: ${chainId}`);\n    this.provider.emit(\"connect\", {\n      chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n  async setupEngine(connector) {\n    const providerHandlers = getProviderHandlers$2({\n      connector\n    });\n    this.update({\n      accounts: connector.accounts || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    if (!this.config.skipLookupNetwork) await this.lookupNetwork(connector);\n  }\n  async onConnectorStateUpdate(connector) {\n    connector.on(\"session_update\", async (error, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n      const {\n        accounts,\n        chainId: connectedChainId,\n        rpcUrl\n      } = payload.params[0];\n      // Check if accounts changed and trigger event\n      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts\n        });\n        // await this.setupEngine(connector);\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n      const connectedHexChainId = `0x${connectedChainId.toString(16)}`;\n      // Check if chainId changed and trigger event\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        const maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedChainId) || {};\n        // Handle rpcUrl update\n        this.configure({\n          chainConfig: _objectSpread$5(_objectSpread$5({}, maybeConfig), {}, {\n            chainId: connectedHexChainId,\n            rpcTarget: rpcUrl,\n            chainNamespace: CHAIN_NAMESPACES.EIP155\n          })\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n}\n_defineProperty(WalletConnectProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectProvider({\n    config: {\n      chainConfig: params.chainConfig,\n      skipLookupNetwork: params.skipLookupNetwork\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\nasync function getLastActiveSession(signClient) {\n  if (signClient.session.length) {\n    const lastKeyIndex = signClient.session.keys.length - 1;\n    return signClient.session.get(signClient.session.keys[lastKeyIndex]);\n  }\n  return null;\n}\nasync function sendJrpcRequest(signClient, chainId, method, params) {\n  const session = await getLastActiveSession(signClient);\n  if (!session) {\n    throw ethErrors.provider.disconnected();\n  }\n  return signClient.request({\n    topic: session.topic,\n    chainId: `eip155:${chainId}`,\n    request: {\n      method,\n      params\n    }\n  });\n}\nasync function getAccounts(signClient) {\n  const session = await getLastActiveSession(signClient);\n  if (!session) {\n    throw ethErrors.provider.disconnected();\n  }\n  const accounts = getAccountsFromNamespaces(session.namespaces);\n  if (accounts && accounts.length) {\n    return [...new Set(accounts.map(add => {\n      return parseAccountId(add).address;\n    }))];\n  }\n  throw new Error(\"Failed to get accounts\");\n}\nfunction getProviderHandlers$1(_ref) {\n  let {\n    connector,\n    chainId\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      return getAccounts(connector);\n    },\n    processTransaction: async (txParams, _) => {\n      const methodRes = await sendJrpcRequest(connector, chainId, \"eth_sendTransaction\", [txParams]);\n      return methodRes;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const methodRes = await sendJrpcRequest(connector, chainId, \"eth_signTransaction\", [txParams]);\n      return methodRes;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const methodRes = await sendJrpcRequest(connector, chainId, \"eth_sign\", [msgParams.from, msgParams.data]);\n      return methodRes;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const methodRes = await sendJrpcRequest(connector, chainId, \"personal_sign\", [msgParams.from, msgParams.data]);\n      return methodRes;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      const methodRes = await sendJrpcRequest(connector, chainId, \"eth_signTypedData\", [msgParams.data, msgParams.from]);\n      return methodRes;\n    },\n    processTypedMessageV3: async msgParams => {\n      const methodRes = await sendJrpcRequest(connector, chainId, \"eth_signTypedData_v3\", [msgParams.from, msgParams.data]);\n      return methodRes;\n    },\n    processTypedMessageV4: async msgParams => {\n      const methodRes = await sendJrpcRequest(connector, chainId, \"eth_signTypedData_v4\", [msgParams.from, msgParams.data]);\n      return methodRes;\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$4(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass WalletConnectV2Provider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$4(_objectSpread$4({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        }),\n        skipLookupNetwork: !!config.skipLookupNetwork\n      },\n      state: _objectSpread$4(_objectSpread$4({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n    _defineProperty(this, \"connector\", null);\n    this.connector = connector || null;\n  }\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n  async switchChain(_ref2) {\n    let {\n      chainId\n    } = _ref2;\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    const currentChainConfig = this.getChainConfig(chainId);\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    await this.setupEngine(this.connector);\n  }\n  async addChain(chainConfig) {\n    super.addChain(chainConfig);\n  }\n  // no need to implement this method in wallet connect v2.\n  async lookupNetwork(_) {\n    return this.config.chainConfig.chainId;\n  }\n  async setupEngine(connector) {\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const numChainId = parseInt(chainId, 16);\n    const providerHandlers = getProviderHandlers$1({\n      connector,\n      chainId: numChainId\n    });\n    const jrpcRes = await getAccounts(connector);\n    this.update({\n      accounts: jrpcRes || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n  }\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.EIP155,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\",\n          decimals: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.decimals) || 18\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n  connectedTopic() {\n    var _this$connector;\n    if (!this.connector) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if ((_this$connector = this.connector) !== null && _this$connector !== void 0 && (_this$connector = _this$connector.session) !== null && _this$connector !== void 0 && _this$connector.length) {\n      var _this$connector$sessi;\n      // currently we are supporting only 1 active session\n      const lastKeyIndex = this.connector.session.keys.length - 1;\n      return (_this$connector$sessi = this.connector.session.get(this.connector.session.keys[lastKeyIndex])) === null || _this$connector$sessi === void 0 ? void 0 : _this$connector$sessi.topic;\n    }\n    return undefined;\n  }\n  checkIfChainIdAllowed(chainId) {\n    if (!this.connector || !this.connectedTopic()) return false;\n    const sessionData = this.connector.session.get(this.connectedTopic());\n    const allChains = getChainsFromNamespaces(sessionData.namespaces);\n    let chainAllowed = false;\n    for (const chain of allChains) {\n      const parsedId = parseChainId(chain);\n      if (Number.parseInt(parsedId.reference, 10) === Number.parseInt(chainId, 10)) {\n        chainAllowed = true;\n        break;\n      }\n    }\n    return chainAllowed;\n  }\n  checkIfAccountAllowed(address) {\n    if (!this.connector || !this.connectedTopic()) return false;\n    const sessionData = this.connector.session.get(this.connectedTopic());\n    const allAccounts = getAccountsFromNamespaces(sessionData.namespaces);\n    let accountAllowed = false;\n    for (const account of allAccounts) {\n      var _parsedAccount$addres;\n      const parsedAccount = parseAccountId(account);\n      if (((_parsedAccount$addres = parsedAccount.address) === null || _parsedAccount$addres === void 0 ? void 0 : _parsedAccount$addres.toLowerCase()) === (address === null || address === void 0 ? void 0 : address.toLowerCase())) {\n        accountAllowed = true;\n        break;\n      }\n    }\n    return accountAllowed;\n  }\n  async onConnectorStateUpdate(connector) {\n    connector.events.on(\"session_event\", async payload => {\n      log.debug(\"session_event data\", payload);\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n      const {\n        event\n      } = payload.params;\n      const {\n        name,\n        data\n      } = event || {};\n      // Check if accounts changed and trigger event\n      if (name === \"accountsChanged\" && data !== null && data !== void 0 && data.length && this.state.accounts[0] !== data[0] && this.checkIfAccountAllowed(data[0])) {\n        this.update({\n          accounts: data\n        });\n        this.provider.emit(\"accountsChanged\", data);\n      }\n      if (event.name === \"chainChanged\") {\n        const {\n          chainId: connectedChainId,\n          rpcUrl\n        } = data;\n        const connectedHexChainId = `0x${connectedChainId.toString(16)}`;\n        if (!this.checkIfChainIdAllowed(connectedHexChainId)) return;\n        // Check if chainId changed and trigger event\n        if (connectedHexChainId && this.state.chainId !== connectedHexChainId) {\n          const maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedHexChainId) || {};\n          // Handle rpcUrl update\n          this.configure({\n            chainConfig: _objectSpread$4(_objectSpread$4({}, maybeConfig), {}, {\n              chainId: connectedHexChainId,\n              rpcTarget: rpcUrl,\n              chainNamespace: CHAIN_NAMESPACES.EIP155\n            })\n          });\n          await this.setupEngine(connector);\n        }\n      }\n    });\n  }\n}\n_defineProperty(WalletConnectV2Provider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectV2Provider({\n    config: {\n      chainConfig: params.chainConfig,\n      skipLookupNetwork: params.skipLookupNetwork\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\n\n// Big Number Constants\nconst BIG_NUMBER_WEI_MULTIPLIER = new BigNumber(\"1e18\");\nconst BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber(\"1e9\");\nconst BIG_NUMBER_ETH_MULTIPLIER = new BigNumber(\"1\");\n// Setter Maps\nconst toBigNumber = {\n  hex: n => typeof n === \"string\" ? new BigNumber(stripHexPrefix(n), 16) : new BigNumber(n, 16),\n  dec: n => new BigNumber(n, 10)\n};\nconst toNormalizedDenomination = {\n  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),\n  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),\n  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)\n};\nconst toSpecifiedDenomination = {\n  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),\n  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),\n  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP)\n};\nconst baseChange = {\n  hex: n => n.toString(16),\n  dec: n => new BigNumber(n).toString(10)\n};\nconst converter = params => {\n  const {\n    value,\n    fromNumericBase,\n    fromDenomination,\n    toNumericBase,\n    toDenomination,\n    numberOfDecimals\n  } = params;\n  let convertedValue = toBigNumber[fromNumericBase](value);\n  if (fromDenomination) {\n    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);\n  }\n  if (toDenomination) {\n    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);\n  }\n  if (numberOfDecimals) {\n    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);\n  }\n  if (toNumericBase) {\n    convertedValue = baseChange[toNumericBase](convertedValue);\n  }\n  return convertedValue;\n};\nconst conversionUtil = (value, _ref) => {\n  let {\n    fromNumericBase = \"hex\",\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals\n  } = _ref;\n  return converter({\n    fromNumericBase,\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals,\n    value: value || \"0\"\n  });\n};\nfunction decGWEIToHexWEI(decGWEI) {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"dec\",\n    toNumericBase: \"hex\",\n    fromDenomination: \"GWEI\",\n    toDenomination: \"WEI\"\n  });\n}\nfunction hexWEIToDecGWEI(decGWEI) {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"hex\",\n    toNumericBase: \"dec\",\n    fromDenomination: \"WEI\",\n    toDenomination: \"GWEI\"\n  });\n}\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction normalizeGWEIDecimalNumbers(n) {\n  const numberAsWEIHex = decGWEIToHexWEI(n);\n  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);\n  return numberAsGWEI;\n}\nasync function fetchEip1159GasEstimates(url) {\n  const estimates = await get(url);\n  const normalizedEstimates = _objectSpread$3(_objectSpread$3({}, estimates), {}, {\n    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),\n    low: _objectSpread$3(_objectSpread$3({}, estimates.low), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas)\n    }),\n    medium: _objectSpread$3(_objectSpread$3({}, estimates.medium), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas)\n    }),\n    high: _objectSpread$3(_objectSpread$3({}, estimates.high), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas)\n    })\n  });\n  return normalizedEstimates;\n}\n/**\n * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium\n * high values from that API.\n */\nasync function fetchLegacyGasPriceEstimates(url) {\n  const result = await get(url, {\n    referrer: url,\n    referrerPolicy: \"no-referrer-when-downgrade\",\n    method: \"GET\",\n    mode: \"cors\"\n  });\n  return {\n    low: result.SafeGasPrice,\n    medium: result.ProposeGasPrice,\n    high: result.FastGasPrice\n  };\n}\nconst validateTypedMessageParams = (parameters, activeChainId) => {\n  var _data$domain;\n  try {\n    assert.ok(parameters && typeof parameters === \"object\", \"Params must be an object.\");\n    assert.ok(\"data\" in parameters, 'Params must include a \"data\" field.');\n    assert.ok(\"from\" in parameters, 'Params must include a \"from\" field.');\n    assert.ok(typeof parameters.from === \"string\" && isValidAddress(parameters.from), '\"from\" field must be a valid, lowercase, hexadecimal Ethereum address string.');\n    let data = null;\n    let chainId = null;\n    switch (parameters.version) {\n      case SignTypedDataVersion.V1:\n        if (typeof parameters.data === \"string\") {\n          assert.doesNotThrow(() => {\n            data = JSON.parse(parameters.data);\n          }, '\"data\" must be a valid JSON string.');\n        } else {\n          // for backward compatiblity we validate for both string and object type.\n          data = parameters.data;\n        }\n        assert.ok(Array.isArray(data), \"params.data must be an array.\");\n        assert.doesNotThrow(() => {\n          typedSignatureHash(data);\n        }, \"Signing data must be valid EIP-712 typed data.\");\n        break;\n      case SignTypedDataVersion.V3:\n      case SignTypedDataVersion.V4:\n        if (typeof parameters.data === \"string\") {\n          assert.doesNotThrow(() => {\n            data = JSON.parse(parameters.data);\n          }, '\"data\" must be a valid JSON string.');\n        } else {\n          // for backward compatiblity we validate for both string and object type.\n          data = parameters.data;\n        }\n        assert.ok(data.primaryType in data.types, `Primary type of \"${data.primaryType}\" has no type definition.`);\n        const validation = jsonschema.validate(data, TYPED_MESSAGE_SCHEMA.properties);\n        assert.strictEqual(validation.errors.length, 0, \"Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.\");\n        chainId = (_data$domain = data.domain) === null || _data$domain === void 0 ? void 0 : _data$domain.chainId;\n        if (chainId) {\n          assert.ok(!Number.isNaN(activeChainId), `Cannot sign messages for chainId \"${chainId}\", because Web3Auth is switching networks.`);\n          if (typeof chainId === \"string\") {\n            chainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n          }\n          assert.strictEqual(chainId, activeChainId, `Provided chainId \"${chainId}\" must match the active chainId \"${activeChainId}\"`);\n        }\n        break;\n      default:\n        assert.fail(`Unknown typed data version \"${parameters.version}\"`);\n    }\n  } catch (error) {\n    throw ethErrors.rpc.invalidInput({\n      message: error === null || error === void 0 ? void 0 : error.message\n    });\n  }\n};\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nasync function signTx(txParams, privKey, txFormatter) {\n  const finalTxParams = await txFormatter.formatTransaction(txParams);\n  const common = await txFormatter.getCommonConfiguration();\n  const unsignedEthTx = TransactionFactory.fromTxData(finalTxParams, {\n    common\n  });\n  const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n  return signedTx;\n}\nfunction getProviderHandlers(_ref) {\n  let {\n    txFormatter,\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n  return {\n    getAccounts: async _ => [`0x${privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\")}`],\n    getPrivateKey: async _ => privKey,\n    processTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      const txHash = await providerEngineProxy.request({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))]\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      return `0x${signedTx.toString(\"hex\")}`;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({\n        privateKey: privKeyBuffer,\n        data: msgParams.data\n      });\n      return sig;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      const params = _objectSpread$2(_objectSpread$2({}, msgParams), {}, {\n        version: SignTypedDataVersion.V1\n      });\n      validateTypedMessageParams(params, finalChainId);\n      const data = typeof params.data === \"string\" ? JSON.parse(params.data) : params.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V1\n      });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      validateTypedMessageParams(msgParams, finalChainId);\n      const data = typeof msgParams.data === \"string\" ? JSON.parse(msgParams.data) : msgParams.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V3\n      });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const chainId = await providerEngineProxy.request({\n        method: \"eth_chainId\"\n      });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      validateTypedMessageParams(msgParams, finalChainId);\n      const data = typeof msgParams.data === \"string\" ? JSON.parse(msgParams.data) : msgParams.data;\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data,\n        version: SignTypedDataVersion.V4\n      });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address, _) => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams, _) => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({\n        encryptedData: JSON.parse(buff.toString(\"utf8\")),\n        privateKey: privKey\n      });\n      return decrypted;\n    }\n  };\n}\nfunction bnLessThan(a, b) {\n  if (a === null || a === undefined || b === null || b === undefined) {\n    return null;\n  }\n  return new BigNumber$1(a, 10).lt(b, 10);\n}\nfunction bnToHex(inputBn) {\n  return addHexPrefix(inputBn.toString(16));\n}\nfunction hexToBn(inputHex) {\n  if (BN.isBN(inputHex)) return inputHex;\n  return new BN(stripHexPrefix(inputHex), 16);\n}\nfunction BnMultiplyByFraction(targetBN, numerator, denominator) {\n  const numberBN = new BN(numerator);\n  const denomBN = new BN(denominator);\n  return targetBN.mul(numberBN).div(denomBN);\n}\nconst LegacyGasAPIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices\";\nconst EIP1559APIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees\";\nconst TRANSACTION_ENVELOPE_TYPES = {\n  LEGACY: \"0x0\",\n  ACCESS_LIST: \"0x1\",\n  FEE_MARKET: \"0x2\"\n};\nconst TRANSACTION_TYPES = {\n  SENT_ETHER: \"sentEther\",\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  STANDARD_TRANSACTION: \"transaction\"\n};\nconst GAS_ESTIMATE_TYPES = {\n  FEE_MARKET: \"fee-market\",\n  LEGACY: \"legacy\",\n  ETH_GASPRICE: \"eth_gasPrice\",\n  NONE: \"none\"\n};\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass TransactionFormatter {\n  constructor(_ref) {\n    let {\n      getProviderEngineProxy\n    } = _ref;\n    _defineProperty(this, \"chainConfig\", null);\n    _defineProperty(this, \"getProviderEngineProxy\", void 0);\n    _defineProperty(this, \"isEIP1559Compatible\", false);\n    this.getProviderEngineProxy = getProviderEngineProxy;\n  }\n  get providerProxy() {\n    return this.getProviderEngineProxy();\n  }\n  async init() {\n    this.chainConfig = await this.providerProxy.request({\n      method: \"eth_provider_config\",\n      params: []\n    });\n    this.isEIP1559Compatible = await this.getEIP1559Compatibility();\n  }\n  async getCommonConfiguration() {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const {\n      displayName: name,\n      chainId\n    } = this.chainConfig;\n    const hardfork = this.isEIP1559Compatible ? Hardfork.London : Hardfork.Berlin;\n    const customChainParams = {\n      name,\n      chainId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      defaultHardfork: hardfork\n    };\n    return Common.custom(customChainParams);\n  }\n  async formatTransaction(txParams) {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const clonedTxParams = _objectSpread$1({}, txParams);\n    if (clonedTxParams.nonce === undefined) clonedTxParams.nonce = await this.providerProxy.request({\n      method: \"eth_getTransactionCount\",\n      params: [txParams.from, \"latest\"]\n    });\n    if (!this.isEIP1559Compatible && clonedTxParams.gasPrice) {\n      if (clonedTxParams.maxFeePerGas) delete clonedTxParams.maxFeePerGas;\n      if (clonedTxParams.maxPriorityFeePerGas) delete clonedTxParams.maxPriorityFeePerGas;\n      // if gas is not provided explicitly, estimate it.\n      if (!clonedTxParams.gas) {\n        const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n        if (defaultGasLimit) {\n          clonedTxParams.gasLimit = defaultGasLimit;\n        }\n      } else {\n        clonedTxParams.gasLimit = clonedTxParams.gas;\n      }\n      return clonedTxParams;\n    }\n    if (!clonedTxParams.gas) {\n      const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n      if (defaultGasLimit) {\n        clonedTxParams.gasLimit = defaultGasLimit;\n      }\n    } else {\n      clonedTxParams.gasLimit = clonedTxParams.gas;\n    }\n    const {\n      gasPrice: defaultGasPrice,\n      maxFeePerGas: defaultMaxFeePerGas,\n      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas\n    } = await this.getDefaultGasFees(clonedTxParams);\n    if (this.isEIP1559Compatible) {\n      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas\n      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.\n      if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n        clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;\n        clonedTxParams.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === \"string\" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof clonedTxParams.gasPrice === \"string\" ? stripHexPrefix(clonedTxParams.gasPrice) : clonedTxParams.gasPrice) ? defaultMaxPriorityFeePerGas : clonedTxParams.gasPrice;\n      } else {\n        if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxFeePerGas = defaultMaxFeePerGas;\n        }\n        if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;\n        }\n        if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available\n          // then we set maxFeePerGas to the defaultGasPrice, assuming it is\n          // available.\n          clonedTxParams.maxFeePerGas = defaultGasPrice;\n        }\n        if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is\n          // available  then we set maxPriorityFeePerGas to\n          // clonedTxParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas\n          // set by the dapp, or the maxFeePerGas from the controller.\n          clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;\n        }\n      }\n      // We remove the gasPrice param entirely when on an eip1559 compatible network\n      delete clonedTxParams.gasPrice;\n    } else {\n      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params\n      // when not on a EIP1559 compatible network\n      delete clonedTxParams.maxPriorityFeePerGas;\n      delete clonedTxParams.maxFeePerGas;\n    }\n    // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are\n    // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest\n    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas\n    // were available from either the dapp or the network.\n    if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {\n      clonedTxParams.gasPrice = defaultGasPrice;\n    }\n    clonedTxParams.type = this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;\n    clonedTxParams.chainId = this.chainConfig.chainId;\n    return clonedTxParams;\n  }\n  async fetchEthGasPriceEstimate() {\n    const gasPrice = await this.providerProxy.request({\n      method: \"eth_gasPrice\",\n      params: []\n    });\n    return {\n      gasPrice: hexWEIToDecGWEI(gasPrice).toString()\n    };\n  }\n  async getEIP1559Compatibility() {\n    const latestBlock = await this.providerProxy.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", false]\n    });\n    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;\n    return !!supportsEIP1559;\n  }\n  async fetchGasFeeEstimateData() {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const isLegacyGasAPICompatible = this.chainConfig.chainId === \"0x1\";\n    const chainId = Number.parseInt(this.chainConfig.chainId, 16);\n    let gasData;\n    try {\n      if (this.isEIP1559Compatible) {\n        // TODO: kovan is not working due to a bug in metamask api\n        const estimates = await fetchEip1159GasEstimates(EIP1559APIEndpoint.replace(\"<chain_id>\", `${chainId}`));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET\n        };\n      } else if (isLegacyGasAPICompatible) {\n        const estimates = await fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace(\"<chain_id>\", `${chainId}`));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY\n        };\n      } else {\n        throw new Error(\"Main gas fee/price estimation failed. Use fallback\");\n      }\n    } catch (e) {\n      try {\n        const estimates = await this.fetchEthGasPriceEstimate();\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE\n        };\n      } catch (error) {\n        throw new Error(`Gas fee/price estimation failed. Message: ${error.message}`);\n      }\n    }\n    return gasData;\n  }\n  async getDefaultGasFees(txParams) {\n    if (!this.isEIP1559Compatible && txParams.gasPrice || this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas) {\n      return {};\n    }\n    try {\n      const {\n        gasFeeEstimates,\n        gasEstimateType\n      } = await this.fetchGasFeeEstimateData();\n      if (this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n        const {\n          medium: {\n            suggestedMaxPriorityFeePerGas,\n            suggestedMaxFeePerGas\n          } = {}\n        } = gasFeeEstimates;\n        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {\n          return {\n            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxFeePerGas)),\n            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas))\n          };\n        }\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n        // The LEGACY type includes low, medium and high estimates of\n        // gas price values.\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.medium))\n        };\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n        // The ETH_GASPRICE type just includes a single gas price property,\n        // which we can assume was retrieved from eth_gasPrice\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.gasPrice))\n        };\n      }\n    } catch (error) {\n      log.error(error);\n    }\n    const {\n      gasPrice\n    } = await this.fetchEthGasPriceEstimate();\n    return {\n      gasPrice: addHexPrefix(decGWEIToHexWEI(gasPrice))\n    };\n  }\n  async estimateTxGas(txMeta) {\n    const txParams = _objectSpread$1({}, txMeta);\n    // `eth_estimateGas` can fail if the user has insufficient balance for the\n    // value being sent, or for the gas cost. We don't want to check their\n    // balance here, we just want the gas estimate. The gas price is removed\n    // to skip those balance checks. We check balance elsewhere. We also delete\n    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.\n    delete txParams.gasPrice;\n    delete txParams.maxFeePerGas;\n    delete txParams.maxPriorityFeePerGas;\n    const gas = await this.providerProxy.request({\n      method: \"eth_estimateGas\",\n      params: [txParams]\n    });\n    return gas;\n  }\n  async analyzeGasUsage(txMeta) {\n    const block = await this.providerProxy.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", false]\n    });\n    // fallback to block gasLimit\n    const blockGasLimitBN = hexToBn(block.gasLimit);\n    const saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);\n    let estimatedGasHex = bnToHex(saferGasLimitBN);\n    try {\n      estimatedGasHex = await this.estimateTxGas(txMeta);\n    } catch (error) {\n      log.warn(error);\n    }\n    return {\n      blockGasLimit: block.gasLimit,\n      estimatedGasHex\n    };\n  }\n  addGasBuffer(initialGasLimitHex, blockGasLimitHex) {\n    let multiplier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.5;\n    const initialGasLimitBn = hexToBn(initialGasLimitHex);\n    const blockGasLimitBn = hexToBn(blockGasLimitHex);\n    const upperGasLimitBn = blockGasLimitBn.muln(0.9);\n    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);\n    // if initialGasLimit is above blockGasLimit, dont modify it\n    if (initialGasLimitBn.gt(upperGasLimitBn)) return bnToHex(initialGasLimitBn);\n    // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit\n    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return bnToHex(bufferedGasLimitBn);\n    // otherwise use blockGasLimit\n    return bnToHex(upperGasLimitBn);\n  }\n  async determineTransactionCategory(txParameters) {\n    const {\n      data,\n      to\n    } = txParameters;\n    let code = \"\";\n    let txCategory;\n    if (data && !to) {\n      txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;\n    } else {\n      try {\n        code = await this.providerProxy.request({\n          method: \"eth_getCode\",\n          params: [to, \"latest\"]\n        });\n      } catch (error) {\n        log.warn(error);\n      }\n      const codeIsEmpty = !code || code === \"0x\" || code === \"0x0\";\n      txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;\n    }\n    return {\n      transactionCategory: txCategory,\n      code\n    };\n  }\n  async getDefaultGasLimit(txParams) {\n    const {\n      transactionCategory\n    } = await this.determineTransactionCategory(_objectSpread$1({}, txParams));\n    if (txParams.gas) {\n      return txParams.gas;\n    }\n    if (txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER) {\n      // if there's data in the params, but there's no contract code, it's not a valid transaction\n      if (txParams.data) {\n        throw Error(\"TxGasUtil - Trying to call a function on a non-contract address\");\n      }\n      const TWENTY_ONE_THOUSAND = 21000;\n      // This is a standard ether simple send, gas requirement is exactly 21k\n      return addHexPrefix(TWENTY_ONE_THOUSAND.toString(16));\n    }\n    const {\n      blockGasLimit,\n      estimatedGasHex\n    } = await this.analyzeGasUsage(txParams);\n    // add additional gas buffer to our estimation for safety\n    const gasLimit = this.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit);\n    return gasLimit;\n  }\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass EthereumPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state\n    });\n  }\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n  async setupProvider(privKey) {\n    const txFormatter = new TransactionFormatter({\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const providerHandlers = getProviderHandlers({\n      txFormatter,\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine();\n    // Not a partial anymore because of checks in ctor\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await txFormatter.init();\n    await this.lookupNetwork();\n  }\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"eth_accounts\"\n        })\n      });\n    }\n  }\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    await this.setupProvider(privKey);\n  }\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request({\n      method: \"net_version\",\n      params: []\n    });\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(`Invalid network, net_version is: ${network}`);\n    if (this.state.chainId !== chainId) {\n      this._providerEngineProxy.emit(\"chainChanged\", chainId);\n      this._providerEngineProxy.emit(\"connect\", {\n        chainId\n      });\n    }\n    this.update({\n      chainId\n    });\n    return network;\n  }\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.EIP155,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\",\n          decimals: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.decimals) || 18\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async params => {\n        const {\n          privateKey\n        } = params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n}\n_defineProperty(EthereumPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new EthereumPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\nexport { EthereumPrivateKeyProvider, TransactionFormatter, WalletConnectProvider, WalletConnectV2Provider, getProviderHandlers };","map":{"version":3,"names":["resemblesAddress","str","length","createWalletMiddleware","_ref","getAccounts","getPrivateKey","processDecryptMessage","processEncryptionPublicKey","processEthSignMessage","processPersonalMessage","processTransaction","processSignTransaction","processTypedMessage","processTypedMessageV3","processTypedMessageV4","Error","validateAndNormalizeKeyholder","address","req","accounts","normalizedAccounts","map","_address","toLowerCase","normalizedAddress","includes","ethErrors","rpc","invalidParams","message","lookupAccounts","res","result","lookupDefaultAccount","sendTransaction","methodNotSupported","txParams","params","from","signTransaction","ethSign","extraParams","msgParams","_objectSpread$6","data","signTypedData","version","signTypedDataV3","signTypedDataV4","personalSign","firstParam","secondParam","warning","encryptionPublicKey","decryptMessage","ciphertext","fetchPrivateKey","createScaffoldMiddleware","eth_accounts","createAsyncMiddleware","eth_private_key","private_key","eth_coinbase","eth_sendTransaction","eth_signTransaction","eth_sign","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","personal_sign","eth_getEncryptionPublicKey","eth_decrypt","createEthMiddleware","providerHandlers","ethMiddleware","mergeMiddleware","eth_syncing","createChainSwitchMiddleware","addChain","switchChain","addNewChain","_req$params","chainParams","undefined","chainId","rpcUrls","nativeCurrency","updateChain","_req$params2","wallet_addEthereumChain","wallet_switchEthereumChain","createAccountMiddleware","_ref2","updatePrivatekey","updateAccount","_req$params3","accountParams","privateKey","wallet_updateAccount","createChainIdMiddleware","next","end","method","createProviderConfigMiddleware","providerConfig","createJsonRpcClient","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","getProviderHandlers$2","connector","_","signMessage","signPersonalMessage","WalletConnectProvider","BaseProvider","constructor","config","state","chainConfig","_objectSpread$5","chainNamespace","CHAIN_NAMESPACES","EIP155","skipLookupNetwork","_defineProperty","enable","provider","custom","code","setupProvider","_providerEngineProxy","request","onConnectorStateUpdate","setupEngine","lookup","currentChainConfig","getChainConfig","update","displayName","sendCustomRequest","chainName","blockExplorerUrls","blockExplorer","name","tickerName","symbol","ticker","decimals","error","log","configure","lookupNetwork","WalletInitializationError","notReady","connected","WalletLoginError","notConnectedError","connectedHexChainId","isHexStrict","toString","rpcConnectionError","emit","engine","JRPCEngine","push","providerFromEngine","updateProviderEngineProxy","on","payload","connectedChainId","rpcUrl","maybeConfig","providerFactory","getLastActiveSession","signClient","session","lastKeyIndex","keys","get","sendJrpcRequest","disconnected","topic","getAccountsFromNamespaces","namespaces","Set","add","parseAccountId","getProviderHandlers$1","methodRes","WalletConnectV2Provider","_objectSpread$4","numChainId","parseInt","jrpcRes","chainSwitchMiddleware","getChainSwitchMiddleware","chainSwitchHandlers","connectedTopic","_this$connector","_this$connector$sessi","checkIfChainIdAllowed","sessionData","allChains","getChainsFromNamespaces","chainAllowed","chain","parsedId","parseChainId","Number","reference","checkIfAccountAllowed","allAccounts","accountAllowed","account","_parsedAccount$addres","parsedAccount","events","debug","event","BIG_NUMBER_WEI_MULTIPLIER","BigNumber","BIG_NUMBER_GWEI_MULTIPLIER","BIG_NUMBER_ETH_MULTIPLIER","toBigNumber","hex","n","stripHexPrefix","dec","toNormalizedDenomination","WEI","bigNumber","div","GWEI","ETH","toSpecifiedDenomination","times","dp","ROUND_HALF_UP","baseChange","converter","value","fromNumericBase","fromDenomination","toNumericBase","toDenomination","numberOfDecimals","convertedValue","ROUND_HALF_DOWN","conversionUtil","decGWEIToHexWEI","decGWEI","hexWEIToDecGWEI","normalizeGWEIDecimalNumbers","numberAsWEIHex","numberAsGWEI","fetchEip1159GasEstimates","url","estimates","normalizedEstimates","_objectSpread$3","estimatedBaseFee","low","suggestedMaxPriorityFeePerGas","suggestedMaxFeePerGas","medium","high","fetchLegacyGasPriceEstimates","referrer","referrerPolicy","mode","SafeGasPrice","ProposeGasPrice","FastGasPrice","validateTypedMessageParams","parameters","activeChainId","_data$domain","assert","ok","isValidAddress","SignTypedDataVersion","V1","doesNotThrow","JSON","parse","Array","isArray","typedSignatureHash","V3","V4","primaryType","types","validation","jsonschema","validate","TYPED_MESSAGE_SCHEMA","properties","strictEqual","errors","domain","isNaN","fail","invalidInput","signTx","privKey","txFormatter","finalTxParams","formatTransaction","common","getCommonConfiguration","unsignedEthTx","TransactionFactory","fromTxData","signedTx","sign","Buffer","serialize","getProviderHandlers","getProviderEngineProxy","privateToAddress","providerEngineProxy","txHash","concat","rawMessageSig","privKeyBuffer","sig","finalChainId","_objectSpread$2","info","getEncryptionPublicKey","stripped","buff","decrypted","decrypt","encryptedData","bnLessThan","a","b","BigNumber$1","lt","bnToHex","inputBn","addHexPrefix","hexToBn","inputHex","BN","isBN","BnMultiplyByFraction","targetBN","numerator","denominator","numberBN","denomBN","mul","LegacyGasAPIEndpoint","EIP1559APIEndpoint","TRANSACTION_ENVELOPE_TYPES","LEGACY","ACCESS_LIST","FEE_MARKET","TRANSACTION_TYPES","SENT_ETHER","CONTRACT_INTERACTION","DEPLOY_CONTRACT","STANDARD_TRANSACTION","GAS_ESTIMATE_TYPES","ETH_GASPRICE","NONE","TransactionFormatter","providerProxy","init","isEIP1559Compatible","getEIP1559Compatibility","hardfork","Hardfork","London","Berlin","customChainParams","networkId","defaultHardfork","Common","clonedTxParams","_objectSpread$1","nonce","gasPrice","maxFeePerGas","maxPriorityFeePerGas","gas","defaultGasLimit","getDefaultGasLimit","gasLimit","defaultGasPrice","defaultMaxFeePerGas","defaultMaxPriorityFeePerGas","getDefaultGasFees","type","fetchEthGasPriceEstimate","latestBlock","supportsEIP1559","baseFeePerGas","fetchGasFeeEstimateData","isLegacyGasAPICompatible","gasData","replace","gasFeeEstimates","gasEstimateType","e","estimateTxGas","txMeta","analyzeGasUsage","block","blockGasLimitBN","saferGasLimitBN","estimatedGasHex","warn","blockGasLimit","addGasBuffer","initialGasLimitHex","blockGasLimitHex","multiplier","arguments","initialGasLimitBn","blockGasLimitBn","upperGasLimitBn","muln","bufferedGasLimitBn","gt","determineTransactionCategory","txParameters","to","txCategory","codeIsEmpty","transactionCategory","TWENTY_ONE_THOUSAND","EthereumPrivateKeyProvider","_objectSpread","bind","getAccountMiddleware","existingKey","network","chainDisconnected","accountHandlers"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/rpc/walletMidddleware.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/rpc/ethRpcMiddlewares.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/rpc/jrpcClient.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/injectedProviders/walletConnectUtils.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/injectedProviders/WalletConnectProvider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/injectedProviders/walletConnectV2Utils.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/injectedProviders/WalletConnectV2Provider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/converter.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/privateKeyProviders/TransactionFormatter/utils.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/privateKeyProviders/ethPrivatekeyUtils.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/utils.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/privateKeyProviders/TransactionFormatter/constants.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/privateKeyProviders/TransactionFormatter/index.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/ethereum-provider/src/providers/privateKeyProviders/EthereumPrivateKeyProvider.ts"],"sourcesContent":["import type { MessageTypes, TypedDataV1, TypedMessage } from \"@metamask/eth-sig-util\";\nimport { createAsyncMiddleware, createScaffoldMiddleware, JRPCMiddleware, JRPCRequest, JRPCResponse } from \"@toruslabs/openlogin-jrpc\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport type { MessageParams, TransactionParams, TypedMessageParams, WalletMiddlewareOptions } from \"./interfaces\";\n\nfunction resemblesAddress(str: string): boolean {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n\nexport function createWalletMiddleware({\n  getAccounts,\n  getPrivateKey,\n  processDecryptMessage,\n  processEncryptionPublicKey,\n  processEthSignMessage,\n  processPersonalMessage,\n  processTransaction,\n  processSignTransaction,\n  processTypedMessage,\n  processTypedMessageV3,\n  processTypedMessageV4,\n}: WalletMiddlewareOptions): JRPCMiddleware<string, unknown> {\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  }\n\n  //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n  async function validateAndNormalizeKeyholder(address: string, req: JRPCRequest<unknown>): Promise<string> {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts: string[] = await getAccounts(req);\n      const normalizedAccounts: string[] = accounts.map((_address) => _address.toLowerCase());\n      const normalizedAddress: string = address.toLowerCase();\n\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n    throw ethErrors.rpc.invalidParams({\n      message: `Invalid parameters: must provide an Ethereum address.`,\n    });\n  }\n\n  //\n  // account lookups\n  //\n\n  async function lookupAccounts(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    res.result = await getAccounts(req);\n  }\n\n  async function lookupDefaultAccount(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  }\n\n  //\n  // transaction signatures\n  //\n\n  async function sendTransaction(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams: TransactionParams = (req.params as TransactionParams[])[0] || {\n      from: \"\",\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from as string, req);\n    res.result = await processTransaction(txParams, req);\n  }\n\n  async function signTransaction(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams: TransactionParams = (req.params as TransactionParams[])[0] || {\n      from: \"\",\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from as string, req);\n    res.result = await processSignTransaction(txParams, req);\n  }\n\n  //\n  // message signatures\n  //\n\n  async function ethSign(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address: string = await validateAndNormalizeKeyholder((req.params as string[])[0], req);\n    const message: string = (req.params as string[])[1];\n    const extraParams: Record<string, unknown> = (req.params as Record<string, unknown>[])[2] || {};\n    const msgParams: MessageParams<string> = {\n      ...extraParams,\n      from: address,\n      data: message,\n    };\n\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n\n  async function signTypedData(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const message: TypedDataV1 = (req.params as TypedDataV1[])[0];\n    const address: string = await validateAndNormalizeKeyholder((req.params as string[])[1], req);\n    const version = \"V1\";\n    const extraParams: Record<string, unknown> = (req.params as Record<string, unknown>[])[2] || {};\n    const msgParams: MessageParams<TypedDataV1> = {\n      ...extraParams,\n      from: address,\n      data: message,\n    };\n\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n\n  async function signTypedDataV3(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address: string = await validateAndNormalizeKeyholder((req.params as string[])[0], req);\n    const message: TypedMessage<MessageTypes> = (req.params as TypedMessage<MessageTypes>[])[1];\n    const version = \"V3\";\n    const msgParams: TypedMessageParams<TypedMessage<MessageTypes>> = {\n      data: message,\n      from: address,\n      version,\n    };\n\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n\n  async function signTypedDataV4(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address: string = await validateAndNormalizeKeyholder((req.params as string[])[0], req);\n    const message: TypedMessage<MessageTypes> = (req.params as TypedMessage<MessageTypes>[])[1];\n    const version = \"V4\";\n    const msgParams: TypedMessageParams<TypedMessage<MessageTypes>> = {\n      data: message,\n      from: address,\n      version,\n    };\n\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n\n  async function personalSign(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    // process normally\n    const firstParam: string = (req.params as string[])[0];\n    const secondParam: string = (req.params as string[])[1];\n    // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n    const extraParams: Record<string, unknown> = (req.params as Record<string, unknown>[])[2] || {};\n\n    // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n    let address: string, message: string;\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = `The eth_personalSign method requires params ordered `;\n      warning += `[message, address]. This was previously handled incorrectly, `;\n      warning += `and has been corrected automatically. `;\n      warning += `Please switch this param order for smooth behavior in the future.`;\n      (res as any).warning = warning;\n\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n    address = await validateAndNormalizeKeyholder(address, req);\n\n    const msgParams: MessageParams<string> = {\n      ...extraParams,\n      from: address,\n      data: message,\n    };\n\n    // eslint-disable-next-line require-atomic-updates\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n\n  async function encryptionPublicKey(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address: string = await validateAndNormalizeKeyholder((req.params as string)[0], req);\n\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n\n  async function decryptMessage(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const ciphertext: string = (req.params as string)[0];\n    const address: string = await validateAndNormalizeKeyholder((req.params as string)[1], req);\n    const extraParams: Record<string, unknown> = (req.params as Record<string, unknown>[])[2] || {};\n    const msgParams: MessageParams<string> = {\n      ...extraParams,\n      from: address,\n      data: ciphertext,\n    };\n\n    res.result = processDecryptMessage(msgParams, req);\n  }\n\n  async function fetchPrivateKey(req: JRPCRequest<unknown>, res: JRPCResponse<unknown>): Promise<void> {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n    res.result = getPrivateKey(req);\n  }\n\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage),\n  });\n}\n","import {\n  createAsyncMiddleware,\n  createScaffoldMiddleware,\n  JRPCMiddleware,\n  JRPCRequest,\n  JRPCResponse,\n  mergeMiddleware,\n} from \"@toruslabs/openlogin-jrpc\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { AddEthereumChainParameter, IAccountHandlers, IChainSwitchHandlers, IProviderHandlers } from \"./interfaces\";\nimport { createWalletMiddleware } from \"./walletMidddleware\";\n\nexport function createEthMiddleware(providerHandlers: IProviderHandlers): JRPCMiddleware<unknown, unknown> {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processSignTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage,\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([\n    createScaffoldMiddleware({\n      eth_syncing: false,\n    }),\n    createWalletMiddleware({\n      getAccounts,\n      getPrivateKey,\n      processTransaction,\n      processEthSignMessage,\n      processSignTransaction,\n      processTypedMessage,\n      processTypedMessageV3,\n      processTypedMessageV4,\n      processPersonalMessage,\n      processEncryptionPublicKey,\n      processDecryptMessage,\n    }),\n  ]);\n  return ethMiddleware;\n}\n\nexport function createChainSwitchMiddleware({ addChain, switchChain }: IChainSwitchHandlers): JRPCMiddleware<unknown, unknown> {\n  async function addNewChain(req: JRPCRequest<AddEthereumChainParameter[]>, res: JRPCResponse<unknown>): Promise<void> {\n    const chainParams = req.params?.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n\n    res.result = await addChain(chainParams);\n  }\n  async function updateChain(req: JRPCRequest<{ chainId: string }[]>, res: JRPCResponse<unknown>): Promise<void> {\n    const chainParams = req.params?.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain),\n  });\n}\n\n// #region account middlewares\nexport function createAccountMiddleware({ updatePrivatekey }: IAccountHandlers): JRPCMiddleware<unknown, unknown> {\n  async function updateAccount(req: JRPCRequest<{ privateKey: string }[]>, res: JRPCResponse<unknown>): Promise<void> {\n    const accountParams = req.params?.length ? req.params[0] : undefined;\n    if (!accountParams?.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount),\n  });\n}\n\n// #endregion account middlewares\n","import { createFetchMiddleware } from \"@toruslabs/base-controllers\";\nimport { JRPCEngineEndCallback, JRPCEngineNextCallback, JRPCMiddleware, JRPCRequest, JRPCResponse, mergeMiddleware } from \"@toruslabs/openlogin-jrpc\";\nimport type { CustomChainConfig } from \"@web3auth/base\";\n\nexport function createChainIdMiddleware(chainId: string): JRPCMiddleware<unknown, unknown> {\n  return (req: JRPCRequest<unknown>, res: JRPCResponse<string>, next: JRPCEngineNextCallback, end: JRPCEngineEndCallback) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n    return next();\n  };\n}\n\nexport function createProviderConfigMiddleware(providerConfig: CustomChainConfig): JRPCMiddleware<unknown, unknown> {\n  return (req: JRPCRequest<unknown>, res: JRPCResponse<CustomChainConfig>, next: JRPCEngineNextCallback, end: JRPCEngineEndCallback) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n    return next();\n  };\n}\n\nexport function createJsonRpcClient(providerConfig: CustomChainConfig): {\n  networkMiddleware: JRPCMiddleware<unknown, unknown>;\n  fetchMiddleware: JRPCMiddleware<unknown, unknown>;\n} {\n  const { chainId, rpcTarget } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({ rpcTarget });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return { networkMiddleware, fetchMiddleware };\n}\n","import { MessageTypes, TypedDataV1, TypedMessage } from \"@metamask/eth-sig-util\";\nimport { JRPCRequest } from \"@toruslabs/openlogin-jrpc\";\nimport type { IConnector, ITxData } from \"@walletconnect/legacy-types\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { IProviderHandlers, MessageParams, TransactionParams, TypedMessageParams } from \"../../rpc/interfaces\";\n\nexport function getProviderHandlers({ connector }: { connector: IConnector }): IProviderHandlers {\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async (_: JRPCRequest<unknown>) => {\n      const { accounts } = connector;\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams: TransactionParams, _: JRPCRequest<unknown>): Promise<string> => {\n      const result = await connector.sendTransaction(txParams as ITxData);\n      return result;\n    },\n    processSignTransaction: async (txParams: TransactionParams, _: JRPCRequest<unknown>): Promise<string> => {\n      const result = await connector.signTransaction(txParams as ITxData);\n      return result;\n    },\n    processEthSignMessage: async (msgParams: MessageParams<string>, _: JRPCRequest<unknown>): Promise<string> => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams: MessageParams<string>, _: JRPCRequest<unknown>): Promise<string> => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams: MessageParams<TypedDataV1>, _: JRPCRequest<unknown>): Promise<string> => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async (msgParams: TypedMessageParams<TypedMessage<MessageTypes>>): Promise<string> => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV4: async (msgParams: TypedMessageParams<TypedMessage<MessageTypes>>): Promise<string> => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processEncryptionPublicKey: async (_: string): Promise<string> => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: (_: MessageParams<string>): string => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n  };\n}\n","import { JRPCEngine, providerFromEngine } from \"@toruslabs/openlogin-jrpc\";\nimport type { IConnector } from \"@walletconnect/legacy-types\";\nimport { CHAIN_NAMESPACES, CustomChainConfig, getChainConfig, isHexStrict, log, WalletInitializationError, WalletLoginError } from \"@web3auth/base\";\nimport { BaseProvider, BaseProviderConfig, BaseProviderState } from \"@web3auth/base-provider\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { createEthMiddleware } from \"../../rpc/ethRpcMiddlewares\";\nimport { createJsonRpcClient } from \"../../rpc/jrpcClient\";\nimport { getProviderHandlers } from \"./walletConnectUtils\";\n\nexport interface WalletConnectProviderConfig extends BaseProviderConfig {\n  chainConfig: Omit<CustomChainConfig, \"chainNamespace\">;\n}\n\nexport interface WalletConnectProviderState extends BaseProviderState {\n  accounts: string[];\n}\n\nexport class WalletConnectProvider extends BaseProvider<BaseProviderConfig, WalletConnectProviderState, IConnector> {\n  private connector: IConnector | null = null;\n\n  constructor({ config, state, connector }: { config: WalletConnectProviderConfig; state?: BaseProviderState; connector?: IConnector }) {\n    super({\n      config: { chainConfig: { ...config.chainConfig, chainNamespace: CHAIN_NAMESPACES.EIP155 }, skipLookupNetwork: !!config.skipLookupNetwork },\n      state: { ...(state || {}), chainId: \"loading\", accounts: [] },\n    });\n    this.connector = connector || null;\n  }\n\n  public static getProviderInstance = async (params: {\n    connector: IConnector;\n    chainConfig: Omit<CustomChainConfig, \"chainNamespace\">;\n    skipLookupNetwork: boolean;\n  }): Promise<WalletConnectProvider> => {\n    const providerFactory = new WalletConnectProvider({ config: { chainConfig: params.chainConfig, skipLookupNetwork: params.skipLookupNetwork } });\n    await providerFactory.setupProvider(params.connector);\n    return providerFactory;\n  };\n\n  public async enable(): Promise<string[]> {\n    if (!this.connector)\n      throw ethErrors.provider.custom({ message: \"Connector is not initialized, pass wallet connect connector in constructor\", code: 4902 });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({ method: \"eth_accounts\" });\n  }\n\n  public async setupProvider(connector: IConnector): Promise<void> {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n\n  public async switchChain({ chainId, addChain = true, lookup = true }: { chainId: string; addChain?: boolean; lookup?: boolean }): Promise<void> {\n    if (!this.connector)\n      throw ethErrors.provider.custom({ message: \"Connector is not initialized, pass wallet connect connector in constructor\", code: 4902 });\n    const currentChainConfig = this.getChainConfig(chainId);\n    this.update({\n      chainId: \"loading\",\n    });\n    const { rpcTarget, displayName } = currentChainConfig;\n    if (addChain) {\n      try {\n        await this.connector.sendCustomRequest({\n          method: \"wallet_addEthereumChain\",\n          params: [\n            {\n              chainId,\n              chainName: displayName,\n              rpcUrls: [rpcTarget],\n              blockExplorerUrls: [currentChainConfig.blockExplorer],\n              nativeCurrency: {\n                name: currentChainConfig.tickerName,\n                symbol: currentChainConfig.ticker,\n                decimals: currentChainConfig.decimals || 18,\n              },\n            },\n          ],\n        });\n      } catch (error) {\n        log.error(error);\n      }\n    }\n\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_switchEthereumChain\",\n        params: [{ chainId }],\n      });\n    } catch (error) {\n      log.error(error);\n      // ignore this error because metamask & others return provider.result as null\n      // wallet connect thinks this is wrong\n      if (error.message !== \"JSON RPC response format is invalid\") {\n        throw error;\n      }\n    }\n\n    this.configure({ chainConfig: currentChainConfig });\n    if (lookup) await this.lookupNetwork(this.connector);\n  }\n\n  async addChain(chainConfig: CustomChainConfig): Promise<void> {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const { rpcTarget, displayName } = chainConfig;\n\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_addEthereumChain\",\n        params: [\n          {\n            chainId: chainConfig.chainId,\n            chainName: displayName,\n            rpcUrls: [rpcTarget],\n            blockExplorerUrls: [chainConfig.blockExplorer],\n            nativeCurrency: {\n              name: chainConfig.tickerName,\n              symbol: chainConfig.ticker,\n              decimals: chainConfig.decimals || 18,\n            },\n          },\n        ],\n      });\n      super.addChain(chainConfig);\n    } catch (error) {\n      log.error(error);\n      throw error;\n    }\n  }\n\n  protected async lookupNetwork(connector: IConnector): Promise<string> {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n    const { chainId } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : `0x${connector.chainId.toString(16)}`;\n    if (chainId !== connectedHexChainId)\n      throw WalletInitializationError.rpcConnectionError(`Invalid network, net_version is: ${connectedHexChainId}, expected: ${chainId}`);\n\n    this.provider.emit(\"connect\", { chainId });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n\n  private async setupEngine(connector: IConnector): Promise<void> {\n    const providerHandlers = getProviderHandlers({ connector });\n    this.update({\n      accounts: connector.accounts || [],\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const { networkMiddleware } = createJsonRpcClient(this.config.chainConfig as CustomChainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    if (!this.config.skipLookupNetwork) await this.lookupNetwork(connector);\n  }\n\n  private async onConnectorStateUpdate(connector: IConnector) {\n    connector.on(\"session_update\", async (error: Error | null, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n      const { accounts, chainId: connectedChainId, rpcUrl }: { accounts?: string[]; chainId?: number; rpcUrl?: string } = payload.params[0];\n      // Check if accounts changed and trigger event\n      if (accounts?.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts,\n        });\n        // await this.setupEngine(connector);\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n      const connectedHexChainId = `0x${connectedChainId.toString(16)}`;\n      // Check if chainId changed and trigger event\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        const maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedChainId) || {};\n        // Handle rpcUrl update\n        this.configure({\n          chainConfig: { ...maybeConfig, chainId: connectedHexChainId, rpcTarget: rpcUrl, chainNamespace: CHAIN_NAMESPACES.EIP155 },\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n}\n","import { MessageTypes, TypedDataV1, TypedMessage } from \"@metamask/eth-sig-util\";\nimport { JRPCRequest } from \"@toruslabs/openlogin-jrpc\";\nimport type { ISignClient, SessionTypes } from \"@walletconnect/types\";\nimport { getAccountsFromNamespaces, parseAccountId } from \"@walletconnect/utils\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { IProviderHandlers, MessageParams, TransactionParams, TypedMessageParams } from \"../../rpc/interfaces\";\n\nasync function getLastActiveSession(signClient: ISignClient): Promise<SessionTypes.Struct | null> {\n  if (signClient.session.length) {\n    const lastKeyIndex = signClient.session.keys.length - 1;\n    return signClient.session.get(signClient.session.keys[lastKeyIndex]);\n  }\n  return null;\n}\n\nexport async function sendJrpcRequest<T, U>(signClient: ISignClient, chainId: number, method: string, params: U): Promise<T> {\n  const session = await getLastActiveSession(signClient);\n  if (!session) {\n    throw ethErrors.provider.disconnected();\n  }\n  return signClient.request<T>({\n    topic: session.topic,\n    chainId: `eip155:${chainId}`,\n    request: {\n      method,\n      params,\n    },\n  });\n}\n\nexport async function getAccounts(signClient: ISignClient): Promise<string[]> {\n  const session = await getLastActiveSession(signClient);\n  if (!session) {\n    throw ethErrors.provider.disconnected();\n  }\n  const accounts = getAccountsFromNamespaces(session.namespaces);\n  if (accounts && accounts.length) {\n    return [\n      ...new Set(\n        accounts.map((add) => {\n          return parseAccountId(add).address;\n        })\n      ),\n    ];\n  }\n  throw new Error(\"Failed to get accounts\");\n}\n\nexport function getProviderHandlers({ connector, chainId }: { connector: ISignClient; chainId: number }): IProviderHandlers {\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async (_: JRPCRequest<unknown>) => {\n      return getAccounts(connector);\n    },\n    processTransaction: async (txParams: TransactionParams, _: JRPCRequest<unknown>): Promise<string> => {\n      const methodRes = await sendJrpcRequest<string, TransactionParams[]>(connector, chainId, \"eth_sendTransaction\", [txParams]);\n      return methodRes;\n    },\n    processSignTransaction: async (txParams: TransactionParams, _: JRPCRequest<unknown>): Promise<string> => {\n      const methodRes = await sendJrpcRequest<string, TransactionParams[]>(connector, chainId, \"eth_signTransaction\", [txParams]);\n      return methodRes;\n    },\n    processEthSignMessage: async (msgParams: MessageParams<string>, _: JRPCRequest<unknown>): Promise<string> => {\n      const methodRes = await sendJrpcRequest<string, string[]>(connector, chainId, \"eth_sign\", [msgParams.from, msgParams.data]);\n      return methodRes;\n    },\n    processPersonalMessage: async (msgParams: MessageParams<string>, _: JRPCRequest<unknown>): Promise<string> => {\n      const methodRes = await sendJrpcRequest<string, string[]>(connector, chainId, \"personal_sign\", [msgParams.from, msgParams.data]);\n      return methodRes;\n    },\n    processTypedMessage: async (msgParams: MessageParams<TypedDataV1>, _: JRPCRequest<unknown>): Promise<string> => {\n      const methodRes = await sendJrpcRequest<string, unknown[]>(connector, chainId, \"eth_signTypedData\", [msgParams.data, msgParams.from]);\n      return methodRes;\n    },\n    processTypedMessageV3: async (msgParams: TypedMessageParams<TypedMessage<MessageTypes>>): Promise<string> => {\n      const methodRes = await sendJrpcRequest<string, unknown[]>(connector, chainId, \"eth_signTypedData_v3\", [msgParams.from, msgParams.data]);\n      return methodRes;\n    },\n    processTypedMessageV4: async (msgParams: TypedMessageParams<TypedMessage<MessageTypes>>): Promise<string> => {\n      const methodRes = await sendJrpcRequest<string, unknown[]>(connector, chainId, \"eth_signTypedData_v4\", [msgParams.from, msgParams.data]);\n      return methodRes;\n    },\n    processEncryptionPublicKey: async (_: string): Promise<string> => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: (_: MessageParams<string>): string => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n  };\n}\n","import { JRPCEngine, JRPCMiddleware, providerFromEngine } from \"@toruslabs/openlogin-jrpc\";\nimport type { ISignClient, SignClientTypes } from \"@walletconnect/types\";\nimport { getAccountsFromNamespaces, getChainsFromNamespaces, parseAccountId, parseChainId } from \"@walletconnect/utils\";\nimport { CHAIN_NAMESPACES, CustomChainConfig, getChainConfig, log, WalletLoginError } from \"@web3auth/base\";\nimport { BaseProvider, BaseProviderConfig, BaseProviderState } from \"@web3auth/base-provider\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { createChainSwitchMiddleware, createEthMiddleware } from \"../../rpc/ethRpcMiddlewares\";\nimport { AddEthereumChainParameter, IChainSwitchHandlers } from \"../../rpc/interfaces\";\nimport { createJsonRpcClient } from \"../../rpc/jrpcClient\";\nimport { getAccounts, getProviderHandlers } from \"./walletConnectV2Utils\";\n\nexport interface WalletConnectV2ProviderConfig extends BaseProviderConfig {\n  chainConfig: Omit<CustomChainConfig, \"chainNamespace\">;\n}\n\nexport interface WalletConnectV2ProviderState extends BaseProviderState {\n  accounts: string[];\n}\n\nexport class WalletConnectV2Provider extends BaseProvider<BaseProviderConfig, WalletConnectV2ProviderState, ISignClient> {\n  private connector: ISignClient | null = null;\n\n  constructor({ config, state, connector }: { config: WalletConnectV2ProviderConfig; state?: BaseProviderState; connector?: ISignClient }) {\n    super({\n      config: { chainConfig: { ...config.chainConfig, chainNamespace: CHAIN_NAMESPACES.EIP155 }, skipLookupNetwork: !!config.skipLookupNetwork },\n      state: { ...(state || {}), chainId: \"loading\", accounts: [] },\n    });\n    this.connector = connector || null;\n  }\n\n  public static getProviderInstance = async (params: {\n    connector: ISignClient;\n    chainConfig: Omit<CustomChainConfig, \"chainNamespace\">;\n    skipLookupNetwork: boolean;\n  }): Promise<WalletConnectV2Provider> => {\n    const providerFactory = new WalletConnectV2Provider({ config: { chainConfig: params.chainConfig, skipLookupNetwork: params.skipLookupNetwork } });\n    await providerFactory.setupProvider(params.connector);\n    return providerFactory;\n  };\n\n  public async enable(): Promise<string[]> {\n    if (!this.connector)\n      throw ethErrors.provider.custom({ message: \"Connector is not initialized, pass wallet connect connector in constructor\", code: 4902 });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({ method: \"eth_accounts\" });\n  }\n\n  public async setupProvider(connector: ISignClient): Promise<void> {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n\n  public async switchChain({ chainId }: { chainId: string }): Promise<void> {\n    if (!this.connector)\n      throw ethErrors.provider.custom({ message: \"Connector is not initialized, pass wallet connect connector in constructor\", code: 4902 });\n    const currentChainConfig = this.getChainConfig(chainId);\n    this.configure({ chainConfig: currentChainConfig });\n    await this.setupEngine(this.connector);\n  }\n\n  async addChain(chainConfig: CustomChainConfig): Promise<void> {\n    super.addChain(chainConfig);\n  }\n\n  // no need to implement this method in wallet connect v2.\n  protected async lookupNetwork(_: ISignClient): Promise<string> {\n    return this.config.chainConfig.chainId;\n  }\n\n  private async setupEngine(connector: ISignClient): Promise<void> {\n    const { chainId } = this.config.chainConfig;\n    const numChainId = parseInt(chainId, 16);\n    const providerHandlers = getProviderHandlers({ connector, chainId: numChainId });\n    const jrpcRes = await getAccounts(connector);\n\n    this.update({\n      accounts: jrpcRes || [],\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine();\n    const { networkMiddleware } = createJsonRpcClient(this.config.chainConfig as CustomChainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n  }\n\n  private getChainSwitchMiddleware(): JRPCMiddleware<unknown, unknown> {\n    const chainSwitchHandlers: IChainSwitchHandlers = {\n      addChain: async (params: AddEthereumChainParameter): Promise<void> => {\n        const { chainId, chainName, rpcUrls, blockExplorerUrls, nativeCurrency } = params;\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.EIP155,\n          chainId,\n          ticker: nativeCurrency?.symbol || \"ETH\",\n          tickerName: nativeCurrency?.name || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: blockExplorerUrls?.[0] || \"\",\n          decimals: nativeCurrency?.decimals || 18,\n        });\n      },\n      switchChain: async (params: { chainId: string }): Promise<void> => {\n        const { chainId } = params;\n        await this.switchChain({ chainId });\n      },\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  private connectedTopic() {\n    if (!this.connector) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (this.connector?.session?.length) {\n      // currently we are supporting only 1 active session\n      const lastKeyIndex = this.connector.session.keys.length - 1;\n      return this.connector.session.get(this.connector.session.keys[lastKeyIndex])?.topic;\n    }\n    return undefined;\n  }\n\n  private checkIfChainIdAllowed(chainId) {\n    if (!this.connector || !this.connectedTopic()) return false;\n    const sessionData = this.connector.session.get(this.connectedTopic());\n    const allChains = getChainsFromNamespaces(sessionData.namespaces);\n\n    let chainAllowed = false;\n    for (const chain of allChains) {\n      const parsedId = parseChainId(chain);\n      if (Number.parseInt(parsedId.reference, 10) === Number.parseInt(chainId, 10)) {\n        chainAllowed = true;\n        break;\n      }\n    }\n    return chainAllowed;\n  }\n\n  private checkIfAccountAllowed(address) {\n    if (!this.connector || !this.connectedTopic()) return false;\n    const sessionData = this.connector.session.get(this.connectedTopic());\n    const allAccounts = getAccountsFromNamespaces(sessionData.namespaces);\n    let accountAllowed = false;\n    for (const account of allAccounts) {\n      const parsedAccount = parseAccountId(account);\n      if (parsedAccount.address?.toLowerCase() === address?.toLowerCase()) {\n        accountAllowed = true;\n        break;\n      }\n    }\n    return accountAllowed;\n  }\n\n  private async onConnectorStateUpdate(connector: ISignClient) {\n    connector.events.on(\"session_event\", async (payload: SignClientTypes.EventArguments[\"session_event\"]) => {\n      log.debug(\"session_event data\", payload);\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n      const { event } = payload.params;\n      const { name, data } = event || {};\n      // Check if accounts changed and trigger event\n      if (name === \"accountsChanged\" && data?.length && this.state.accounts[0] !== data[0] && this.checkIfAccountAllowed(data[0])) {\n        this.update({\n          accounts: data,\n        });\n        this.provider.emit(\"accountsChanged\", data);\n      }\n\n      if (event.name === \"chainChanged\") {\n        const { chainId: connectedChainId, rpcUrl } = data;\n        const connectedHexChainId = `0x${connectedChainId.toString(16)}`;\n\n        if (!this.checkIfChainIdAllowed(connectedHexChainId)) return;\n        // Check if chainId changed and trigger event\n        if (connectedHexChainId && this.state.chainId !== connectedHexChainId) {\n          const maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedHexChainId) || {};\n          // Handle rpcUrl update\n          this.configure({\n            chainConfig: { ...maybeConfig, chainId: connectedHexChainId, rpcTarget: rpcUrl, chainNamespace: CHAIN_NAMESPACES.EIP155 },\n          });\n          await this.setupEngine(connector);\n        }\n      }\n    });\n  }\n}\n","import { stripHexPrefix } from \"@ethereumjs/util\";\nimport BigNumber from \"bignumber.js\";\n\ntype DenominationType = \"WEI\" | \"GWEI\" | \"ETH\";\ntype NumericBaseType = \"hex\" | \"dec\";\n\ntype ConverterInput = {\n  value: string | BigNumber;\n  fromNumericBase: NumericBaseType;\n  fromDenomination?: DenominationType;\n  toNumericBase?: NumericBaseType;\n  toDenomination?: DenominationType;\n  numberOfDecimals?: number;\n};\n// Big Number Constants\nconst BIG_NUMBER_WEI_MULTIPLIER = new BigNumber(\"1e18\");\nconst BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber(\"1e9\");\nconst BIG_NUMBER_ETH_MULTIPLIER = new BigNumber(\"1\");\n\n// Setter Maps\nconst toBigNumber: Record<NumericBaseType, (n: string | BigNumber) => BigNumber> = {\n  hex: (n: string | BigNumber) => (typeof n === \"string\" ? new BigNumber(stripHexPrefix(n), 16) : new BigNumber(n, 16)),\n  dec: (n: string | BigNumber) => new BigNumber(n, 10),\n};\nconst toNormalizedDenomination: Record<string, (n: BigNumber) => BigNumber> = {\n  WEI: (bigNumber) => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),\n  GWEI: (bigNumber) => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),\n  ETH: (bigNumber) => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER),\n};\nconst toSpecifiedDenomination: Record<string, (n: BigNumber) => BigNumber> = {\n  WEI: (bigNumber) => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),\n  GWEI: (bigNumber) => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),\n  ETH: (bigNumber) => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),\n};\nconst baseChange: Record<string, (n: BigNumber) => string> = {\n  hex: (n) => n.toString(16),\n  dec: (n) => new BigNumber(n).toString(10),\n};\n\nconst converter = (params: ConverterInput): string | BigNumber => {\n  const { value, fromNumericBase, fromDenomination, toNumericBase, toDenomination, numberOfDecimals } = params;\n  let convertedValue: string | BigNumber = toBigNumber[fromNumericBase](value);\n\n  if (fromDenomination) {\n    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue as BigNumber);\n  }\n\n  if (toDenomination) {\n    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue as BigNumber);\n  }\n\n  if (numberOfDecimals) {\n    convertedValue = (convertedValue as BigNumber).dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);\n  }\n\n  if (toNumericBase) {\n    convertedValue = baseChange[toNumericBase](convertedValue);\n  }\n  return convertedValue;\n};\n\nconst conversionUtil = (\n  value: string | BigNumber,\n  { fromNumericBase = \"hex\", toNumericBase, fromDenomination, toDenomination, numberOfDecimals }: Partial<ConverterInput>\n): BigNumber | string => {\n  return converter({\n    fromNumericBase,\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals,\n    value: value || \"0\",\n  });\n};\n\nfunction decGWEIToHexWEI(decGWEI: string | BigNumber): string {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"dec\",\n    toNumericBase: \"hex\",\n    fromDenomination: \"GWEI\",\n    toDenomination: \"WEI\",\n  }) as string;\n}\n\nfunction hexWEIToDecGWEI(decGWEI: string | BigNumber): string {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"hex\",\n    toNumericBase: \"dec\",\n    fromDenomination: \"WEI\",\n    toDenomination: \"GWEI\",\n  }) as string;\n}\n\nexport { conversionUtil, decGWEIToHexWEI, hexWEIToDecGWEI };\n","import { isValidAddress } from \"@ethereumjs/util\";\nimport { SignTypedDataVersion, TYPED_MESSAGE_SCHEMA, TypedDataV1Field, typedSignatureHash } from \"@metamask/eth-sig-util\";\nimport { get } from \"@toruslabs/http-helpers\";\nimport { isHexStrict } from \"@web3auth/base\";\nimport assert from \"assert\";\nimport { BigNumber } from \"bignumber.js\";\nimport { ethErrors } from \"eth-rpc-errors\";\nimport jsonschema from \"jsonschema\";\n\nimport { TypedMessageParams } from \"../../../rpc/interfaces\";\nimport { decGWEIToHexWEI, hexWEIToDecGWEI } from \"../../converter\";\nimport { EIP1159GasData, LegacyGasData } from \"./interfaces\";\n\nexport function normalizeGWEIDecimalNumbers(n: string | BigNumber): string {\n  const numberAsWEIHex = decGWEIToHexWEI(n);\n  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);\n  return numberAsGWEI;\n}\n\nexport async function fetchEip1159GasEstimates(url: string): Promise<EIP1159GasData> {\n  const estimates = await get<EIP1159GasData>(url);\n  const normalizedEstimates = {\n    ...estimates,\n    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),\n    low: {\n      ...estimates.low,\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas),\n    },\n    medium: {\n      ...estimates.medium,\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas),\n    },\n    high: {\n      ...estimates.high,\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas),\n    },\n  };\n  return normalizedEstimates;\n}\n\n/**\n * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium\n * high values from that API.\n */\nexport async function fetchLegacyGasPriceEstimates(url: string): Promise<LegacyGasData> {\n  const result = await get<{\n    SafeGasPrice: string;\n    ProposeGasPrice: string;\n    FastGasPrice: string;\n  }>(url, {\n    referrer: url,\n    referrerPolicy: \"no-referrer-when-downgrade\",\n    method: \"GET\",\n    mode: \"cors\",\n  });\n  return {\n    low: result.SafeGasPrice,\n    medium: result.ProposeGasPrice,\n    high: result.FastGasPrice,\n  };\n}\n\nexport const validateTypedMessageParams = (parameters: TypedMessageParams<unknown>, activeChainId: number) => {\n  try {\n    assert.ok(parameters && typeof parameters === \"object\", \"Params must be an object.\");\n    assert.ok(\"data\" in parameters, 'Params must include a \"data\" field.');\n    assert.ok(\"from\" in parameters, 'Params must include a \"from\" field.');\n    assert.ok(\n      typeof parameters.from === \"string\" && isValidAddress(parameters.from),\n      '\"from\" field must be a valid, lowercase, hexadecimal Ethereum address string.'\n    );\n    let data = null;\n    let chainId = null;\n    switch ((parameters as TypedMessageParams<unknown>).version) {\n      case SignTypedDataVersion.V1:\n        if (typeof parameters.data === \"string\") {\n          assert.doesNotThrow(() => {\n            data = JSON.parse(parameters.data as string);\n          }, '\"data\" must be a valid JSON string.');\n        } else {\n          // for backward compatiblity we validate for both string and object type.\n          data = parameters.data;\n        }\n        assert.ok(Array.isArray(data as unknown), \"params.data must be an array.\");\n        assert.doesNotThrow(() => {\n          typedSignatureHash(data as TypedDataV1Field[]);\n        }, \"Signing data must be valid EIP-712 typed data.\");\n        break;\n      case SignTypedDataVersion.V3:\n      case SignTypedDataVersion.V4:\n        if (typeof parameters.data === \"string\") {\n          assert.doesNotThrow(() => {\n            data = JSON.parse(parameters.data as string);\n          }, '\"data\" must be a valid JSON string.');\n        } else {\n          // for backward compatiblity we validate for both string and object type.\n          data = parameters.data;\n        }\n\n        assert.ok(data.primaryType in data.types, `Primary type of \"${data.primaryType}\" has no type definition.`);\n        const validation = jsonschema.validate(data, TYPED_MESSAGE_SCHEMA.properties);\n        assert.strictEqual(validation.errors.length, 0, \"Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.\");\n        chainId = data.domain?.chainId;\n        if (chainId) {\n          assert.ok(!Number.isNaN(activeChainId), `Cannot sign messages for chainId \"${chainId}\", because Web3Auth is switching networks.`);\n          if (typeof chainId === \"string\") {\n            chainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n          }\n          assert.strictEqual(chainId, activeChainId, `Provided chainId \"${chainId}\" must match the active chainId \"${activeChainId}\"`);\n        }\n        break;\n      default:\n        assert.fail(`Unknown typed data version \"${(parameters as TypedMessageParams<unknown>).version}\"`);\n    }\n  } catch (error) {\n    throw ethErrors.rpc.invalidInput({\n      message: error?.message,\n    });\n  }\n};\n","import { TransactionFactory } from \"@ethereumjs/tx\";\nimport { privateToAddress, stripHexPrefix } from \"@ethereumjs/util\";\nimport {\n  decrypt,\n  EthEncryptedData,\n  getEncryptionPublicKey,\n  MessageTypes,\n  personalSign,\n  signTypedData,\n  SignTypedDataVersion,\n  TypedDataV1,\n  TypedMessage,\n} from \"@metamask/eth-sig-util\";\nimport { signMessage } from \"@toruslabs/base-controllers\";\nimport { JRPCRequest } from \"@toruslabs/openlogin-jrpc\";\nimport { isHexStrict, log, SafeEventEmitterProvider } from \"@web3auth/base\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { IProviderHandlers, MessageParams, TransactionParams, TypedMessageParams } from \"../../rpc/interfaces\";\nimport { TransactionFormatter } from \"./TransactionFormatter\";\nimport { validateTypedMessageParams } from \"./TransactionFormatter/utils\";\n\nasync function signTx(txParams: TransactionParams & { gas?: string }, privKey: string, txFormatter: TransactionFormatter): Promise<Buffer> {\n  const finalTxParams = await txFormatter.formatTransaction(txParams);\n  const common = await txFormatter.getCommonConfiguration();\n  const unsignedEthTx = TransactionFactory.fromTxData(finalTxParams, {\n    common,\n  });\n  const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n  return signedTx;\n}\n\nexport function getProviderHandlers({\n  txFormatter,\n  privKey,\n  getProviderEngineProxy,\n}: {\n  txFormatter: TransactionFormatter;\n  privKey: string;\n  getProviderEngineProxy: () => SafeEventEmitterProvider | null;\n}): IProviderHandlers {\n  return {\n    getAccounts: async (_: JRPCRequest<unknown>) => [`0x${privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\")}`],\n    getPrivateKey: async (_: JRPCRequest<unknown>) => privKey,\n    processTransaction: async (txParams: TransactionParams & { gas?: string }, _: JRPCRequest<unknown>): Promise<string> => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy)\n        throw ethErrors.provider.custom({\n          message: \"Provider is not initialized\",\n          code: 4902,\n        });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      const txHash = await providerEngineProxy.request<string>({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))],\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams: TransactionParams & { gas?: string }, _: JRPCRequest<unknown>): Promise<string> => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy)\n        throw ethErrors.provider.custom({\n          message: \"Provider is not initialized\",\n          code: 4902,\n        });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      return `0x${signedTx.toString(\"hex\")}`;\n    },\n    processEthSignMessage: async (msgParams: MessageParams<string>, _: JRPCRequest<unknown>): Promise<string> => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams: MessageParams<string>, _: JRPCRequest<unknown>): Promise<string> => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({ privateKey: privKeyBuffer, data: msgParams.data });\n      return sig;\n    },\n    processTypedMessage: async (msgParams: MessageParams<TypedDataV1>, _: JRPCRequest<unknown>): Promise<string> => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy)\n        throw ethErrors.provider.custom({\n          message: \"Provider is not initialized\",\n          code: 4902,\n        });\n      const chainId = await providerEngineProxy.request<string>({ method: \"eth_chainId\" });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      const params = {\n        ...msgParams,\n        version: SignTypedDataVersion.V1,\n      };\n      validateTypedMessageParams(params, finalChainId);\n      const data = typeof params.data === \"string\" ? JSON.parse(params.data) : params.data;\n      const sig = signTypedData({ privateKey: privKeyBuffer, data, version: SignTypedDataVersion.V1 });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams: TypedMessageParams<TypedMessage<MessageTypes>>, _: JRPCRequest<unknown>): Promise<string> => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy)\n        throw ethErrors.provider.custom({\n          message: \"Provider is not initialized\",\n          code: 4902,\n        });\n      const chainId = await providerEngineProxy.request<string>({ method: \"eth_chainId\" });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      validateTypedMessageParams(msgParams, finalChainId);\n      const data = typeof msgParams.data === \"string\" ? JSON.parse(msgParams.data) : msgParams.data;\n      const sig = signTypedData({ privateKey: privKeyBuffer, data, version: SignTypedDataVersion.V3 });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams: TypedMessageParams<TypedMessage<MessageTypes>>, _: JRPCRequest<unknown>): Promise<string> => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy)\n        throw ethErrors.provider.custom({\n          message: \"Provider is not initialized\",\n          code: 4902,\n        });\n      const chainId = await providerEngineProxy.request<string>({ method: \"eth_chainId\" });\n      const finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n      validateTypedMessageParams(msgParams, finalChainId);\n      const data = typeof msgParams.data === \"string\" ? JSON.parse(msgParams.data) : msgParams.data;\n      const sig = signTypedData({ privateKey: privKeyBuffer, data, version: SignTypedDataVersion.V4 });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address: string, _: JRPCRequest<unknown>): Promise<string> => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams: MessageParams<string>, _: JRPCRequest<unknown>): string => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({ encryptedData: JSON.parse(buff.toString(\"utf8\")) as EthEncryptedData, privateKey: privKey });\n      return decrypted;\n    },\n  };\n}\n","import { addHexPrefix, stripHexPrefix } from \"@ethereumjs/util\";\nimport { BigNumber } from \"bignumber.js\";\nimport BN from \"bn.js\";\n\nexport function bnLessThan(a, b) {\n  if (a === null || a === undefined || b === null || b === undefined) {\n    return null;\n  }\n  return new BigNumber(a, 10).lt(b, 10);\n}\n\nexport function bnToHex(inputBn: BN) {\n  return addHexPrefix(inputBn.toString(16));\n}\n\nexport function hexToBn(inputHex: string): BN {\n  if (BN.isBN(inputHex)) return inputHex;\n  return new BN(stripHexPrefix(inputHex), 16);\n}\n\nexport function BnMultiplyByFraction(targetBN: BN, numerator: number | string, denominator: number | string): BN {\n  const numberBN = new BN(numerator);\n  const denomBN = new BN(denominator);\n  return targetBN.mul(numberBN).div(denomBN);\n}\n","export const LegacyGasAPIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices\";\nexport const EIP1559APIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees\";\nexport const TRANSACTION_ENVELOPE_TYPES = {\n  LEGACY: \"0x0\",\n  ACCESS_LIST: \"0x1\",\n  FEE_MARKET: \"0x2\",\n};\n\nexport const TRANSACTION_TYPES = {\n  SENT_ETHER: \"sentEther\",\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  STANDARD_TRANSACTION: \"transaction\",\n};\n\nexport const GAS_ESTIMATE_TYPES = {\n  FEE_MARKET: \"fee-market\",\n  LEGACY: \"legacy\",\n  ETH_GASPRICE: \"eth_gasPrice\",\n  NONE: \"none\",\n};\n","import { Common, Hardfork } from \"@ethereumjs/common\";\nimport { addHexPrefix, stripHexPrefix } from \"@ethereumjs/util\";\nimport { Block } from \"@toruslabs/openlogin-jrpc\";\nimport { CustomChainConfig, log, SafeEventEmitterProvider } from \"@web3auth/base\";\n\nimport { TransactionParams } from \"../../../rpc/interfaces\";\nimport { decGWEIToHexWEI, hexWEIToDecGWEI } from \"../../converter\";\nimport { bnLessThan, BnMultiplyByFraction, bnToHex, hexToBn } from \"../../utils\";\nimport { EIP1559APIEndpoint, GAS_ESTIMATE_TYPES, LegacyGasAPIEndpoint, TRANSACTION_ENVELOPE_TYPES, TRANSACTION_TYPES } from \"./constants\";\nimport { EIP1159GasData, FallbackGasData, GasData, LegacyGasData, TxType } from \"./interfaces\";\nimport { fetchEip1159GasEstimates, fetchLegacyGasPriceEstimates } from \"./utils\";\n\nexport class TransactionFormatter {\n  private chainConfig: CustomChainConfig | null = null;\n\n  private getProviderEngineProxy: () => SafeEventEmitterProvider;\n\n  private isEIP1559Compatible = false;\n\n  constructor({ getProviderEngineProxy }: { getProviderEngineProxy: () => SafeEventEmitterProvider }) {\n    this.getProviderEngineProxy = getProviderEngineProxy;\n  }\n\n  get providerProxy() {\n    return this.getProviderEngineProxy();\n  }\n\n  async init(): Promise<void> {\n    this.chainConfig = (await this.providerProxy.request<CustomChainConfig>({ method: \"eth_provider_config\", params: [] })) as CustomChainConfig;\n    this.isEIP1559Compatible = await this.getEIP1559Compatibility();\n  }\n\n  async getCommonConfiguration(): Promise<Common> {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const { displayName: name, chainId } = this.chainConfig;\n    const hardfork = this.isEIP1559Compatible ? Hardfork.London : Hardfork.Berlin;\n    const customChainParams = {\n      name,\n      chainId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      defaultHardfork: hardfork,\n    };\n    return Common.custom(customChainParams);\n  }\n\n  async formatTransaction(txParams: TransactionParams & { gas?: string }): Promise<TransactionParams & { gas?: string }> {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n\n    const clonedTxParams = {\n      ...txParams,\n    };\n\n    if (clonedTxParams.nonce === undefined)\n      clonedTxParams.nonce = (await this.providerProxy.request<number>({\n        method: \"eth_getTransactionCount\",\n        params: [txParams.from, \"latest\"],\n      })) as number;\n\n    if (!this.isEIP1559Compatible && clonedTxParams.gasPrice) {\n      if (clonedTxParams.maxFeePerGas) delete clonedTxParams.maxFeePerGas;\n      if (clonedTxParams.maxPriorityFeePerGas) delete clonedTxParams.maxPriorityFeePerGas;\n      // if gas is not provided explicitly, estimate it.\n      if (!clonedTxParams.gas) {\n        const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n        if (defaultGasLimit) {\n          clonedTxParams.gasLimit = defaultGasLimit;\n        }\n      } else {\n        clonedTxParams.gasLimit = clonedTxParams.gas;\n      }\n      return clonedTxParams;\n    }\n\n    if (!clonedTxParams.gas) {\n      const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n      if (defaultGasLimit) {\n        clonedTxParams.gasLimit = defaultGasLimit;\n      }\n    } else {\n      clonedTxParams.gasLimit = clonedTxParams.gas;\n    }\n\n    const {\n      gasPrice: defaultGasPrice,\n      maxFeePerGas: defaultMaxFeePerGas,\n      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas,\n    } = await this.getDefaultGasFees(clonedTxParams);\n\n    if (this.isEIP1559Compatible) {\n      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas\n      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.\n      if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n        clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;\n\n        clonedTxParams.maxPriorityFeePerGas = bnLessThan(\n          typeof defaultMaxPriorityFeePerGas === \"string\" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas,\n          typeof clonedTxParams.gasPrice === \"string\" ? stripHexPrefix(clonedTxParams.gasPrice) : clonedTxParams.gasPrice\n        )\n          ? defaultMaxPriorityFeePerGas\n          : clonedTxParams.gasPrice;\n      } else {\n        if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxFeePerGas = defaultMaxFeePerGas;\n        }\n\n        if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;\n        }\n\n        if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available\n          // then we set maxFeePerGas to the defaultGasPrice, assuming it is\n          // available.\n          clonedTxParams.maxFeePerGas = defaultGasPrice;\n        }\n\n        if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is\n          // available  then we set maxPriorityFeePerGas to\n          // clonedTxParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas\n          // set by the dapp, or the maxFeePerGas from the controller.\n          clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;\n        }\n      }\n\n      // We remove the gasPrice param entirely when on an eip1559 compatible network\n\n      delete clonedTxParams.gasPrice;\n    } else {\n      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params\n      // when not on a EIP1559 compatible network\n\n      delete clonedTxParams.maxPriorityFeePerGas;\n      delete clonedTxParams.maxFeePerGas;\n    }\n\n    // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are\n    // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest\n    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas\n    // were available from either the dapp or the network.\n    if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {\n      clonedTxParams.gasPrice = defaultGasPrice as never;\n    }\n\n    clonedTxParams.type = this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;\n    clonedTxParams.chainId = this.chainConfig.chainId;\n    return clonedTxParams;\n  }\n\n  private async fetchEthGasPriceEstimate(): Promise<{ gasPrice: string }> {\n    const gasPrice = (await this.providerProxy.request<string>({ method: \"eth_gasPrice\", params: [] })) as string;\n    return {\n      gasPrice: hexWEIToDecGWEI(gasPrice).toString(),\n    };\n  }\n\n  private async getEIP1559Compatibility(): Promise<boolean> {\n    const latestBlock = await this.providerProxy.request<Block>({ method: \"eth_getBlockByNumber\", params: [\"latest\", false] });\n    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;\n\n    return !!supportsEIP1559;\n  }\n\n  private async fetchGasFeeEstimateData(): Promise<GasData> {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const isLegacyGasAPICompatible = this.chainConfig.chainId === \"0x1\";\n\n    const chainId = Number.parseInt(this.chainConfig.chainId, 16);\n\n    let gasData: GasData;\n\n    try {\n      if (this.isEIP1559Compatible) {\n        // TODO: kovan is not working due to a bug in metamask api\n        const estimates = await fetchEip1159GasEstimates(EIP1559APIEndpoint.replace(\"<chain_id>\", `${chainId}`));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET,\n        };\n      } else if (isLegacyGasAPICompatible) {\n        const estimates = await fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace(\"<chain_id>\", `${chainId}`));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY,\n        };\n      } else {\n        throw new Error(\"Main gas fee/price estimation failed. Use fallback\");\n      }\n    } catch (e: unknown) {\n      try {\n        const estimates = await this.fetchEthGasPriceEstimate();\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE,\n        };\n      } catch (error: unknown) {\n        throw new Error(`Gas fee/price estimation failed. Message: ${(error as Error).message}`);\n      }\n    }\n    return gasData;\n  }\n\n  private async getDefaultGasFees(\n    txParams: TransactionParams & { gas?: string }\n  ): Promise<{ gasPrice?: string; maxFeePerGas?: string; maxPriorityFeePerGas?: string }> {\n    if ((!this.isEIP1559Compatible && txParams.gasPrice) || (this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas)) {\n      return {};\n    }\n\n    try {\n      const { gasFeeEstimates, gasEstimateType } = await this.fetchGasFeeEstimateData();\n      if (this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n        const { medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {} } = gasFeeEstimates as EIP1159GasData;\n\n        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {\n          return {\n            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxFeePerGas)),\n            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas)),\n          };\n        }\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n        // The LEGACY type includes low, medium and high estimates of\n        // gas price values.\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI((gasFeeEstimates as LegacyGasData).medium)),\n        };\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n        // The ETH_GASPRICE type just includes a single gas price property,\n        // which we can assume was retrieved from eth_gasPrice\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI((gasFeeEstimates as FallbackGasData).gasPrice)),\n        };\n      }\n    } catch (error) {\n      log.error(error);\n    }\n\n    const { gasPrice } = await this.fetchEthGasPriceEstimate();\n\n    return { gasPrice: addHexPrefix(decGWEIToHexWEI(gasPrice)) };\n  }\n\n  private async estimateTxGas(txMeta: TransactionParams): Promise<string> {\n    const txParams = { ...txMeta };\n\n    // `eth_estimateGas` can fail if the user has insufficient balance for the\n    // value being sent, or for the gas cost. We don't want to check their\n    // balance here, we just want the gas estimate. The gas price is removed\n    // to skip those balance checks. We check balance elsewhere. We also delete\n    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.\n    delete txParams.gasPrice;\n    delete txParams.maxFeePerGas;\n    delete txParams.maxPriorityFeePerGas;\n    const gas = (await this.providerProxy.request<string>({ method: \"eth_estimateGas\", params: [txParams] })) as string;\n    return gas;\n  }\n\n  private async analyzeGasUsage(txMeta: TransactionParams): Promise<{\n    blockGasLimit: string;\n    estimatedGasHex: string;\n  }> {\n    const block = (await this.providerProxy.request<Block>({ method: \"eth_getBlockByNumber\", params: [\"latest\", false] })) as Block;\n    // fallback to block gasLimit\n    const blockGasLimitBN = hexToBn(block.gasLimit as string);\n    const saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);\n    let estimatedGasHex = bnToHex(saferGasLimitBN);\n\n    try {\n      estimatedGasHex = await this.estimateTxGas(txMeta);\n    } catch (error: unknown) {\n      log.warn(error);\n    }\n    return { blockGasLimit: block.gasLimit as string, estimatedGasHex };\n  }\n\n  private addGasBuffer(initialGasLimitHex: string, blockGasLimitHex: string, multiplier = 1.5): string {\n    const initialGasLimitBn = hexToBn(initialGasLimitHex);\n    const blockGasLimitBn = hexToBn(blockGasLimitHex);\n    const upperGasLimitBn = blockGasLimitBn.muln(0.9);\n    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);\n\n    // if initialGasLimit is above blockGasLimit, dont modify it\n    if (initialGasLimitBn.gt(upperGasLimitBn)) return bnToHex(initialGasLimitBn);\n    // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit\n    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return bnToHex(bufferedGasLimitBn);\n    // otherwise use blockGasLimit\n    return bnToHex(upperGasLimitBn);\n  }\n\n  private async determineTransactionCategory(txParameters: TransactionParams & { gas?: string }): Promise<{\n    transactionCategory: TxType | null;\n    code?: string;\n  }> {\n    const { data, to } = txParameters;\n    let code = \"\";\n\n    let txCategory: TxType | null;\n\n    if (data && !to) {\n      txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;\n    } else {\n      try {\n        code = (await this.providerProxy.request<string>({ method: \"eth_getCode\", params: [to, \"latest\"] })) as string;\n      } catch (error) {\n        log.warn(error);\n      }\n      const codeIsEmpty = !code || code === \"0x\" || code === \"0x0\";\n\n      txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;\n    }\n\n    return { transactionCategory: txCategory, code };\n  }\n\n  private async getDefaultGasLimit(txParams: TransactionParams & { gas?: string }): Promise<string> {\n    const { transactionCategory } = await this.determineTransactionCategory({ ...txParams });\n\n    if (txParams.gas) {\n      return txParams.gas;\n    }\n\n    if (txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER) {\n      // if there's data in the params, but there's no contract code, it's not a valid transaction\n      if (txParams.data) {\n        throw Error(\"TxGasUtil - Trying to call a function on a non-contract address\");\n      }\n\n      const TWENTY_ONE_THOUSAND = 21_000;\n\n      // This is a standard ether simple send, gas requirement is exactly 21k\n      return addHexPrefix(TWENTY_ONE_THOUSAND.toString(16));\n    }\n\n    const { blockGasLimit, estimatedGasHex } = await this.analyzeGasUsage(txParams);\n\n    // add additional gas buffer to our estimation for safety\n    const gasLimit = this.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit as string);\n    return gasLimit;\n  }\n}\n","import { JRPCEngine, JRPCMiddleware, providerFromEngine } from \"@toruslabs/openlogin-jrpc\";\nimport { CHAIN_NAMESPACES, CustomChainConfig } from \"@web3auth/base\";\nimport { BaseProvider, BaseProviderConfig, BaseProviderState } from \"@web3auth/base-provider\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { createAccountMiddleware, createChainSwitchMiddleware, createEthMiddleware } from \"../../rpc/ethRpcMiddlewares\";\nimport { AddEthereumChainParameter, IAccountHandlers, IChainSwitchHandlers } from \"../../rpc/interfaces\";\nimport { createJsonRpcClient } from \"../../rpc/jrpcClient\";\nimport { getProviderHandlers } from \"./ethPrivatekeyUtils\";\nimport { TransactionFormatter } from \"./TransactionFormatter\";\n\nexport interface EthereumPrivKeyProviderConfig extends BaseProviderConfig {\n  chainConfig: Omit<CustomChainConfig, \"chainNamespace\">;\n}\n\nexport interface EthereumPrivKeyProviderState extends BaseProviderState {\n  privateKey?: string;\n}\n\nexport class EthereumPrivateKeyProvider extends BaseProvider<BaseProviderConfig, EthereumPrivKeyProviderState, string> {\n  constructor({ config, state }: { config: EthereumPrivKeyProviderConfig; state?: EthereumPrivKeyProviderState }) {\n    super({ config: { chainConfig: { ...config.chainConfig, chainNamespace: CHAIN_NAMESPACES.EIP155 } }, state });\n  }\n\n  public static getProviderInstance = async (params: {\n    privKey: string;\n    chainConfig: Omit<CustomChainConfig, \"chainNamespace\">;\n  }): Promise<EthereumPrivateKeyProvider> => {\n    const providerFactory = new EthereumPrivateKeyProvider({ config: { chainConfig: params.chainConfig } });\n    await providerFactory.setupProvider(params.privKey);\n    return providerFactory;\n  };\n\n  public async enable(): Promise<string[]> {\n    if (!this.state.privateKey)\n      throw ethErrors.provider.custom({ message: \"Private key is not found in state, plz pass it in constructor state param\", code: 4902 });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({ method: \"eth_accounts\" });\n  }\n\n  public async setupProvider(privKey: string): Promise<void> {\n    const txFormatter = new TransactionFormatter({\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this),\n    });\n    const providerHandlers = getProviderHandlers({\n      txFormatter,\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this),\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine();\n    // Not a partial anymore because of checks in ctor\n    const { networkMiddleware } = createJsonRpcClient(this.config.chainConfig as CustomChainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await txFormatter.init();\n    await this.lookupNetwork();\n  }\n\n  public async updateAccount(params: { privateKey: string }): Promise<void> {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n    const existingKey = await this._providerEngineProxy.request<string>({ method: \"eth_private_key\" });\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request<string[]>({ method: \"eth_accounts\" }),\n      });\n    }\n  }\n\n  public async switchChain(params: { chainId: string }): Promise<void> {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\",\n    });\n    this.configure({ chainConfig });\n    const privKey = await this._providerEngineProxy.request<string>({ method: \"eth_private_key\" });\n    await this.setupProvider(privKey);\n  }\n\n  protected async lookupNetwork(): Promise<string> {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n    const { chainId } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request<string>({\n      method: \"net_version\",\n      params: [],\n    });\n\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(`Invalid network, net_version is: ${network}`);\n    if (this.state.chainId !== chainId) {\n      this._providerEngineProxy.emit(\"chainChanged\", chainId);\n      this._providerEngineProxy.emit(\"connect\", { chainId });\n    }\n    this.update({ chainId });\n    return network;\n  }\n\n  private getChainSwitchMiddleware(): JRPCMiddleware<unknown, unknown> {\n    const chainSwitchHandlers: IChainSwitchHandlers = {\n      addChain: async (params: AddEthereumChainParameter): Promise<void> => {\n        const { chainId, chainName, rpcUrls, blockExplorerUrls, nativeCurrency } = params;\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.EIP155,\n          chainId,\n          ticker: nativeCurrency?.symbol || \"ETH\",\n          tickerName: nativeCurrency?.name || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: blockExplorerUrls?.[0] || \"\",\n          decimals: nativeCurrency?.decimals || 18,\n        });\n      },\n      switchChain: async (params: { chainId: string }): Promise<void> => {\n        const { chainId } = params;\n        await this.switchChain({ chainId });\n      },\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  private getAccountMiddleware(): JRPCMiddleware<unknown, unknown> {\n    const accountHandlers: IAccountHandlers = {\n      updatePrivatekey: async (params: { privateKey: string }): Promise<void> => {\n        const { privateKey } = params;\n        await this.updateAccount({ privateKey });\n      },\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}