{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionFactory = void 0;\nconst util_1 = require(\"@ethereumjs/util\");\nconst eip1559Transaction_1 = require(\"./eip1559Transaction\");\nconst eip2930Transaction_1 = require(\"./eip2930Transaction\");\nconst fromRpc_1 = require(\"./fromRpc\");\nconst legacyTransaction_1 = require(\"./legacyTransaction\");\nclass TransactionFactory {\n  // It is not possible to instantiate a TransactionFactory object.\n  constructor() {}\n  /**\n   * Create a transaction from a `txData` object\n   *\n   * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)\n   * @param txOptions - Options to pass on to the constructor of the transaction\n   */\n  static fromTxData(txData, txOptions = {}) {\n    if (!('type' in txData) || txData.type === undefined) {\n      // Assume legacy transaction\n      return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);\n    } else {\n      const txType = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.type)));\n      if (txType === 0) {\n        return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);\n      } else if (txType === 1) {\n        return eip2930Transaction_1.AccessListEIP2930Transaction.fromTxData(txData, txOptions);\n      } else if (txType === 2) {\n        return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);\n      } else {\n        throw new Error(`Tx instantiation with type ${txType} not supported`);\n      }\n    }\n  }\n  /**\n   * This method tries to decode serialized data.\n   *\n   * @param data - The data Buffer\n   * @param txOptions - The transaction options\n   */\n  static fromSerializedData(data, txOptions = {}) {\n    if (data[0] <= 0x7f) {\n      // Determine the type.\n      switch (data[0]) {\n        case 1:\n          return eip2930Transaction_1.AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);\n        case 2:\n          return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);\n        default:\n          throw new Error(`TypedTransaction with ID ${data[0]} unknown`);\n      }\n    } else {\n      return legacyTransaction_1.Transaction.fromSerializedTx(data, txOptions);\n    }\n  }\n  /**\n   * When decoding a BlockBody, in the transactions field, a field is either:\n   * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))\n   * A Buffer[] (Legacy Transaction)\n   * This method returns the right transaction.\n   *\n   * @param data - A Buffer or Buffer[]\n   * @param txOptions - The transaction options\n   */\n  static fromBlockBodyData(data, txOptions = {}) {\n    if (Buffer.isBuffer(data)) {\n      return this.fromSerializedData(data, txOptions);\n    } else if (Array.isArray(data)) {\n      // It is a legacy transaction\n      return legacyTransaction_1.Transaction.fromValuesArray(data, txOptions);\n    } else {\n      throw new Error('Cannot decode transaction: unknown type input');\n    }\n  }\n  /**\n   *  Method to retrieve a transaction from the provider\n   * @param provider - An Ethers JsonRPCProvider\n   * @param txHash - Transaction hash\n   * @param txOptions - The transaction options\n   * @returns the transaction specified by `txHash`\n   */\n  static async fromEthersProvider(provider, txHash, txOptions) {\n    const prov = (0, util_1.getProvider)(provider);\n    const txData = await (0, util_1.fetchFromProvider)(prov, {\n      method: 'eth_getTransactionByHash',\n      params: [txHash]\n    });\n    if (txData === null) {\n      throw new Error('No data returned from provider');\n    }\n    return TransactionFactory.fromRPCTx(txData, txOptions);\n  }\n  /**\n   * Method to decode data retrieved from RPC, such as `eth_getTransactionByHash`\n   * Note that this normalizes some of the parameters\n   * @param txData The RPC-encoded data\n   * @param txOptions The transaction options\n   * @returns\n   */\n  static async fromRPCTx(txData, txOptions = {}) {\n    return TransactionFactory.fromTxData((0, fromRpc_1.normalizeTxParams)(txData), txOptions);\n  }\n}\nexports.TransactionFactory = TransactionFactory;","map":{"version":3,"names":["util_1","require","eip1559Transaction_1","eip2930Transaction_1","fromRpc_1","legacyTransaction_1","TransactionFactory","constructor","fromTxData","txData","txOptions","type","undefined","Transaction","txType","Number","bufferToBigInt","toBuffer","AccessListEIP2930Transaction","FeeMarketEIP1559Transaction","Error","fromSerializedData","data","fromSerializedTx","fromBlockBodyData","Buffer","isBuffer","Array","isArray","fromValuesArray","fromEthersProvider","provider","txHash","prov","getProvider","fetchFromProvider","method","params","fromRPCTx","normalizeTxParams","exports"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@ethereumjs/tx/src/transactionFactory.ts"],"sourcesContent":["import { bufferToBigInt, fetchFromProvider, getProvider, toBuffer } from '@ethereumjs/util'\n\nimport { FeeMarketEIP1559Transaction } from './eip1559Transaction'\nimport { AccessListEIP2930Transaction } from './eip2930Transaction'\nimport { normalizeTxParams } from './fromRpc'\nimport { Transaction } from './legacyTransaction'\n\nimport type {\n  AccessListEIP2930TxData,\n  FeeMarketEIP1559TxData,\n  TxData,\n  TxOptions,\n  TypedTransaction,\n} from './types'\n\nexport class TransactionFactory {\n  // It is not possible to instantiate a TransactionFactory object.\n  private constructor() {}\n\n  /**\n   * Create a transaction from a `txData` object\n   *\n   * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)\n   * @param txOptions - Options to pass on to the constructor of the transaction\n   */\n  public static fromTxData(\n    txData: TxData | AccessListEIP2930TxData | FeeMarketEIP1559TxData,\n    txOptions: TxOptions = {}\n  ): TypedTransaction {\n    if (!('type' in txData) || txData.type === undefined) {\n      // Assume legacy transaction\n      return Transaction.fromTxData(<TxData>txData, txOptions)\n    } else {\n      const txType = Number(bufferToBigInt(toBuffer(txData.type)))\n      if (txType === 0) {\n        return Transaction.fromTxData(<TxData>txData, txOptions)\n      } else if (txType === 1) {\n        return AccessListEIP2930Transaction.fromTxData(<AccessListEIP2930TxData>txData, txOptions)\n      } else if (txType === 2) {\n        return FeeMarketEIP1559Transaction.fromTxData(<FeeMarketEIP1559TxData>txData, txOptions)\n      } else {\n        throw new Error(`Tx instantiation with type ${txType} not supported`)\n      }\n    }\n  }\n\n  /**\n   * This method tries to decode serialized data.\n   *\n   * @param data - The data Buffer\n   * @param txOptions - The transaction options\n   */\n  public static fromSerializedData(data: Buffer, txOptions: TxOptions = {}): TypedTransaction {\n    if (data[0] <= 0x7f) {\n      // Determine the type.\n      switch (data[0]) {\n        case 1:\n          return AccessListEIP2930Transaction.fromSerializedTx(data, txOptions)\n        case 2:\n          return FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions)\n        default:\n          throw new Error(`TypedTransaction with ID ${data[0]} unknown`)\n      }\n    } else {\n      return Transaction.fromSerializedTx(data, txOptions)\n    }\n  }\n\n  /**\n   * When decoding a BlockBody, in the transactions field, a field is either:\n   * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))\n   * A Buffer[] (Legacy Transaction)\n   * This method returns the right transaction.\n   *\n   * @param data - A Buffer or Buffer[]\n   * @param txOptions - The transaction options\n   */\n  public static fromBlockBodyData(data: Buffer | Buffer[], txOptions: TxOptions = {}) {\n    if (Buffer.isBuffer(data)) {\n      return this.fromSerializedData(data, txOptions)\n    } else if (Array.isArray(data)) {\n      // It is a legacy transaction\n      return Transaction.fromValuesArray(data, txOptions)\n    } else {\n      throw new Error('Cannot decode transaction: unknown type input')\n    }\n  }\n\n  /**\n   *  Method to retrieve a transaction from the provider\n   * @param provider - An Ethers JsonRPCProvider\n   * @param txHash - Transaction hash\n   * @param txOptions - The transaction options\n   * @returns the transaction specified by `txHash`\n   */\n  public static async fromEthersProvider(\n    provider: string | any,\n    txHash: string,\n    txOptions?: TxOptions\n  ) {\n    const prov = getProvider(provider)\n    const txData = await fetchFromProvider(prov, {\n      method: 'eth_getTransactionByHash',\n      params: [txHash],\n    })\n    if (txData === null) {\n      throw new Error('No data returned from provider')\n    }\n    return TransactionFactory.fromRPCTx(txData, txOptions)\n  }\n\n  /**\n   * Method to decode data retrieved from RPC, such as `eth_getTransactionByHash`\n   * Note that this normalizes some of the parameters\n   * @param txData The RPC-encoded data\n   * @param txOptions The transaction options\n   * @returns\n   */\n  public static async fromRPCTx(\n    txData: TxData | AccessListEIP2930TxData | FeeMarketEIP1559TxData,\n    txOptions: TxOptions = {}\n  ) {\n    return TransactionFactory.fromTxData(normalizeTxParams(txData), txOptions)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}