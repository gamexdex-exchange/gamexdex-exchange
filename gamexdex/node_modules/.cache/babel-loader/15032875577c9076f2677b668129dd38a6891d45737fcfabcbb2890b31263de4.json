{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, WalletInitializationError, log, CHAIN_NAMESPACES, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WALLET_ADAPTERS, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport { PLUGIN_NAMESPACES } from '@web3auth/base-plugin';\nimport { CommonJRPCProvider } from '@web3auth/base-provider';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\nclass Web3AuthNoModal extends SafeEventEmitter {\n  constructor(options) {\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n    super();\n    _defineProperty(this, \"coreOptions\", void 0);\n    _defineProperty(this, \"connectedAdapterName\", null);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"cachedAdapter\", null);\n    _defineProperty(this, \"walletAdapters\", {});\n    _defineProperty(this, \"commonJRPCProvider\", null);\n    _defineProperty(this, \"plugins\", {});\n    _defineProperty(this, \"storage\", \"localStorage\");\n    if (!options.clientId) throw WalletInitializationError.invalidParams(\"Please provide a valid clientId in constructor\");\n    if (options.enableLogging) log.enableAll();else log.setLevel(\"error\");\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    if (options.storageKey === \"session\") this.storage = \"sessionStorage\";\n    this.cachedAdapter = storageAvailable(this.storage) ? window[this.storage].getItem(ADAPTER_CACHE_KEY) : null;\n    this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId) || {}), options.chainConfig)\n    });\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n  get connected() {\n    return Boolean(this.connectedAdapterName);\n  }\n  get provider() {\n    if (this.status !== ADAPTER_STATUS.NOT_READY && this.commonJRPCProvider) {\n      return this.commonJRPCProvider.provider;\n    }\n    return null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init() {\n    this.commonJRPCProvider = await CommonJRPCProvider.getProviderInstance({\n      chainConfig: this.coreOptions.chainConfig\n    });\n    const initPromises = Object.keys(this.walletAdapters).map(adapterName => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]);\n      // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n        this.walletAdapters[adapterName].setAdapterSettings({\n          chainConfig: providedChainConfig,\n          sessionTime: this.coreOptions.sessionTime,\n          clientId: this.coreOptions.clientId,\n          web3AuthNetwork: this.coreOptions.web3AuthNetwork,\n          useCoreKitKey: this.coreOptions.useCoreKitKey\n        });\n      } else {\n        this.walletAdapters[adapterName].setAdapterSettings({\n          sessionTime: this.coreOptions.sessionTime,\n          clientId: this.coreOptions.clientId,\n          web3AuthNetwork: this.coreOptions.web3AuthNetwork,\n          useCoreKitKey: this.coreOptions.useCoreKitKey\n        });\n      }\n      return this.walletAdapters[adapterName].init({\n        autoConnect: this.cachedAdapter === adapterName\n      }).catch(e => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n  configureAdapter(adapter) {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(`Wallet adapter for ${adapter.name} already exists`);\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(`This wallet adapter belongs to ${adapter.adapterNamespace} which is incompatible with currently used namespace: ${providedChainConfig.chainNamespace}`);\n    if (adapter.name === WALLET_ADAPTERS.WALLET_CONNECT_V2 && this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V1]) {\n      throw WalletInitializationError.invalidParams(\"Either one of wallet connect v2 or wallet connect v1 can be used, wallet connect v1 is already added to adapter lists.\");\n    }\n    if (adapter.name === WALLET_ADAPTERS.WALLET_CONNECT_V1 && this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V2]) {\n      throw WalletInitializationError.invalidParams(\"Either one of wallet connect v2 or wallet connect v1 can be used, wallet connect v2 is already added to adapter lists.\");\n    }\n    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setAdapterSettings({\n        chainConfig: providedChainConfig\n      });\n    }\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n  clearCache() {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n  async addChain(chainConfig) {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) return this.walletAdapters[this.connectedAdapterName].addChain(chainConfig);\n    if (this.commonJRPCProvider) {\n      return this.commonJRPCProvider.addChain(chainConfig);\n    }\n    throw WalletInitializationError.notReady(`No wallet is ready`);\n  }\n  async switchChain(params) {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) return this.walletAdapters[this.connectedAdapterName].switchChain(params);\n    if (this.commonJRPCProvider) {\n      return this.commonJRPCProvider.switchChain(params);\n    }\n    throw WalletInitializationError.notReady(`No wallet is ready`);\n  }\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n  async connectTo(walletName, loginParams) {\n    if (!this.walletAdapters[walletName] || !this.commonJRPCProvider) throw WalletInitializationError.notFound(`Please add wallet adapter for ${walletName} wallet, before connecting`);\n    const provider = await this.walletAdapters[walletName].connect(loginParams);\n    this.commonJRPCProvider.updateProviderEngineProxy(provider);\n    return this.provider;\n  }\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n  async getUserInfo() {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n  async authenticateUser() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].authenticateUser();\n  }\n  async addPlugin(plugin) {\n    if (this.plugins[plugin.name]) throw new Error(`Plugin ${plugin.name} already exist`);\n    if (plugin.pluginNamespace !== PLUGIN_NAMESPACES.MULTICHAIN && plugin.pluginNamespace !== this.coreOptions.chainConfig.chainNamespace) throw new Error(`This plugin belongs to ${plugin.pluginNamespace} namespace which is incompatible with currently used namespace: ${this.coreOptions.chainConfig.chainNamespace}`);\n    this.plugins[plugin.name] = plugin;\n    return this;\n  }\n  subscribeToAdapterEvents(walletAdapter) {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, async data => {\n      if (!this.commonJRPCProvider) throw WalletInitializationError.notFound(`CommonJrpcProvider not found`);\n      const {\n        provider\n      } = this.walletAdapters[data.adapter];\n      this.commonJRPCProvider.updateProviderEngineProxy(provider);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n      Object.values(this.plugins).map(async plugin => {\n        try {\n          if (!plugin.SUPPORTED_ADAPTERS.includes(data.adapter)) {\n            return;\n          }\n          await plugin.initWithWeb3Auth(this);\n          await plugin.connect();\n        } catch (error) {\n          // swallow error if connector adapter doesn't supports this plugin.\n          if (error.code === 5211) {\n            return;\n          }\n          log.error(error);\n        }\n      });\n      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n    });\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, async data => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n      if (storageAvailable(this.storage)) {\n        const cachedAdapter = window[this.storage].getItem(ADAPTER_CACHE_KEY);\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n      await Promise.all(Object.values(this.plugins).map(plugin => {\n        return plugin.disconnect().catch(error => {\n          // swallow error if adapter doesn't supports this plugin.\n          if (error.code === 5211) {\n            return;\n          }\n          // throw error;\n          log.error(error);\n        });\n      }));\n      this.connectedAdapterName = null;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, data => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, data => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CACHE_CLEAR, data => {\n      log.debug(\"adapter cache clear\", data);\n      if (storageAvailable(this.storage)) {\n        this.clearCache();\n      }\n    });\n  }\n  checkInitRequirements() {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n  cacheWallet(walletName) {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n}\nexport { Web3AuthNoModal };","map":{"version":3,"names":["ADAPTER_CACHE_KEY","Web3AuthNoModal","SafeEventEmitter","constructor","options","_options$chainConfig","_options$chainConfig2","_options$chainConfig3","_options$chainConfig4","_defineProperty","ADAPTER_STATUS","NOT_READY","clientId","WalletInitializationError","invalidParams","enableLogging","log","enableAll","setLevel","chainConfig","chainNamespace","Object","values","CHAIN_NAMESPACES","includes","storageKey","storage","cachedAdapter","storageAvailable","window","getItem","coreOptions","_objectSpread","getChainConfig","chainId","subscribeToAdapterEvents","bind","connected","Boolean","connectedAdapterName","provider","status","commonJRPCProvider","_","Error","init","CommonJRPCProvider","getProviderInstance","initPromises","keys","walletAdapters","map","adapterName","chainConfigProxy","providedChainConfig","setAdapterSettings","sessionTime","web3AuthNetwork","useCoreKitKey","autoConnect","catch","e","error","READY","Promise","all","configureAdapter","adapter","checkInitRequirements","adapterAlreadyExists","name","duplicateAdapterError","adapterNamespace","ADAPTER_NAMESPACES","MULTICHAIN","incompatibleChainNameSpace","WALLET_ADAPTERS","WALLET_CONNECT_V2","WALLET_CONNECT_V1","currentChainNamespace","clearCache","removeItem","addChain","CONNECTED","notReady","switchChain","params","connectTo","walletName","loginParams","notFound","connect","updateProviderEngineProxy","logout","arguments","length","undefined","cleanup","WalletLoginError","notConnectedError","disconnect","getUserInfo","debug","authenticateUser","addPlugin","plugin","plugins","pluginNamespace","PLUGIN_NAMESPACES","walletAdapter","on","ADAPTER_EVENTS","data","cacheWallet","SUPPORTED_ADAPTERS","initWithWeb3Auth","code","emit","DISCONNECTED","CONNECTING","ERRORED","ADAPTER_DATA_UPDATED","CACHE_CLEAR","setItem"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/no-modal/src/noModal.ts"],"sourcesContent":["import { SafeEventEmitter } from \"@toruslabs/openlogin-jrpc\";\nimport type { OPENLOGIN_NETWORK_TYPE } from \"@toruslabs/openlogin-utils\";\nimport {\n  ADAPTER_EVENTS,\n  ADAPTER_NAMESPACES,\n  ADAPTER_STATUS,\n  ADAPTER_STATUS_TYPE,\n  CHAIN_NAMESPACES,\n  CONNECTED_EVENT_DATA,\n  CustomChainConfig,\n  getChainConfig,\n  IAdapter,\n  IWeb3Auth,\n  log,\n  SafeEventEmitterProvider,\n  storageAvailable,\n  UserAuthInfo,\n  UserInfo,\n  WALLET_ADAPTER_TYPE,\n  WALLET_ADAPTERS,\n  WalletInitializationError,\n  WalletLoginError,\n  Web3AuthError,\n} from \"@web3auth/base\";\nimport { IPlugin, PLUGIN_NAMESPACES } from \"@web3auth/base-plugin\";\nimport { CommonJRPCProvider } from \"@web3auth/base-provider\";\n\nexport interface Web3AuthNoModalOptions {\n  /**\n   * Client id for web3auth.\n   * You can obtain your client id from the web3auth developer dashboard.\n   * You can set any random string for this on localhost.\n   */\n  clientId: string;\n  /**\n   * custom chain configuration for chainNamespace\n   *\n   * @defaultValue mainnet config of provided chainNamespace\n   */\n  chainConfig: Partial<CustomChainConfig> & Pick<CustomChainConfig, \"chainNamespace\">;\n\n  /**\n   * setting to true will enable logs\n   *\n   * @defaultValue false\n   */\n  enableLogging?: boolean;\n  /**\n   * setting to \"local\" will persist social login session accross browser tabs.\n   *\n   * @defaultValue \"local\"\n   */\n  storageKey?: \"session\" | \"local\";\n\n  /**\n   * sessionTime (in seconds) for idToken issued by Web3Auth for server side verification.\n   * @defaultValue 86400\n   *\n   * Note: max value can be 7 days (86400 * 7) and min can be  1 day (86400)\n   */\n  sessionTime?: number;\n  /**\n   * Web3Auth Network to use for the session & the issued idToken\n   * @defaultValue mainnet\n   */\n  web3AuthNetwork?: OPENLOGIN_NETWORK_TYPE;\n\n  /**\n   * Uses core-kit key with web3auth provider\n   * @defaultValue false\n   */\n  useCoreKitKey?: boolean;\n}\n\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\nexport class Web3AuthNoModal extends SafeEventEmitter implements IWeb3Auth {\n  readonly coreOptions: Web3AuthNoModalOptions;\n\n  public connectedAdapterName: WALLET_ADAPTER_TYPE | null = null;\n\n  public status: ADAPTER_STATUS_TYPE = ADAPTER_STATUS.NOT_READY;\n\n  public cachedAdapter: string | null = null;\n\n  protected walletAdapters: Record<string, IAdapter<unknown>> = {};\n\n  protected commonJRPCProvider: CommonJRPCProvider | null = null;\n\n  private plugins: Record<string, IPlugin> = {};\n\n  private storage: \"sessionStorage\" | \"localStorage\" = \"localStorage\";\n\n  constructor(options: Web3AuthNoModalOptions) {\n    super();\n    if (!options.clientId) throw WalletInitializationError.invalidParams(\"Please provide a valid clientId in constructor\");\n    if (options.enableLogging) log.enableAll();\n    else log.setLevel(\"error\");\n    if (!options.chainConfig?.chainNamespace || !Object.values(CHAIN_NAMESPACES).includes(options.chainConfig?.chainNamespace))\n      throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    if (options.storageKey === \"session\") this.storage = \"sessionStorage\";\n    this.cachedAdapter = storageAvailable(this.storage) ? window[this.storage].getItem(ADAPTER_CACHE_KEY) : null;\n\n    this.coreOptions = {\n      ...options,\n      chainConfig: {\n        ...(getChainConfig(options.chainConfig?.chainNamespace, options.chainConfig?.chainId) || {}),\n        ...options.chainConfig,\n      },\n    };\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n\n  get connected(): boolean {\n    return Boolean(this.connectedAdapterName);\n  }\n\n  get provider(): SafeEventEmitterProvider | null {\n    if (this.status !== ADAPTER_STATUS.NOT_READY && this.commonJRPCProvider) {\n      return this.commonJRPCProvider.provider;\n    }\n    return null;\n  }\n\n  set provider(_: SafeEventEmitterProvider | null) {\n    throw new Error(\"Not implemented\");\n  }\n\n  public async init(): Promise<void> {\n    this.commonJRPCProvider = await CommonJRPCProvider.getProviderInstance({ chainConfig: this.coreOptions.chainConfig as CustomChainConfig });\n    const initPromises = Object.keys(this.walletAdapters).map((adapterName) => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]);\n      // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n        this.walletAdapters[adapterName].setAdapterSettings({\n          chainConfig: providedChainConfig,\n          sessionTime: this.coreOptions.sessionTime,\n          clientId: this.coreOptions.clientId,\n          web3AuthNetwork: this.coreOptions.web3AuthNetwork,\n          useCoreKitKey: this.coreOptions.useCoreKitKey,\n        });\n      } else {\n        this.walletAdapters[adapterName].setAdapterSettings({\n          sessionTime: this.coreOptions.sessionTime,\n          clientId: this.coreOptions.clientId,\n          web3AuthNetwork: this.coreOptions.web3AuthNetwork,\n          useCoreKitKey: this.coreOptions.useCoreKitKey,\n        });\n      }\n\n      return this.walletAdapters[adapterName].init({ autoConnect: this.cachedAdapter === adapterName }).catch((e) => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n\n  public configureAdapter(adapter: IAdapter<unknown>): Web3AuthNoModal {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(`Wallet adapter for ${adapter.name} already exists`);\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace)\n      throw WalletInitializationError.incompatibleChainNameSpace(\n        `This wallet adapter belongs to ${adapter.adapterNamespace} which is incompatible with currently used namespace: ${providedChainConfig.chainNamespace}`\n      );\n\n    if (adapter.name === WALLET_ADAPTERS.WALLET_CONNECT_V2 && this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V1]) {\n      throw WalletInitializationError.invalidParams(\n        \"Either one of wallet connect v2 or wallet connect v1 can be used, wallet connect v1 is already added to adapter lists.\"\n      );\n    }\n    if (adapter.name === WALLET_ADAPTERS.WALLET_CONNECT_V1 && this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V2]) {\n      throw WalletInitializationError.invalidParams(\n        \"Either one of wallet connect v2 or wallet connect v1 can be used, wallet connect v2 is already added to adapter lists.\"\n      );\n    }\n\n    if (\n      adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN &&\n      adapter.currentChainNamespace &&\n      providedChainConfig.chainNamespace !== adapter.currentChainNamespace\n    ) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setAdapterSettings({ chainConfig: providedChainConfig as CustomChainConfig });\n    }\n\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n\n  public clearCache() {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n\n  public async addChain(chainConfig: CustomChainConfig): Promise<void> {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName)\n      return this.walletAdapters[this.connectedAdapterName].addChain(chainConfig);\n\n    if (this.commonJRPCProvider) {\n      return this.commonJRPCProvider.addChain(chainConfig);\n    }\n    throw WalletInitializationError.notReady(`No wallet is ready`);\n  }\n\n  public async switchChain(params: { chainId: string }): Promise<void> {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName)\n      return this.walletAdapters[this.connectedAdapterName].switchChain(params);\n\n    if (this.commonJRPCProvider) {\n      return this.commonJRPCProvider.switchChain(params);\n    }\n    throw WalletInitializationError.notReady(`No wallet is ready`);\n  }\n\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n  async connectTo<T>(walletName: WALLET_ADAPTER_TYPE, loginParams?: T): Promise<SafeEventEmitterProvider | null> {\n    if (!this.walletAdapters[walletName] || !this.commonJRPCProvider)\n      throw WalletInitializationError.notFound(`Please add wallet adapter for ${walletName} wallet, before connecting`);\n    const provider = await this.walletAdapters[walletName].connect(loginParams);\n    this.commonJRPCProvider.updateProviderEngineProxy(provider as SafeEventEmitterProvider);\n    return this.provider;\n  }\n\n  async logout(options: { cleanup: boolean } = { cleanup: false }): Promise<void> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n\n  async getUserInfo(): Promise<Partial<UserInfo>> {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n\n  async authenticateUser(): Promise<UserAuthInfo> {\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);\n    return this.walletAdapters[this.connectedAdapterName].authenticateUser();\n  }\n\n  public async addPlugin(plugin: IPlugin): Promise<IWeb3Auth> {\n    if (this.plugins[plugin.name]) throw new Error(`Plugin ${plugin.name} already exist`);\n    if (plugin.pluginNamespace !== PLUGIN_NAMESPACES.MULTICHAIN && plugin.pluginNamespace !== this.coreOptions.chainConfig.chainNamespace)\n      throw new Error(\n        `This plugin belongs to ${plugin.pluginNamespace} namespace which is incompatible with currently used namespace: ${this.coreOptions.chainConfig.chainNamespace}`\n      );\n\n    this.plugins[plugin.name] = plugin;\n    return this;\n  }\n\n  protected subscribeToAdapterEvents(walletAdapter: IAdapter<unknown>): void {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, async (data: CONNECTED_EVENT_DATA) => {\n      if (!this.commonJRPCProvider) throw WalletInitializationError.notFound(`CommonJrpcProvider not found`);\n      const { provider } = this.walletAdapters[data.adapter];\n      this.commonJRPCProvider.updateProviderEngineProxy(provider as SafeEventEmitterProvider);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n\n      Object.values(this.plugins).map(async (plugin) => {\n        try {\n          if (!plugin.SUPPORTED_ADAPTERS.includes(data.adapter)) {\n            return;\n          }\n          await plugin.initWithWeb3Auth(this);\n          await plugin.connect();\n        } catch (error: unknown) {\n          // swallow error if connector adapter doesn't supports this plugin.\n          if ((error as Web3AuthError).code === 5211) {\n            return;\n          }\n          log.error(error);\n        }\n      });\n\n      this.emit(ADAPTER_EVENTS.CONNECTED, { ...data } as CONNECTED_EVENT_DATA);\n    });\n\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, async (data) => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n      if (storageAvailable(this.storage)) {\n        const cachedAdapter = window[this.storage].getItem(ADAPTER_CACHE_KEY);\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n      await Promise.all(\n        Object.values(this.plugins).map((plugin) => {\n          return plugin.disconnect().catch((error: Web3AuthError) => {\n            // swallow error if adapter doesn't supports this plugin.\n            if (error.code === 5211) {\n              return;\n            }\n            // throw error;\n            log.error(error);\n          });\n        })\n      );\n      this.connectedAdapterName = null;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, (data) => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, (data) => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, (data) => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n\n    walletAdapter.on(ADAPTER_EVENTS.CACHE_CLEAR, (data) => {\n      log.debug(\"adapter cache clear\", data);\n      if (storageAvailable(this.storage)) {\n        this.clearCache();\n      }\n    });\n  }\n\n  protected checkInitRequirements(): void {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  private cacheWallet(walletName: string) {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AA0EA,MAAMA,iBAAiB,GAAG,wBAAwB;AAC5C,MAAOC,eAAgB,SAAQC,gBAAgB;EAiBnDC,YAAYC,OAA+B;IAAA,IAAAC,oBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA;IACzC,KAAK,EAAE;IAACC,eAAA;IAAAA,eAAA,+BAfgD,IAAI;IAAAA,eAAA,iBAEzBC,cAAc,CAACC,SAAS;IAAAF,eAAA,wBAEvB,IAAI;IAAAA,eAAA,yBAEoB,EAAE;IAAAA,eAAA,6BAEN,IAAI;IAAAA,eAAA,kBAEnB,EAAE;IAAAA,eAAA,kBAEQ,cAAc;IAIjE,IAAI,CAACL,OAAO,CAACQ,QAAQ,EAAE,MAAMC,yBAAyB,CAACC,aAAa,CAAC,gDAAgD,CAAC;IACtH,IAAIV,OAAO,CAACW,aAAa,EAAEC,GAAG,CAACC,SAAS,EAAE,CAAC,KACtCD,GAAG,CAACE,QAAQ,CAAC,OAAO,CAAC;IAC1B,IAAI,GAAAb,oBAAA,GAACD,OAAO,CAACe,WAAW,cAAAd,oBAAA,eAAnBA,oBAAA,CAAqBe,cAAc,KAAI,CAACC,MAAM,CAACC,MAAM,CAACC,gBAAgB,CAAC,CAACC,QAAQ,EAAAlB,qBAAA,GAACF,OAAO,CAACe,WAAW,cAAAb,qBAAA,KAAnB,kBAAAA,qBAAA,CAAqBc,cAAc,CAAC,EACxH,MAAMP,yBAAyB,CAACC,aAAa,CAAC,sDAAsD,CAAC;IACvG,IAAIV,OAAO,CAACqB,UAAU,KAAK,SAAS,EAAE,IAAI,CAACC,OAAO,GAAG,gBAAgB;IACrE,IAAI,CAACC,aAAa,GAAGC,gBAAgB,CAAC,IAAI,CAACF,OAAO,CAAC,GAAGG,MAAM,CAAC,IAAI,CAACH,OAAO,CAAC,CAACI,OAAO,CAAC9B,iBAAiB,CAAC,GAAG,IAAI;IAE5G,IAAI,CAAC+B,WAAW,GAAAC,aAAA,CAAAA,aAAA,KACX5B,OAAO;MACVe,WAAW,EAAAa,aAAA,CAAAA,aAAA,KACLC,cAAc,EAAA1B,qBAAA,GAACH,OAAO,CAACe,WAAW,cAAAZ,qBAAA,uBAAnBA,qBAAA,CAAqBa,cAAc,GAAAZ,qBAAA,GAAEJ,OAAO,CAACe,WAAW,cAAAX,qBAAA,KAAnB,kBAAAA,qBAAA,CAAqB0B,OAAO,CAAC,IAAI,EAAE,CACxF,EAAA9B,OAAO,CAACe,WAAW;KAEzB;IACD,IAAI,CAACgB,wBAAwB,GAAG,IAAI,CAACA,wBAAwB,CAACC,IAAI,CAAC,IAAI,CAAC;EAC1E;EAEA,IAAIC,SAASA,CAAA;IACX,OAAOC,OAAO,CAAC,IAAI,CAACC,oBAAoB,CAAC;EAC3C;EAEA,IAAIC,QAAQA,CAAA;IACV,IAAI,IAAI,CAACC,MAAM,KAAK/B,cAAc,CAACC,SAAS,IAAI,IAAI,CAAC+B,kBAAkB,EAAE;MACvE,OAAO,IAAI,CAACA,kBAAkB,CAACF,QAAQ;IACxC;IACD,OAAO,IAAI;EACb;EAEA,IAAIA,QAAQA,CAACG,CAAkC;IAC7C,MAAM,IAAIC,KAAK,CAAC,iBAAiB,CAAC;EACpC;EAEO,MAAMC,IAAIA,CAAA;IACf,IAAI,CAACH,kBAAkB,GAAG,MAAMI,kBAAkB,CAACC,mBAAmB,CAAC;MAAE5B,WAAW,EAAE,IAAI,CAACY,WAAW,CAACZ;IAAgC,CAAE,CAAC;IAC1I,MAAM6B,YAAY,GAAG3B,MAAM,CAAC4B,IAAI,CAAC,IAAI,CAACC,cAAc,CAAC,CAACC,GAAG,CAAEC,WAAW,IAAI;MACxE,IAAI,CAACjB,wBAAwB,CAAC,IAAI,CAACe,cAAc,CAACE,WAAW,CAAC,CAAC;MAC/D;MACA;MACA,IAAI,CAAC,IAAI,CAACF,cAAc,CAACE,WAAW,CAAC,CAACC,gBAAgB,EAAE;QACtD,MAAMC,mBAAmB,GAAG,IAAI,CAACvB,WAAW,CAACZ,WAAW;QACxD,IAAI,CAACmC,mBAAmB,CAAClC,cAAc,EAAE,MAAMP,yBAAyB,CAACC,aAAa,CAAC,8CAA8C,CAAC;QACtI,IAAI,CAACoC,cAAc,CAACE,WAAW,CAAC,CAACG,kBAAkB,CAAC;UAClDpC,WAAW,EAAEmC,mBAAmB;UAChCE,WAAW,EAAE,IAAI,CAACzB,WAAW,CAACyB,WAAW;UACzC5C,QAAQ,EAAE,IAAI,CAACmB,WAAW,CAACnB,QAAQ;UACnC6C,eAAe,EAAE,IAAI,CAAC1B,WAAW,CAAC0B,eAAe;UACjDC,aAAa,EAAE,IAAI,CAAC3B,WAAW,CAAC2B;QACjC,EAAC;MACH,OAAM;QACL,IAAI,CAACR,cAAc,CAACE,WAAW,CAAC,CAACG,kBAAkB,CAAC;UAClDC,WAAW,EAAE,IAAI,CAACzB,WAAW,CAACyB,WAAW;UACzC5C,QAAQ,EAAE,IAAI,CAACmB,WAAW,CAACnB,QAAQ;UACnC6C,eAAe,EAAE,IAAI,CAAC1B,WAAW,CAAC0B,eAAe;UACjDC,aAAa,EAAE,IAAI,CAAC3B,WAAW,CAAC2B;QACjC,EAAC;MACH;MAED,OAAO,IAAI,CAACR,cAAc,CAACE,WAAW,CAAC,CAACP,IAAI,CAAC;QAAEc,WAAW,EAAE,IAAI,CAAChC,aAAa,KAAKyB;MAAa,EAAC,CAACQ,KAAK,CAAEC,CAAC,IAAK7C,GAAG,CAAC8C,KAAK,CAACD,CAAC,CAAC,CAAC;IAC9H,CAAC,CAAC;IACF,IAAI,CAACpB,MAAM,GAAG/B,cAAc,CAACqD,KAAK;IAClC,MAAMC,OAAO,CAACC,GAAG,CAACjB,YAAY,CAAC;EACjC;EAEOkB,gBAAgBA,CAACC,OAA0B;IAChD,IAAI,CAACC,qBAAqB,EAAE;IAC5B,MAAMd,mBAAmB,GAAG,IAAI,CAACvB,WAAW,CAACZ,WAAW;IAExD,IAAI,CAACmC,mBAAmB,CAAClC,cAAc,EAAE,MAAMP,yBAAyB,CAACC,aAAa,CAAC,8CAA8C,CAAC;IAEtI,MAAMuD,oBAAoB,GAAG,IAAI,CAACnB,cAAc,CAACiB,OAAO,CAACG,IAAI,CAAC;IAC9D,IAAID,oBAAoB,EAAE,MAAMxD,yBAAyB,CAAC0D,qBAAqB,CAAC,sBAAsBJ,OAAO,CAACG,IAAqB,kBAAC;IACpI,IAAIH,OAAO,CAACK,gBAAgB,KAAKC,kBAAkB,CAACC,UAAU,IAAIP,OAAO,CAACK,gBAAgB,KAAKlB,mBAAmB,CAAClC,cAAc,EAC/H,MAAMP,yBAAyB,CAAC8D,0BAA0B,CACtB,kCAAAR,OAAO,CAACK,gBAAyE,yDAAAlB,mBAAmB,CAAClC,cAAc,EAAE,CACxJ;IAEH,IAAI+C,OAAO,CAACG,IAAI,KAAKM,eAAe,CAACC,iBAAiB,IAAI,IAAI,CAAC3B,cAAc,CAAC0B,eAAe,CAACE,iBAAiB,CAAC,EAAE;MAChH,MAAMjE,yBAAyB,CAACC,aAAa,CAC3C,wHAAwH,CACzH;IACF;IACD,IAAIqD,OAAO,CAACG,IAAI,KAAKM,eAAe,CAACE,iBAAiB,IAAI,IAAI,CAAC5B,cAAc,CAAC0B,eAAe,CAACC,iBAAiB,CAAC,EAAE;MAChH,MAAMhE,yBAAyB,CAACC,aAAa,CAC3C,wHAAwH,CACzH;IACF;IAED,IACEqD,OAAO,CAACK,gBAAgB,KAAKC,kBAAkB,CAACC,UAAU,IAC1DP,OAAO,CAACY,qBAAqB,IAC7BzB,mBAAmB,CAAClC,cAAc,KAAK+C,OAAO,CAACY,qBAAqB,EACpE;MACA;MACAZ,OAAO,CAACZ,kBAAkB,CAAC;QAAEpC,WAAW,EAAEmC;MAA0C,EAAC;IACtF;IAED,IAAI,CAACJ,cAAc,CAACiB,OAAO,CAACG,IAAI,CAAC,GAAGH,OAAO;IAC3C,OAAO,IAAI;EACb;EAEOa,UAAUA,CAAA;IACf,IAAI,CAACpD,gBAAgB,CAAC,IAAI,CAACF,OAAO,CAAC,EAAE;IACrCG,MAAM,CAAC,IAAI,CAACH,OAAO,CAAC,CAACuD,UAAU,CAACjF,iBAAiB,CAAC;IAClD,IAAI,CAAC2B,aAAa,GAAG,IAAI;EAC3B;EAEO,MAAMuD,QAAQA,CAAC/D,WAA8B;IAClD,IAAI,IAAI,CAACsB,MAAM,KAAK/B,cAAc,CAACyE,SAAS,IAAI,IAAI,CAAC5C,oBAAoB,EACvE,OAAO,IAAI,CAACW,cAAc,CAAC,IAAI,CAACX,oBAAoB,CAAC,CAAC2C,QAAQ,CAAC/D,WAAW,CAAC;IAE7E,IAAI,IAAI,CAACuB,kBAAkB,EAAE;MAC3B,OAAO,IAAI,CAACA,kBAAkB,CAACwC,QAAQ,CAAC/D,WAAW,CAAC;IACrD;IACD,MAAMN,yBAAyB,CAACuE,QAAQ,CAAC,oBAAoB,CAAC;EAChE;EAEO,MAAMC,WAAWA,CAACC,MAA2B;IAClD,IAAI,IAAI,CAAC7C,MAAM,KAAK/B,cAAc,CAACyE,SAAS,IAAI,IAAI,CAAC5C,oBAAoB,EACvE,OAAO,IAAI,CAACW,cAAc,CAAC,IAAI,CAACX,oBAAoB,CAAC,CAAC8C,WAAW,CAACC,MAAM,CAAC;IAE3E,IAAI,IAAI,CAAC5C,kBAAkB,EAAE;MAC3B,OAAO,IAAI,CAACA,kBAAkB,CAAC2C,WAAW,CAACC,MAAM,CAAC;IACnD;IACD,MAAMzE,yBAAyB,CAACuE,QAAQ,CAAC,oBAAoB,CAAC;EAChE;EAEA;;;AAGG;EACH,MAAMG,SAASA,CAAIC,UAA+B,EAAEC,WAAe;IACjE,IAAI,CAAC,IAAI,CAACvC,cAAc,CAACsC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC9C,kBAAkB,EAC9D,MAAM7B,yBAAyB,CAAC6E,QAAQ,kCAAkCF,UAAU,4BAA4B,CAAC;IACnH,MAAMhD,QAAQ,GAAG,MAAM,IAAI,CAACU,cAAc,CAACsC,UAAU,CAAC,CAACG,OAAO,CAACF,WAAW,CAAC;IAC3E,IAAI,CAAC/C,kBAAkB,CAACkD,yBAAyB,CAACpD,QAAoC,CAAC;IACvF,OAAO,IAAI,CAACA,QAAQ;EACtB;EAEA,MAAMqD,MAAMA,CAAA,EAAmD;IAAA,IAAlDzF,OAAA,GAAA0F,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,CAAgC;MAAEG,OAAO,EAAE;KAAO;IAC7D,IAAI,IAAI,CAACxD,MAAM,KAAK/B,cAAc,CAACyE,SAAS,IAAI,CAAC,IAAI,CAAC5C,oBAAoB,EAAE,MAAM2D,gBAAgB,CAACC,iBAAiB,CAAC,wBAAwB,CAAC;IAC9I,MAAM,IAAI,CAACjD,cAAc,CAAC,IAAI,CAACX,oBAAoB,CAAC,CAAC6D,UAAU,CAAChG,OAAO,CAAC;EAC1E;EAEA,MAAMiG,WAAWA,CAAA;IACfrF,GAAG,CAACsF,KAAK,CAAC,mBAAmB,EAAE,IAAI,CAAC7D,MAAM,EAAE,IAAI,CAACF,oBAAoB,CAAC;IACtE,IAAI,IAAI,CAACE,MAAM,KAAK/B,cAAc,CAACyE,SAAS,IAAI,CAAC,IAAI,CAAC5C,oBAAoB,EAAE,MAAM2D,gBAAgB,CAACC,iBAAiB,CAAC,wBAAwB,CAAC;IAC9I,OAAO,IAAI,CAACjD,cAAc,CAAC,IAAI,CAACX,oBAAoB,CAAC,CAAC8D,WAAW,EAAE;EACrE;EAEA,MAAME,gBAAgBA,CAAA;IACpB,IAAI,IAAI,CAAC9D,MAAM,KAAK/B,cAAc,CAACyE,SAAS,IAAI,CAAC,IAAI,CAAC5C,oBAAoB,EAAE,MAAM2D,gBAAgB,CAACC,iBAAiB,CAAC,wBAAwB,CAAC;IAC9I,OAAO,IAAI,CAACjD,cAAc,CAAC,IAAI,CAACX,oBAAoB,CAAC,CAACgE,gBAAgB,EAAE;EAC1E;EAEO,MAAMC,SAASA,CAACC,MAAe;IACpC,IAAI,IAAI,CAACC,OAAO,CAACD,MAAM,CAACnC,IAAI,CAAC,EAAE,MAAM,IAAI1B,KAAK,CAAC,UAAU6D,MAAM,CAACnC,IAAoB,iBAAC;IACrF,IAAImC,MAAM,CAACE,eAAe,KAAKC,iBAAiB,CAAClC,UAAU,IAAI+B,MAAM,CAACE,eAAe,KAAK,IAAI,CAAC5E,WAAW,CAACZ,WAAW,CAACC,cAAc,EACnI,MAAM,IAAIwB,KAAK,CACa,0BAAA6D,MAAM,CAACE,eAAkF,uEAAI,CAAC5E,WAAW,CAACZ,WAAW,CAACC,cAAc,EAAE,CACjK;IAEH,IAAI,CAACsF,OAAO,CAACD,MAAM,CAACnC,IAAI,CAAC,GAAGmC,MAAM;IAClC,OAAO,IAAI;EACb;EAEUtE,wBAAwBA,CAAC0E,aAAgC;IACjEA,aAAa,CAACC,EAAE,CAACC,cAAc,CAAC5B,SAAS,EAAE,MAAO6B,IAA0B,IAAI;MAC9E,IAAI,CAAC,IAAI,CAACtE,kBAAkB,EAAE,MAAM7B,yBAAyB,CAAC6E,QAAQ,CAAC,8BAA8B,CAAC;MACtG,MAAM;QAAElD;OAAU,GAAG,IAAI,CAACU,cAAc,CAAC8D,IAAI,CAAC7C,OAAO,CAAC;MACtD,IAAI,CAACzB,kBAAkB,CAACkD,yBAAyB,CAACpD,QAAoC,CAAC;MACvF,IAAI,CAACC,MAAM,GAAG/B,cAAc,CAACyE,SAAS;MACtC,IAAI,CAAC5C,oBAAoB,GAAGyE,IAAI,CAAC7C,OAAO;MACxC,IAAI,CAAC8C,WAAW,CAACD,IAAI,CAAC7C,OAAO,CAAC;MAC9BnD,GAAG,CAACsF,KAAK,CAAC,WAAW,EAAE,IAAI,CAAC7D,MAAM,EAAE,IAAI,CAACF,oBAAoB,CAAC;MAE9DlB,MAAM,CAACC,MAAM,CAAC,IAAI,CAACoF,OAAO,CAAC,CAACvD,GAAG,CAAC,MAAOsD,MAAM,IAAI;QAC/C,IAAI;UACF,IAAI,CAACA,MAAM,CAACS,kBAAkB,CAAC1F,QAAQ,CAACwF,IAAI,CAAC7C,OAAO,CAAC,EAAE;YACrD;UACD;UACD,MAAMsC,MAAM,CAACU,gBAAgB,CAAC,IAAI,CAAC;UACnC,MAAMV,MAAM,CAACd,OAAO,EAAE;SACvB,CAAC,OAAO7B,KAAc,EAAE;UACvB;UACA,IAAKA,KAAuB,CAACsD,IAAI,KAAK,IAAI,EAAE;YAC1C;UACD;UACDpG,GAAG,CAAC8C,KAAK,CAACA,KAAK,CAAC;QACjB;MACH,CAAC,CAAC;MAEF,IAAI,CAACuD,IAAI,CAACN,cAAc,CAAC5B,SAAS,EAAAnD,aAAA,KAAOgF,IAAI,CAA0B,CAAC;IAC1E,CAAC,CAAC;IAEFH,aAAa,CAACC,EAAE,CAACC,cAAc,CAACO,YAAY,EAAE,MAAON,IAAI,IAAI;MAC3D;MACA,IAAI,CAACvE,MAAM,GAAG/B,cAAc,CAACqD,KAAK;MAClC,IAAInC,gBAAgB,CAAC,IAAI,CAACF,OAAO,CAAC,EAAE;QAClC,MAAMC,aAAa,GAAGE,MAAM,CAAC,IAAI,CAACH,OAAO,CAAC,CAACI,OAAO,CAAC9B,iBAAiB,CAAC;QACrE,IAAI,IAAI,CAACuC,oBAAoB,KAAKZ,aAAa,EAAE;UAC/C,IAAI,CAACqD,UAAU,EAAE;QAClB;MACF;MAEDhE,GAAG,CAACsF,KAAK,CAAC,cAAc,EAAE,IAAI,CAAC7D,MAAM,EAAE,IAAI,CAACF,oBAAoB,CAAC;MACjE,MAAMyB,OAAO,CAACC,GAAG,CACf5C,MAAM,CAACC,MAAM,CAAC,IAAI,CAACoF,OAAO,CAAC,CAACvD,GAAG,CAAEsD,MAAM,IAAI;QACzC,OAAOA,MAAM,CAACL,UAAU,EAAE,CAACxC,KAAK,CAAEE,KAAoB,IAAI;UACxD;UACA,IAAIA,KAAK,CAACsD,IAAI,KAAK,IAAI,EAAE;YACvB;UACD;UACD;UACApG,GAAG,CAAC8C,KAAK,CAACA,KAAK,CAAC;QAClB,CAAC,CAAC;MACJ,CAAC,CAAC,CACH;MACD,IAAI,CAACvB,oBAAoB,GAAG,IAAI;MAChC,IAAI,CAAC8E,IAAI,CAACN,cAAc,CAACO,YAAY,EAAEN,IAAI,CAAC;IAC9C,CAAC,CAAC;IACFH,aAAa,CAACC,EAAE,CAACC,cAAc,CAACQ,UAAU,EAAGP,IAAI,IAAI;MACnD,IAAI,CAACvE,MAAM,GAAG/B,cAAc,CAAC6G,UAAU;MACvC,IAAI,CAACF,IAAI,CAACN,cAAc,CAACQ,UAAU,EAAEP,IAAI,CAAC;MAC1ChG,GAAG,CAACsF,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC7D,MAAM,EAAE,IAAI,CAACF,oBAAoB,CAAC;IACjE,CAAC,CAAC;IACFsE,aAAa,CAACC,EAAE,CAACC,cAAc,CAACS,OAAO,EAAGR,IAAI,IAAI;MAChD,IAAI,CAACvE,MAAM,GAAG/B,cAAc,CAAC8G,OAAO;MACpC,IAAI,CAACxC,UAAU,EAAE;MACjB,IAAI,CAACqC,IAAI,CAACN,cAAc,CAACS,OAAO,EAAER,IAAI,CAAC;MACvChG,GAAG,CAACsF,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC7D,MAAM,EAAE,IAAI,CAACF,oBAAoB,CAAC;IAC9D,CAAC,CAAC;IAEFsE,aAAa,CAACC,EAAE,CAACC,cAAc,CAACU,oBAAoB,EAAGT,IAAI,IAAI;MAC7DhG,GAAG,CAACsF,KAAK,CAAC,sBAAsB,EAAEU,IAAI,CAAC;MACvC,IAAI,CAACK,IAAI,CAACN,cAAc,CAACU,oBAAoB,EAAET,IAAI,CAAC;IACtD,CAAC,CAAC;IAEFH,aAAa,CAACC,EAAE,CAACC,cAAc,CAACW,WAAW,EAAGV,IAAI,IAAI;MACpDhG,GAAG,CAACsF,KAAK,CAAC,qBAAqB,EAAEU,IAAI,CAAC;MACtC,IAAIpF,gBAAgB,CAAC,IAAI,CAACF,OAAO,CAAC,EAAE;QAClC,IAAI,CAACsD,UAAU,EAAE;MAClB;IACH,CAAC,CAAC;EACJ;EAEUZ,qBAAqBA,CAAA;IAC7B,IAAI,IAAI,CAAC3B,MAAM,KAAK/B,cAAc,CAAC6G,UAAU,EAAE,MAAM1G,yBAAyB,CAACuE,QAAQ,CAAC,4BAA4B,CAAC;IACrH,IAAI,IAAI,CAAC3C,MAAM,KAAK/B,cAAc,CAACyE,SAAS,EAAE,MAAMtE,yBAAyB,CAACuE,QAAQ,CAAC,mBAAmB,CAAC;IAC3G,IAAI,IAAI,CAAC3C,MAAM,KAAK/B,cAAc,CAACqD,KAAK,EAAE,MAAMlD,yBAAyB,CAACuE,QAAQ,CAAC,gCAAgC,CAAC;EACtH;EAEQ6B,WAAWA,CAACzB,UAAkB;IACpC,IAAI,CAAC5D,gBAAgB,CAAC,IAAI,CAACF,OAAO,CAAC,EAAE;IACrCG,MAAM,CAAC,IAAI,CAACH,OAAO,CAAC,CAACiG,OAAO,CAAC3H,iBAAiB,EAAEwF,UAAU,CAAC;IAC3D,IAAI,CAAC7D,aAAa,GAAG6D,UAAU;EACjC;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}