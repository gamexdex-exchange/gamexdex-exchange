{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine, providerFromEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, WalletLoginError, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { createFetchMiddleware } from '@toruslabs/base-controllers';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { PublicKey, Connection, VersionedTransaction, Keypair } from '@solana/web3.js';\nimport { getED25519Key } from '@toruslabs/openlogin-ed25519';\nimport nacl from '@toruslabs/tweetnacl-js';\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createConfigMiddleware(providerConfig) {\n  const {\n    chainId\n  } = providerConfig;\n  return mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig)]);\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\");\n    // This calls from the prefs controller\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\");\n    // This calls the UI login function\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(`WalletMiddleware - ${targetMethod} not provided`);\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey,\n    getSecretKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey), createGenericJRPCMiddleware(\"private_key\", getPrivateKey), createGenericJRPCMiddleware(\"solanaSecretKey\", getSecretKey)]);\n}\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass BaseInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$3(_objectSpread$3({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n  async switchChain(_) {\n    throw WalletLoginError.unsupportedOperation(\"Chain switching is not supported by this adapter\");\n  }\n  async setupProvider(injectedProvider) {\n    const engine = new JRPCEngine();\n    const providerHandlers = this.getProviderHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    engine.push(solanaMiddleware);\n    const configMiddleware = createConfigMiddleware(this.config.chainConfig);\n    engine.push(configMiddleware);\n    const injectedProviderProxy = this.getInjectedProviderProxy(injectedProvider);\n    if (injectedProviderProxy) {\n      engine.push(injectedProviderProxy);\n    }\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n  async lookupNetwork() {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\";\n  }\n  getInjectedProviderProxy(_) {\n    return undefined;\n  }\n}\nconst getBaseProviderHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const transaction = await injectedProvider.signTransaction(req.params.message);\n      return transaction;\n    },\n    signMessage: async req => {\n      const sigData = await injectedProvider.signMessage(req.params.message, req.params.display);\n      return sigData.signature;\n    },\n    signAllTransactions: async req => {\n      var _req$params, _req$params2;\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const transaction = await injectedProvider.signAllTransactions(req.params.message);\n      return transaction;\n    },\n    signAndSendTransaction: async req => {\n      const txRes = await injectedProvider.signAndSendTransaction(req.params.message);\n      return {\n        signature: txRes.signature\n      };\n    }\n  };\n  return providerHandlers;\n};\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$2({}, req));\n    res.result = result;\n  });\n}\nclass PhantomInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getBaseProviderHandlers(injectedProvider);\n  }\n  getInjectedProviderProxy(injectedProvider) {\n    return createInjectedProviderProxyMiddleware(injectedProvider);\n  }\n}\nconst isVersionTransction = transaction => transaction.version !== undefined || transaction instanceof VersionedTransaction;\nconst getSlopeHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const {\n        data\n      } = await injectedProvider.connect();\n      return [data.publicKey];\n    },\n    getAccounts: async () => {\n      const {\n        data\n      } = await injectedProvider.connect();\n      return [data.publicKey];\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const txMessage = req.params.message;\n      if (!txMessage) throw ethErrors.rpc.invalidRequest({\n        message: \"Invalid transaction message\"\n      });\n      const message = isVersionTransction(txMessage) ? txMessage.message.serialize() : txMessage.serializeMessage();\n      const {\n        data\n      } = await injectedProvider.signTransaction(bs58.encode(message));\n      if (!data.publicKey || !data.signature) throw new Error(\"Invalid signature from slope wallet\");\n      const publicKey = new PublicKey(data.publicKey);\n      const signature = bs58.decode(data.signature);\n      txMessage.addSignature(publicKey, Buffer.from(signature));\n      return txMessage;\n    },\n    signMessage: async req => {\n      const response = await injectedProvider.signMessage(req.params.message);\n      return bs58.decode(response.data.signature);\n    },\n    signAndSendTransaction: async req => {\n      const provider = getProviderEngineProxy();\n      if (!provider) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const txMessage = req.params.message;\n      if (!txMessage) throw ethErrors.rpc.invalidRequest({\n        message: \"Invalid transaction message\"\n      });\n      const message = isVersionTransction(txMessage) ? txMessage.message.serialize() : txMessage.serializeMessage();\n      const {\n        data\n      } = await injectedProvider.signTransaction(bs58.encode(message));\n      if (!data.publicKey || !data.signature) throw new Error(\"Invalid signature from slope wallet\");\n      const publicKey = new PublicKey(data.publicKey);\n      const signature = bs58.decode(data.signature);\n      txMessage.addSignature(publicKey, Buffer.from(signature));\n      const chainConfig = await provider.request({\n        method: \"solana_provider_config\",\n        params: []\n      });\n      const conn = new Connection(chainConfig.rpcTarget);\n      const res = await conn.sendRawTransaction(txMessage.serialize());\n      return {\n        signature: res\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params, _req$params2, _data$signatures;\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const allTxns = req.params.message;\n      const {\n        length\n      } = allTxns;\n      const unsignedTx = [];\n      for (let i = 0; i < length; i++) {\n        const item = allTxns[i];\n        const message = isVersionTransction(item) ? item.message.serialize() : item.serializeMessage();\n        unsignedTx.push(bs58.encode(message));\n      }\n      const {\n        msg,\n        data\n      } = await injectedProvider.signAllTransactions(unsignedTx);\n      if (!data.publicKey || ((_data$signatures = data.signatures) === null || _data$signatures === void 0 ? void 0 : _data$signatures.length) !== length) throw new Error(msg);\n      const publicKey = new PublicKey(data.publicKey);\n      for (let i = 0; i < length; i++) {\n        const signature = bs58.decode(data.signatures[i]);\n        allTxns[i].addSignature(publicKey, Buffer.from(signature));\n      }\n      return allTxns;\n    }\n  };\n  return providerHandlers;\n};\nclass SlopeInjectedProxyProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSlopeHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n}\nconst getSolflareHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const solflareProviderHandlers = getBaseProviderHandlers(injectedProvider);\n  solflareProviderHandlers.signAndSendTransaction = async req => {\n    const provider = getProviderEngineProxy();\n    if (!provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const transaction = await injectedProvider.signTransaction(req.params.message);\n    const chainConfig = await provider.request({\n      method: \"solana_provider_config\",\n      params: []\n    });\n    const conn = new Connection(chainConfig.rpcTarget);\n    const res = await conn.sendRawTransaction(transaction.serialize());\n    return {\n      signature: res\n    };\n  };\n  solflareProviderHandlers.signMessage = async req => {\n    const sigData = await injectedProvider.signMessage(req.params.message, req.params.display);\n    return sigData;\n  };\n  return solflareProviderHandlers;\n};\nclass SolflareInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSolflareHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n}\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const message = await injectedProvider.signMessage(req.params.message);\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const txMessage = req.params.message;\n      const response = await injectedProvider.signTransaction(txMessage);\n      return response;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const txMessage = req.params.message;\n      const response = await injectedProvider.sendTransaction(txMessage);\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const transactions = req.params.message;\n      const response = await injectedProvider.signAllTransactions(transactions);\n      return response;\n    }\n  };\n  return providerHandlers;\n};\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n  async switchChain(params) {\n    // overrides the base provider implementation\n    await this.provider.request({\n      method: \"switchSolanaChain\",\n      params: [{\n        chainId: params.chainId\n      }]\n    });\n  }\n  async addChain(chainConfig) {\n    super.addChain(chainConfig);\n    await this.provider.request({\n      method: \"addNewChainConfig\",\n      params: [{\n        chainId: chainConfig.chainId,\n        chainName: chainConfig.displayName,\n        rpcUrls: [chainConfig.rpcTarget],\n        blockExplorerUrls: [chainConfig.blockExplorer],\n        nativeCurrency: {\n          name: chainConfig.tickerName,\n          symbol: chainConfig.ticker,\n          decimals: chainConfig.decimals || 18\n        }\n      }]\n    });\n  }\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : `0x${parseInt(connectedChainId, 10).toString(16)}`;\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(`Invalid network, net_version is: ${connectedHexChainId}, expected: ${chainId}`);\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : `0x${parseInt(chainId, 10).toString(16)}`;\n      // Check if chainId changed and trigger event\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n}\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    getSecretKey: async () => bs58.encode(keyPair.secretKey),\n    signTransaction: async req => {\n      var _req$params;\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const transaction = req.params.message;\n      if (transaction.version !== undefined || transaction instanceof VersionedTransaction) {\n        transaction.sign([keyPair]);\n      } else {\n        transaction.partialSign(keyPair);\n      }\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params2;\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const _providerEngineProxy = getProviderEngineProxy();\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = req.params.message;\n      if (transaction.version !== undefined || transaction instanceof VersionedTransaction) {\n        transaction.sign([keyPair]);\n      } else {\n        transaction.partialSign(keyPair);\n      }\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [Buffer.from(transaction.serialize()).toString(\"base64\"), {\n          encoding: \"base64\",\n          preflightCommitment: \"confirmed\"\n        }]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5, _req$params6;\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const txns = (_req$params6 = req.params) === null || _req$params6 === void 0 ? void 0 : _req$params6.message;\n      for (const tx of txns || []) {\n        const transaction = tx;\n        if (transaction.version !== undefined || transaction instanceof VersionedTransaction) {\n          transaction.sign([keyPair]);\n        } else {\n          transaction.partialSign(keyPair);\n        }\n      }\n      return txns;\n    }\n  };\n  return providerHandlers;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n  getEd25519Key(privateKey) {\n    return getED25519Key(privateKey).sk.toString(\"hex\").padStart(128, \"0\");\n  }\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(`Failed to lookup network for following rpc target: ${chainConfig.rpcTarget}`);\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n    return this.state.chainId;\n  }\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\",\n          decimals: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.decimals) || 9\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n}\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n    this.provider = provider;\n  }\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: transaction\n      }\n    });\n    return {\n      signature\n    };\n  }\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: transaction\n      }\n    });\n    return signedTransaction;\n  }\n  async signAllTransactions(transactions) {\n    const signedTransactions = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: transactions\n      }\n    });\n    return signedTransactions;\n  }\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n}\nexport { PhantomInjectedProvider, SlopeInjectedProxyProvider, SolanaPrivateKeyProvider, SolanaWallet, SolflareInjectedProvider, TorusInjectedProvider };","map":{"version":3,"names":["createChainIdMiddleware","chainId","req","res","next","end","method","result","createProviderConfigMiddleware","providerConfig","createConfigMiddleware","mergeMiddleware","createJsonRpcClient","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","createGetAccountsMiddleware","_ref","getAccounts","createAsyncMiddleware","request","response","Error","accounts","undefined","createRequestAccountsMiddleware","_ref2","requestAccounts","createGenericJRPCMiddleware","targetMethod","handler","createSolanaMiddleware","providerHandlers","signTransaction","signAndSendTransaction","signAllTransactions","signMessage","getPrivateKey","getSecretKey","createChainSwitchMiddleware","_ref3","addNewChainConfig","switchSolanaChain","createAccountMiddleware","_ref4","updatePrivatekey","BaseInjectedProvider","BaseProvider","constructor","config","state","chainConfig","_objectSpread$3","chainNamespace","CHAIN_NAMESPACES","SOLANA","switchChain","_","WalletLoginError","unsupportedOperation","setupProvider","injectedProvider","engine","JRPCEngine","getProviderHandlers","solanaMiddleware","push","configMiddleware","injectedProviderProxy","getInjectedProviderProxy","provider","providerFromEngine","updateProviderEngineProxy","lookupNetwork","update","getBaseProviderHandlers","publicKey","bs58","encode","toBytes","ethErrors","rpc","methodNotSupported","transaction","params","message","sigData","display","signature","_req$params","_req$params2","length","invalidParams","txRes","createInjectedProviderProxyMiddleware","_next","_objectSpread$2","PhantomInjectedProvider","isVersionTransction","version","VersionedTransaction","getSlopeHandlers","getProviderEngineProxy","data","connect","txMessage","invalidRequest","serialize","serializeMessage","PublicKey","decode","addSignature","Buffer","from","custom","code","conn","Connection","sendRawTransaction","_data$signatures","allTxns","unsignedTx","i","item","msg","signatures","SlopeInjectedProxyProvider","bind","getSolflareHandlers","solflareProviderHandlers","SolflareInjectedProvider","getTorusHandlers","_req$params3","sendTransaction","_req$params4","_req$params5","transactions","TorusInjectedProvider","_objectSpread$1","addChain","chainName","displayName","rpcUrls","blockExplorerUrls","blockExplorer","nativeCurrency","name","tickerName","symbol","ticker","decimals","handleInjectedProviderUpdate","setupEngine","connectedChainId","connectedHexChainId","isHexStrict","toString","parseInt","WalletInitializationError","rpcConnectionError","emit","on","configure","privKey","keyPairGenerator","Keypair","fromSecretKey","keyPair","toBase58","secretKey","sign","partialSign","signedMsg","nacl","detached","_providerEngineProxy","sig","encoding","preflightCommitment","_req$params6","txns","tx","SolanaPrivateKeyProvider","_objectSpread","enable","privateKey","getEd25519Key","getED25519Key","sk","padStart","getChainSwitchMiddleware","getAccountMiddleware","updateAccount","existingKey","getChainConfig","health","chainSwitchHandlers","chainSwitchMiddleware","accountHandlers","providerFactory","SolanaWallet","_defineProperty","signedTransaction","signedTransactions","args"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/rpc/JrpcClient.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/rpc/solanaRpcMiddlewares.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/injectedProviders/base/baseInjectedProvider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/injectedProviders/base/providerHandlers.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/injectedProviders/injectedProviderProxy.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/injectedProviders/phantom/phantomInjectedProvider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/injectedProviders/slope/providerHandlers.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/injectedProviders/slope/slopeInjectedProvider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/injectedProviders/solflare/providerHandlers.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/injectedProviders/solflare/solflareInjectedProvider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/injectedProviders/torus/providerHandlers.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/injectedProviders/torus/torusInjectedProvider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/privateKeyProvider/solanaPrivateKeyUtils.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/providers/privateKeyProvider/solanaPrivateKeyProvider.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/solana-provider/src/solanaWallet.ts"],"sourcesContent":["import { createFetchMiddleware } from \"@toruslabs/base-controllers\";\nimport { JRPCEngineEndCallback, JRPCEngineNextCallback, JRPCMiddleware, JRPCRequest, JRPCResponse, mergeMiddleware } from \"@toruslabs/openlogin-jrpc\";\nimport { CustomChainConfig } from \"@web3auth/base\";\n\nexport function createChainIdMiddleware(chainId: string): JRPCMiddleware<unknown, unknown> {\n  return (req: JRPCRequest<unknown>, res: JRPCResponse<string>, next: JRPCEngineNextCallback, end: JRPCEngineEndCallback) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n    return next();\n  };\n}\n\nexport function createProviderConfigMiddleware(providerConfig: Omit<CustomChainConfig, \"chainNamespace\">): JRPCMiddleware<unknown, unknown> {\n  return (\n    req: JRPCRequest<unknown>,\n    res: JRPCResponse<Omit<CustomChainConfig, \"chainNamespace\">>,\n    next: JRPCEngineNextCallback,\n    end: JRPCEngineEndCallback\n  ) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n    return next();\n  };\n}\n\nexport function createConfigMiddleware(providerConfig: Omit<CustomChainConfig, \"chainNamespace\">): JRPCMiddleware<unknown, unknown> {\n  const { chainId } = providerConfig;\n\n  return mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig)]);\n}\n\nexport function createJsonRpcClient(providerConfig: Omit<CustomChainConfig, \"chainNamespace\">): {\n  networkMiddleware: JRPCMiddleware<unknown, unknown>;\n  fetchMiddleware: JRPCMiddleware<unknown, unknown>;\n} {\n  const { rpcTarget } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({ rpcTarget });\n  const networkMiddleware = mergeMiddleware([createConfigMiddleware(providerConfig), fetchMiddleware]);\n  return { networkMiddleware, fetchMiddleware };\n}\n","import { createAsyncMiddleware, JRPCMiddleware, JRPCRequest, mergeMiddleware } from \"@toruslabs/openlogin-jrpc\";\n\nimport { TransactionOrVersionedTransaction } from \"../interface\";\n\nexport interface IProviderHandlers {\n  requestAccounts: (req: JRPCRequest<unknown>) => Promise<string[]>;\n  getAccounts: (req: JRPCRequest<unknown>) => Promise<string[]>;\n  getPrivateKey: (req: JRPCRequest<unknown>) => Promise<string>;\n  signTransaction: (req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>) => Promise<TransactionOrVersionedTransaction>;\n  signAllTransactions: (req: JRPCRequest<{ message: TransactionOrVersionedTransaction[] }>) => Promise<TransactionOrVersionedTransaction[]>;\n  signAndSendTransaction: (req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>) => Promise<{ signature: string }>;\n  getSecretKey: (req: JRPCRequest<unknown>) => Promise<string>;\n  signMessage: (req: JRPCRequest<{ message: Uint8Array; display?: string }>) => Promise<Uint8Array>;\n}\n\nexport function createGetAccountsMiddleware({ getAccounts }: { getAccounts: IProviderHandlers[\"getAccounts\"] }): JRPCMiddleware<unknown, unknown> {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const { method } = request;\n    if (method !== \"getAccounts\") return next();\n\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\");\n    // This calls from the prefs controller\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\n\nexport function createRequestAccountsMiddleware({\n  requestAccounts,\n}: {\n  requestAccounts: IProviderHandlers[\"requestAccounts\"];\n}): JRPCMiddleware<unknown, unknown> {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const { method } = request;\n    if (method !== \"requestAccounts\") return next();\n\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\");\n    // This calls the UI login function\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\n\nexport function createGenericJRPCMiddleware<T, U>(\n  targetMethod: string,\n  handler: (req: JRPCRequest<T>) => Promise<U>\n): JRPCMiddleware<unknown, unknown> {\n  return createAsyncMiddleware<T, unknown>(async (request, response, next) => {\n    const { method } = request;\n    if (method !== targetMethod) return next();\n\n    if (!handler) throw new Error(`WalletMiddleware - ${targetMethod} not provided`);\n\n    const result = await handler(request);\n\n    response.result = result;\n    return undefined;\n  });\n}\n\nexport function createSolanaMiddleware(providerHandlers: IProviderHandlers): JRPCMiddleware<unknown, unknown> {\n  const { getAccounts, requestAccounts, signTransaction, signAndSendTransaction, signAllTransactions, signMessage, getPrivateKey, getSecretKey } =\n    providerHandlers;\n\n  return mergeMiddleware([\n    createRequestAccountsMiddleware({ requestAccounts }),\n    createGetAccountsMiddleware({ getAccounts }),\n    createGenericJRPCMiddleware<{ message: TransactionOrVersionedTransaction }, TransactionOrVersionedTransaction>(\n      \"signTransaction\",\n      signTransaction\n    ),\n    createGenericJRPCMiddleware<{ message: TransactionOrVersionedTransaction }, { signature: string }>(\n      \"signAndSendTransaction\",\n      signAndSendTransaction\n    ),\n    createGenericJRPCMiddleware<{ message: TransactionOrVersionedTransaction[] }, TransactionOrVersionedTransaction[]>(\n      \"signAllTransactions\",\n      signAllTransactions\n    ),\n    createGenericJRPCMiddleware<{ message: Uint8Array }, Uint8Array>(\"signMessage\", signMessage),\n    createGenericJRPCMiddleware<void, string>(\"solanaPrivateKey\", getPrivateKey),\n    createGenericJRPCMiddleware<void, string>(\"private_key\", getPrivateKey),\n    createGenericJRPCMiddleware<void, string>(\"solanaSecretKey\", getSecretKey),\n  ]);\n}\nexport interface AddSolanaChainParameter {\n  chainId: string; // A 0x-prefixed hexadecimal string\n  chainName: string;\n  nativeCurrency: {\n    name: string;\n    symbol: string; // 2-6 characters long\n    decimals: 18;\n  };\n  rpcUrls: string[];\n  blockExplorerUrls?: string[];\n}\n\nexport interface IChainSwitchHandlers {\n  addNewChainConfig: (req: JRPCRequest<AddSolanaChainParameter>) => Promise<void>;\n  switchSolanaChain: (req: JRPCRequest<{ chainId: string }>) => Promise<void>;\n}\nexport function createChainSwitchMiddleware({ addNewChainConfig, switchSolanaChain }: IChainSwitchHandlers): JRPCMiddleware<unknown, unknown> {\n  return mergeMiddleware([\n    createGenericJRPCMiddleware<AddSolanaChainParameter, void>(\"addSolanaChain\", addNewChainConfig),\n    createGenericJRPCMiddleware<{ chainId: string }, void>(\"switchSolanaChain\", switchSolanaChain),\n  ]);\n}\n\nexport interface IAccountHandlers {\n  updatePrivatekey: (req: JRPCRequest<{ privateKey: string }>) => Promise<void>;\n}\nexport function createAccountMiddleware({ updatePrivatekey }: IAccountHandlers): JRPCMiddleware<unknown, unknown> {\n  return mergeMiddleware([createGenericJRPCMiddleware<{ privateKey: string }, void>(\"updateAccount\", updatePrivatekey)]);\n}\n","import { JRPCEngine, JRPCMiddleware, providerFromEngine } from \"@toruslabs/openlogin-jrpc\";\nimport { CHAIN_NAMESPACES, CustomChainConfig, WalletLoginError } from \"@web3auth/base\";\nimport { BaseProvider, BaseProviderConfig, BaseProviderState } from \"@web3auth/base-provider\";\n\nimport { createConfigMiddleware } from \"../../../rpc/JrpcClient\";\nimport { createSolanaMiddleware, IProviderHandlers } from \"../../../rpc/solanaRpcMiddlewares\";\n\nexport abstract class BaseInjectedProvider<P> extends BaseProvider<BaseProviderConfig, BaseProviderState, P> {\n  constructor({ config, state }: { config: BaseProviderConfig; state?: BaseProviderState }) {\n    super({ config: { chainConfig: { ...config.chainConfig, chainNamespace: CHAIN_NAMESPACES.SOLANA } }, state });\n  }\n\n  public async switchChain(_: { chainId: string }): Promise<void> {\n    throw WalletLoginError.unsupportedOperation(\"Chain switching is not supported by this adapter\");\n  }\n\n  public async setupProvider(injectedProvider: P): Promise<void> {\n    const engine = new JRPCEngine();\n\n    const providerHandlers = this.getProviderHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    engine.push(solanaMiddleware);\n\n    const configMiddleware = createConfigMiddleware(this.config.chainConfig as CustomChainConfig);\n    engine.push(configMiddleware);\n\n    const injectedProviderProxy = this.getInjectedProviderProxy(injectedProvider);\n    if (injectedProviderProxy) {\n      engine.push(injectedProviderProxy);\n    }\n\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  protected async lookupNetwork(): Promise<string> {\n    const { chainConfig } = this.config;\n    this.update({\n      chainId: chainConfig.chainId,\n    });\n    return chainConfig.chainId || \"\";\n  }\n\n  protected getInjectedProviderProxy(_: P): JRPCMiddleware<unknown, unknown> {\n    return undefined;\n  }\n\n  protected abstract getProviderHandlers(injectedProvider: P): IProviderHandlers;\n}\n","import { JRPCRequest } from \"@toruslabs/openlogin-jrpc\";\nimport bs58 from \"bs58\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { IBaseWalletProvider, TransactionOrVersionedTransaction } from \"../../../interface\";\nimport { IProviderHandlers } from \"../../../rpc/solanaRpcMiddlewares\";\n\nexport const getBaseProviderHandlers = (injectedProvider: IBaseWalletProvider): IProviderHandlers => {\n  const providerHandlers: IProviderHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => (injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : []),\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>): Promise<TransactionOrVersionedTransaction> => {\n      const transaction = await injectedProvider.signTransaction(req.params.message);\n      return transaction;\n    },\n    signMessage: async (req: JRPCRequest<{ message: Uint8Array; display?: \"utf8\" | \"hex\" }>): Promise<Uint8Array> => {\n      const sigData = await injectedProvider.signMessage(req.params.message, req.params.display);\n      return sigData.signature;\n    },\n    signAllTransactions: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction[] }>): Promise<TransactionOrVersionedTransaction[]> => {\n      if (!req.params?.message || !req.params?.message.length) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const transaction = await injectedProvider.signAllTransactions(req.params.message);\n      return transaction;\n    },\n    signAndSendTransaction: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>): Promise<{ signature: string }> => {\n      const txRes = await injectedProvider.signAndSendTransaction(req.params.message);\n      return { signature: txRes.signature };\n    },\n  };\n  return providerHandlers;\n};\n","import { createAsyncMiddleware, JRPCEngineNextCallback, JRPCMiddleware, JRPCRequest, JRPCResponse } from \"@toruslabs/openlogin-jrpc\";\n\nimport { InjectedProvider } from \"./interface\";\n\nexport function createInjectedProviderProxyMiddleware(provider: InjectedProvider): JRPCMiddleware<unknown, unknown> {\n  return createAsyncMiddleware(async (req: JRPCRequest<unknown[]>, res: JRPCResponse<unknown>, _next: JRPCEngineNextCallback) => {\n    const result = await provider.request({\n      ...req,\n    });\n    res.result = result;\n  });\n}\n","import { JRPCMiddleware } from \"@toruslabs/openlogin-jrpc\";\n\nimport { IPhantomWalletProvider } from \"../../../interface\";\nimport { IProviderHandlers } from \"../../../rpc/solanaRpcMiddlewares\";\nimport { BaseInjectedProvider } from \"../base/baseInjectedProvider\";\nimport { getBaseProviderHandlers } from \"../base/providerHandlers\";\nimport { createInjectedProviderProxyMiddleware } from \"../injectedProviderProxy\";\n\nexport class PhantomInjectedProvider extends BaseInjectedProvider<IPhantomWalletProvider> {\n  protected getProviderHandlers(injectedProvider: IPhantomWalletProvider): IProviderHandlers {\n    return getBaseProviderHandlers(injectedProvider);\n  }\n\n  protected getInjectedProviderProxy(injectedProvider: IPhantomWalletProvider): JRPCMiddleware<unknown, unknown> {\n    return createInjectedProviderProxyMiddleware(injectedProvider);\n  }\n}\n","import { Connection, PublicKey, Transaction, VersionedTransaction } from \"@solana/web3.js\";\nimport { JRPCRequest } from \"@toruslabs/openlogin-jrpc\";\nimport { CustomChainConfig, SafeEventEmitterProvider } from \"@web3auth/base\";\nimport bs58 from \"bs58\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { ISlopeProvider, TransactionOrVersionedTransaction } from \"../../../interface\";\nimport { IProviderHandlers } from \"../../../rpc/solanaRpcMiddlewares\";\n\nconst isVersionTransction = (transaction: TransactionOrVersionedTransaction) =>\n  (transaction as VersionedTransaction).version !== undefined || transaction instanceof VersionedTransaction;\n\nexport const getSlopeHandlers = (injectedProvider: ISlopeProvider, getProviderEngineProxy: () => SafeEventEmitterProvider): IProviderHandlers => {\n  const providerHandlers: IProviderHandlers = {\n    requestAccounts: async () => {\n      const { data } = await injectedProvider.connect();\n      return [data.publicKey];\n    },\n    getAccounts: async () => {\n      const { data } = await injectedProvider.connect();\n      return [data.publicKey];\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>): Promise<TransactionOrVersionedTransaction> => {\n      const txMessage = req.params.message;\n      if (!txMessage) throw ethErrors.rpc.invalidRequest({ message: \"Invalid transaction message\" });\n\n      const message = isVersionTransction(txMessage)\n        ? (txMessage as VersionedTransaction).message.serialize()\n        : (txMessage as Transaction).serializeMessage();\n      const { data } = await injectedProvider.signTransaction(bs58.encode(message));\n      if (!data.publicKey || !data.signature) throw new Error(\"Invalid signature from slope wallet\");\n\n      const publicKey = new PublicKey(data.publicKey);\n      const signature = bs58.decode(data.signature);\n      txMessage.addSignature(publicKey, Buffer.from(signature));\n      return txMessage;\n    },\n    signMessage: async (req: JRPCRequest<{ message: Uint8Array }>): Promise<Uint8Array> => {\n      const response = await injectedProvider.signMessage(req.params.message);\n      return bs58.decode(response.data.signature);\n    },\n    signAndSendTransaction: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>): Promise<{ signature: string }> => {\n      const provider = getProviderEngineProxy();\n      if (!provider) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n      const txMessage = req.params.message;\n      if (!txMessage) throw ethErrors.rpc.invalidRequest({ message: \"Invalid transaction message\" });\n\n      const message = isVersionTransction(txMessage)\n        ? (txMessage as VersionedTransaction).message.serialize()\n        : (txMessage as Transaction).serializeMessage();\n      const { data } = await injectedProvider.signTransaction(bs58.encode(message));\n      if (!data.publicKey || !data.signature) throw new Error(\"Invalid signature from slope wallet\");\n      const publicKey = new PublicKey(data.publicKey);\n      const signature = bs58.decode(data.signature);\n      txMessage.addSignature(publicKey, Buffer.from(signature));\n      const chainConfig = (await provider.request<CustomChainConfig>({ method: \"solana_provider_config\", params: [] })) as CustomChainConfig;\n      const conn = new Connection(chainConfig.rpcTarget);\n      const res = await conn.sendRawTransaction(txMessage.serialize());\n      return { signature: res };\n    },\n    signAllTransactions: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction[] }>): Promise<TransactionOrVersionedTransaction[]> => {\n      if (!req.params?.message || !req.params?.message.length) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const allTxns = req.params.message;\n      const { length } = allTxns;\n\n      const unsignedTx = [];\n\n      for (let i = 0; i < length; i++) {\n        const item = allTxns[i];\n        const message = isVersionTransction(item) ? (item as VersionedTransaction).message.serialize() : (item as Transaction).serializeMessage();\n        unsignedTx.push(bs58.encode(message));\n      }\n      const { msg, data } = await injectedProvider.signAllTransactions(unsignedTx);\n\n      if (!data.publicKey || data.signatures?.length !== length) throw new Error(msg);\n\n      const publicKey = new PublicKey(data.publicKey);\n\n      for (let i = 0; i < length; i++) {\n        const signature = bs58.decode(data.signatures[i]);\n        allTxns[i].addSignature(publicKey, Buffer.from(signature));\n      }\n\n      return allTxns;\n    },\n  };\n  return providerHandlers;\n};\n","import { ISlopeProvider } from \"../../../interface\";\nimport { IProviderHandlers } from \"../../../rpc/solanaRpcMiddlewares\";\nimport { BaseInjectedProvider } from \"../base/baseInjectedProvider\";\nimport { getSlopeHandlers } from \"./providerHandlers\";\n\nexport class SlopeInjectedProxyProvider extends BaseInjectedProvider<ISlopeProvider> {\n  protected getProviderHandlers(injectedProvider: ISlopeProvider): IProviderHandlers {\n    return getSlopeHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n}\n","import { Connection } from \"@solana/web3.js\";\nimport { JRPCRequest } from \"@toruslabs/openlogin-jrpc\";\nimport { CustomChainConfig, SafeEventEmitterProvider } from \"@web3auth/base\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { IBaseWalletProvider, SolflareWallet, TransactionOrVersionedTransaction } from \"../../../interface\";\nimport { IProviderHandlers } from \"../../../rpc/solanaRpcMiddlewares\";\nimport { getBaseProviderHandlers } from \"../base/providerHandlers\";\n\nexport const getSolflareHandlers = (injectedProvider: SolflareWallet, getProviderEngineProxy: () => SafeEventEmitterProvider): IProviderHandlers => {\n  const solflareProviderHandlers = getBaseProviderHandlers(injectedProvider as IBaseWalletProvider);\n  solflareProviderHandlers.signAndSendTransaction = async (\n    req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>\n  ): Promise<{ signature: string }> => {\n    const provider = getProviderEngineProxy();\n    if (!provider) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n\n    const transaction = await injectedProvider.signTransaction(req.params.message);\n    const chainConfig = (await provider.request<CustomChainConfig>({ method: \"solana_provider_config\", params: [] })) as CustomChainConfig;\n    const conn = new Connection(chainConfig.rpcTarget);\n    const res = await conn.sendRawTransaction(transaction.serialize());\n    return { signature: res };\n  };\n\n  solflareProviderHandlers.signMessage = async (req: JRPCRequest<{ message: Uint8Array; display?: \"utf8\" | \"hex\" }>): Promise<Uint8Array> => {\n    const sigData = await injectedProvider.signMessage(req.params.message, req.params.display);\n    return sigData;\n  };\n  return solflareProviderHandlers;\n};\n","import { SolflareWallet } from \"../../../interface\";\nimport { IProviderHandlers } from \"../../../rpc/solanaRpcMiddlewares\";\nimport { BaseInjectedProvider } from \"../base/baseInjectedProvider\";\nimport { getSolflareHandlers } from \"./providerHandlers\";\n\nexport class SolflareInjectedProvider extends BaseInjectedProvider<SolflareWallet> {\n  protected getProviderHandlers(injectedProvider: SolflareWallet): IProviderHandlers {\n    return getSolflareHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n}\n","import { JRPCRequest } from \"@toruslabs/openlogin-jrpc\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { ITorusWalletProvider, TransactionOrVersionedTransaction } from \"../../../interface\";\nimport { IProviderHandlers } from \"../../../rpc/solanaRpcMiddlewares\";\n\nexport const getTorusHandlers = (injectedProvider: ITorusWalletProvider): IProviderHandlers => {\n  const providerHandlers: IProviderHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request<string[]>({\n        method: \"solana_requestAccounts\",\n        params: {},\n      });\n      return accounts;\n    },\n\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request<string[]>({\n        method: \"solana_requestAccounts\",\n        params: {},\n      });\n      return accounts;\n    },\n\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async (req: JRPCRequest<{ message: Uint8Array }>): Promise<Uint8Array> => {\n      if (!req.params?.message) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const message = await injectedProvider.signMessage(req.params.message);\n      return message;\n    },\n\n    signTransaction: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>): Promise<TransactionOrVersionedTransaction> => {\n      if (!req.params?.message) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const txMessage = req.params.message;\n      const response = await injectedProvider.signTransaction(txMessage);\n      return response;\n    },\n\n    signAndSendTransaction: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>): Promise<{ signature: string }> => {\n      if (!req.params?.message) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const txMessage = req.params.message;\n      const response = await injectedProvider.sendTransaction(txMessage);\n      return { signature: response };\n    },\n\n    signAllTransactions: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction[] }>): Promise<TransactionOrVersionedTransaction[]> => {\n      if (!req.params?.message || !req.params?.message.length) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const transactions = req.params.message;\n      const response = await injectedProvider.signAllTransactions(transactions);\n      return response;\n    },\n  };\n  return providerHandlers;\n};\n","import { JRPCEngine, providerFromEngine } from \"@toruslabs/openlogin-jrpc\";\nimport { CHAIN_NAMESPACES, CustomChainConfig, isHexStrict, WalletInitializationError } from \"@web3auth/base\";\nimport { BaseProvider, BaseProviderConfig, BaseProviderState } from \"@web3auth/base-provider\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { ITorusWalletProvider } from \"../../../interface\";\nimport { createSolanaMiddleware } from \"../../../rpc/solanaRpcMiddlewares\";\nimport { createInjectedProviderProxyMiddleware } from \"../injectedProviderProxy\";\nimport { getTorusHandlers } from \"./providerHandlers\";\n\nexport class TorusInjectedProvider extends BaseProvider<BaseProviderConfig, BaseProviderState, ITorusWalletProvider> {\n  constructor({ config, state }: { config: BaseProviderConfig; state?: BaseProviderState }) {\n    super({ config: { chainConfig: { ...config.chainConfig, chainNamespace: CHAIN_NAMESPACES.SOLANA } }, state });\n  }\n\n  public async switchChain(params: { chainId: string }): Promise<void> {\n    // overrides the base provider implementation\n    await this.provider.request({\n      method: \"switchSolanaChain\",\n      params: [{ chainId: params.chainId }],\n    });\n  }\n\n  public async addChain(chainConfig: CustomChainConfig): Promise<void> {\n    super.addChain(chainConfig);\n    await this.provider.request({\n      method: \"addNewChainConfig\",\n      params: [\n        {\n          chainId: chainConfig.chainId,\n          chainName: chainConfig.displayName,\n          rpcUrls: [chainConfig.rpcTarget],\n          blockExplorerUrls: [chainConfig.blockExplorer],\n          nativeCurrency: {\n            name: chainConfig.tickerName,\n            symbol: chainConfig.ticker,\n            decimals: chainConfig.decimals || 18,\n          },\n        },\n      ],\n    });\n  }\n\n  public async setupProvider(injectedProvider: ITorusWalletProvider): Promise<void> {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  protected async lookupNetwork(): Promise<string> {\n    if (!this.provider) throw ethErrors.provider.custom({ message: \"Torus solana provider is not initialized\", code: 4902 });\n    const { chainId } = this.config.chainConfig;\n\n    const connectedChainId = await this.provider.request<string>({\n      method: \"solana_chainId\",\n    });\n\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : `0x${parseInt(connectedChainId, 10).toString(16)}`;\n    if (chainId !== connectedHexChainId)\n      throw WalletInitializationError.rpcConnectionError(`Invalid network, net_version is: ${connectedHexChainId}, expected: ${chainId}`);\n\n    this.update({ chainId: connectedHexChainId });\n    this.provider.emit(\"connect\", { chainId: this.state.chainId });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  private async setupEngine(injectedProvider: ITorusWalletProvider): Promise<void> {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  private async handleInjectedProviderUpdate(injectedProvider: ITorusWalletProvider): Promise<void> {\n    injectedProvider.on(\"accountsChanged\", async (accounts: string[]) => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async (chainId: string) => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : `0x${parseInt(chainId, 10).toString(16)}`;\n      // Check if chainId changed and trigger event\n      this.configure({\n        chainConfig: { ...this.config.chainConfig, chainId: connectedHexChainId },\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n}\n","import { Keypair, VersionedTransaction } from \"@solana/web3.js\";\nimport { JRPCRequest } from \"@toruslabs/openlogin-jrpc\";\nimport nacl from \"@toruslabs/tweetnacl-js\";\nimport { SafeEventEmitterProvider, WalletInitializationError } from \"@web3auth/base\";\nimport bs58 from \"bs58\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { TransactionOrVersionedTransaction } from \"../../interface\";\nimport { IProviderHandlers } from \"../../rpc/solanaRpcMiddlewares\";\n\nexport async function getProviderHandlers({\n  privKey,\n  getProviderEngineProxy,\n}: {\n  privKey: string;\n  getProviderEngineProxy: () => SafeEventEmitterProvider | null;\n}): Promise<IProviderHandlers> {\n  const keyPairGenerator = (): Keypair => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers: IProviderHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n\n    getPrivateKey: async () => privKey,\n    getSecretKey: async () => bs58.encode(keyPair.secretKey),\n\n    signTransaction: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>): Promise<TransactionOrVersionedTransaction> => {\n      if (!req.params?.message) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const transaction = req.params.message;\n      if ((transaction as VersionedTransaction).version !== undefined || transaction instanceof VersionedTransaction) {\n        (transaction as VersionedTransaction).sign([keyPair]);\n      } else {\n        transaction.partialSign(keyPair);\n      }\n      return transaction;\n    },\n\n    signMessage: async (req: JRPCRequest<{ message: Uint8Array }>): Promise<Uint8Array> => {\n      if (!req.params?.message) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n\n    signAndSendTransaction: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction }>): Promise<{ signature: string }> => {\n      if (!req.params?.message) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n      const _providerEngineProxy = getProviderEngineProxy();\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n\n      const transaction = req.params.message;\n      if ((transaction as VersionedTransaction).version !== undefined || transaction instanceof VersionedTransaction) {\n        (transaction as VersionedTransaction).sign([keyPair]);\n      } else {\n        transaction.partialSign(keyPair);\n      }\n      const sig = await _providerEngineProxy.request<string>({\n        method: \"sendTransaction\",\n        params: [Buffer.from(transaction.serialize()).toString(\"base64\"), { encoding: \"base64\", preflightCommitment: \"confirmed\" }],\n      });\n      return { signature: sig };\n    },\n\n    signAllTransactions: async (req: JRPCRequest<{ message: TransactionOrVersionedTransaction[] }>): Promise<TransactionOrVersionedTransaction[]> => {\n      if (!req.params?.message || !req.params?.message.length) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = req.params?.message;\n      for (const tx of txns || []) {\n        const transaction = tx;\n        if ((transaction as VersionedTransaction).version !== undefined || transaction instanceof VersionedTransaction) {\n          (transaction as VersionedTransaction).sign([keyPair]);\n        } else {\n          transaction.partialSign(keyPair);\n        }\n      }\n      return txns;\n    },\n  };\n\n  return providerHandlers;\n}\n","import { getED25519Key } from \"@toruslabs/openlogin-ed25519\";\nimport { JRPCEngine, JRPCMiddleware, JRPCRequest, providerFromEngine } from \"@toruslabs/openlogin-jrpc\";\nimport { CHAIN_NAMESPACES, CustomChainConfig, WalletInitializationError } from \"@web3auth/base\";\nimport { BaseProvider, BaseProviderConfig, BaseProviderState } from \"@web3auth/base-provider\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { createJsonRpcClient } from \"../../rpc/JrpcClient\";\nimport {\n  AddSolanaChainParameter,\n  createAccountMiddleware,\n  createChainSwitchMiddleware,\n  createSolanaMiddleware,\n  IAccountHandlers,\n  IChainSwitchHandlers,\n} from \"../../rpc/solanaRpcMiddlewares\";\nimport { getProviderHandlers } from \"./solanaPrivateKeyUtils\";\n\nexport interface SolanaPrivKeyProviderConfig extends BaseProviderConfig {\n  chainConfig: Omit<CustomChainConfig, \"chainNamespace\">;\n}\nexport interface SolanaPrivKeyProviderState extends BaseProviderState {\n  privateKey?: string;\n}\nexport class SolanaPrivateKeyProvider extends BaseProvider<BaseProviderConfig, SolanaPrivKeyProviderState, string> {\n  constructor({ config, state }: { config: SolanaPrivKeyProviderConfig; state?: BaseProviderState }) {\n    super({ config: { chainConfig: { ...config.chainConfig, chainNamespace: CHAIN_NAMESPACES.SOLANA } }, state });\n  }\n\n  public static getProviderInstance = async (params: {\n    privKey: string;\n    chainConfig: Omit<CustomChainConfig, \"chainNamespace\">;\n  }): Promise<SolanaPrivateKeyProvider> => {\n    const providerFactory = new SolanaPrivateKeyProvider({ config: { chainConfig: params.chainConfig } });\n    await providerFactory.setupProvider(params.privKey);\n    return providerFactory;\n  };\n\n  public async enable(): Promise<string[]> {\n    if (!this.state.privateKey)\n      throw ethErrors.provider.custom({ message: \"Private key is not found in state, plz pass it in constructor state param\", code: 4902 });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request<string[]>({ method: \"eth_accounts\" });\n  }\n\n  public getEd25519Key(privateKey: string): string {\n    return getED25519Key(privateKey).sk.toString(\"hex\").padStart(128, \"0\");\n  }\n\n  public async setupProvider(privKey: string): Promise<void> {\n    const providerHandlers = await getProviderHandlers({ privKey, getProviderEngineProxy: this.getProviderEngineProxy.bind(this) });\n\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n\n    const engine = new JRPCEngine();\n    const { networkMiddleware } = createJsonRpcClient(this.config.chainConfig as CustomChainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n\n    const provider = providerFromEngine(engine);\n\n    this.updateProviderEngineProxy(provider);\n\n    await this.lookupNetwork();\n  }\n\n  public async updateAccount(params: { privateKey: string }): Promise<void> {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n    const existingKey = await this._providerEngineProxy.request<string>({ method: \"solanaPrivateKey\" });\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request<string[]>({ method: \"requestAccounts\" }),\n      });\n    }\n  }\n\n  public async switchChain(params: { chainId: string }): Promise<void> {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\",\n    });\n    this.configure({ chainConfig });\n    const privKey = await this._providerEngineProxy.request<string>({ method: \"solanaPrivateKey\" });\n    await this.setupProvider(privKey);\n  }\n\n  protected async lookupNetwork(): Promise<string> {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({ message: \"Provider is not initialized\", code: 4902 });\n    const health = await this._providerEngineProxy.request<string>({\n      method: \"getHealth\",\n      params: [],\n    });\n    const { chainConfig } = this.config;\n    if (health !== \"ok\")\n      throw WalletInitializationError.rpcConnectionError(`Failed to lookup network for following rpc target: ${chainConfig.rpcTarget}`);\n    this.update({ chainId: chainConfig.chainId });\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", { chainId: this.state.chainId });\n    }\n    return this.state.chainId;\n  }\n\n  private getChainSwitchMiddleware(): JRPCMiddleware<unknown, unknown> {\n    const chainSwitchHandlers: IChainSwitchHandlers = {\n      addNewChainConfig: async (req: JRPCRequest<AddSolanaChainParameter>): Promise<void> => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const { chainId, chainName, rpcUrls, blockExplorerUrls, nativeCurrency } = req.params;\n\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: nativeCurrency?.symbol || \"SOL\",\n          tickerName: nativeCurrency?.name || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: blockExplorerUrls?.[0] || \"\",\n          decimals: nativeCurrency?.decimals || 9,\n        });\n      },\n      switchSolanaChain: async (req: JRPCRequest<{ chainId: string }>): Promise<void> => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      },\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  private getAccountMiddleware(): JRPCMiddleware<unknown, unknown> {\n    const accountHandlers: IAccountHandlers = {\n      updatePrivatekey: async (req: JRPCRequest<{ privateKey: string }>): Promise<void> => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const { privateKey } = req.params;\n        await this.updateAccount({ privateKey });\n      },\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n}\n","import { RequestArguments, SafeEventEmitterProvider } from \"@web3auth/base\";\n\nimport { ISolanaWallet, TransactionOrVersionedTransaction } from \"./interface\";\n\nexport class SolanaWallet implements ISolanaWallet {\n  public provider: SafeEventEmitterProvider;\n\n  constructor(provider: SafeEventEmitterProvider) {\n    this.provider = provider;\n  }\n\n  public async requestAccounts(): Promise<string[]> {\n    const accounts = await this.provider.request<string[]>({\n      method: \"requestAccounts\",\n      params: {},\n    });\n    return accounts;\n  }\n\n  public async signAndSendTransaction<T extends TransactionOrVersionedTransaction>(transaction: T): Promise<{ signature: string }> {\n    const { signature } = await this.provider.request<{ signature: string }>({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: transaction,\n      },\n    });\n    return { signature };\n  }\n\n  public async signTransaction<T extends TransactionOrVersionedTransaction>(transaction: T): Promise<T> {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: transaction,\n      },\n    });\n    return signedTransaction as T;\n  }\n\n  public async signAllTransactions<T extends TransactionOrVersionedTransaction>(transactions: T[]): Promise<T[]> {\n    const signedTransactions = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: transactions,\n      },\n    });\n    return signedTransactions as T[];\n  }\n\n  public async signMessage(data: Uint8Array): Promise<Uint8Array> {\n    const response = await this.provider.request<Uint8Array>({\n      method: \"signMessage\",\n      params: {\n        message: data,\n      },\n    });\n    return response as Uint8Array;\n  }\n\n  public async request<T>(args: RequestArguments): Promise<T> {\n    const result = await this.provider.request<T>(args);\n    return result as T;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}