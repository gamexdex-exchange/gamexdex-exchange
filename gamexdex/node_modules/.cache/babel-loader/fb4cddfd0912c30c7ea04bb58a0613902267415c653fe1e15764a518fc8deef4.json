{"ast":null,"code":"'use strict';\n\nvar urilib = require('url');\nvar attribute = require('./attribute');\nvar helpers = require('./helpers');\nvar scanSchema = require('./scan').scan;\nvar ValidatorResult = helpers.ValidatorResult;\nvar ValidatorResultError = helpers.ValidatorResultError;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n//var anonymousBase = 'vnd.jsonschema:///';\nvar anonymousBase = '/';\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator() {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema(schema, base) {\n  var self = this;\n  if (!schema) {\n    return null;\n  }\n  var scan = scanSchema(base || anonymousBase, schema);\n  var ourUri = base || schema.$id || schema.id;\n  for (var uri in scan.id) {\n    this.schemas[uri] = scan.id[uri];\n  }\n  for (var uri in scan.ref) {\n    // If this schema is already defined, it will be filtered out by the next step\n    this.unresolvedRefs.push(uri);\n  }\n  // Remove newly defined schemas from unresolvedRefs\n  this.unresolvedRefs = this.unresolvedRefs.filter(function (uri) {\n    return typeof self.schemas[uri] === 'undefined';\n  });\n  return this.schemas[ourUri];\n};\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if (!Array.isArray(schemas)) return;\n  for (var i = 0; i < schemas.length; i++) {\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if (!schemas || typeof schemas != 'object') return;\n  for (var p in schemas) {\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas(schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema(urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate(instance, schema, options, ctx) {\n  if (typeof schema !== 'boolean' && typeof schema !== 'object' || schema === null) {\n    throw new SchemaError('Expected `schema` to be an object or boolean');\n  }\n  if (!options) {\n    options = {};\n  }\n  // This section indexes subschemas in the provided schema, so they don't need to be added with Validator#addSchema\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var id = schema.$id || schema.id;\n  var base = urilib.resolve(options.base || anonymousBase, id || '');\n  if (!ctx) {\n    ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n    var found = scanSchema(base, schema);\n    for (var n in found.id) {\n      var sch = found.id[n];\n      ctx.schemas[n] = sch;\n    }\n  }\n  if (options.required && instance === undefined) {\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    result.addError('is required, but is undefined');\n    return result;\n  }\n  var result = this.validateSchema(instance, schema, options, ctx);\n  if (!result) {\n    throw new Error('Result undefined');\n  } else if (options.throwAll && result.errors.length) {\n    throw new ValidatorResultError(result);\n  }\n  return result;\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = typeof schema === 'string' ? schema : schema.$ref;\n  if (typeof ref == 'string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  // Support for the true/false schemas\n  if (typeof schema === 'boolean') {\n    if (schema === true) {\n      // `true` is always valid\n      schema = {};\n    } else if (schema === false) {\n      // `false` is always invalid\n      schema = {\n        type: []\n      };\n    }\n  } else if (!schema) {\n    // This might be a string\n    throw new Error(\"schema is undefined\");\n  }\n  if (schema['extends']) {\n    if (Array.isArray(schema['extends'])) {\n      var schemaobj = {\n        schema: schema,\n        ctx: ctx\n      };\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  // If passed a string argument, load that schema URI\n  var switchSchema = shouldResolve(schema);\n  if (switchSchema) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser(schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve(schema, ctx) {\n  var ref = shouldResolve(schema);\n  if (ref) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n};\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve(schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {\n      subschema: ctx.schemas[switchSchema],\n      switchSchema: switchSchema\n    };\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if (subschema === undefined) {\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {\n    subschema: subschema,\n    switchSchema: switchSchema\n  };\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType(instance, schema, options, ctx, type) {\n  if (type === undefined) {\n    return;\n  } else if (type === null) {\n    throw new SchemaError('Unexpected null in \"type\" keyword');\n  }\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\nvar types = Validator.prototype.types = {};\ntypes.string = function testString(instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber(instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger(instance) {\n  return typeof instance == 'number' && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean(instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray(instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull(instance) {\n  return instance === null;\n};\ntypes.date = function testDate(instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny(instance) {\n  return true;\n};\ntypes.object = function testObject(instance) {\n  // TODO: fix this - see #15\n  return instance && typeof instance === 'object' && !Array.isArray(instance) && !(instance instanceof Date);\n};\nmodule.exports = Validator;","map":{"version":3,"names":["urilib","require","attribute","helpers","scanSchema","scan","ValidatorResult","ValidatorResultError","SchemaError","SchemaContext","anonymousBase","Validator","customFormats","Object","create","prototype","schemas","unresolvedRefs","types","attributes","validators","addSchema","schema","base","self","ourUri","$id","id","uri","ref","push","filter","addSubSchemaArray","baseuri","Array","isArray","i","length","addSubSchema","addSubSchemaObject","p","setSchemas","getSchema","urn","validate","instance","options","ctx","resolve","found","n","sch","required","undefined","result","addError","validateSchema","Error","throwAll","errors","shouldResolve","$ref","type","schemaobj","forEach","schemaTraverser","bind","deepMerge","superResolve","switchSchema","resolved","subctx","subschema","path","skipAttributes","key","ignoreProperties","indexOf","validatorErr","validator","call","allowUnknownAttributes","importErrors","rewrite","value","s","parsed","parse","fragment","hash","document","substr","objectGetPath","testType","validateType","res","string","testString","number","testNumber","isFinite","integer","testInteger","boolean","testBoolean","array","testArray","testNull","date","testDate","Date","any","testAny","object","testObject","module","exports"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/jsonschema/lib/validator.js"],"sourcesContent":["'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\nvar helpers = require('./helpers');\nvar scanSchema = require('./scan').scan;\nvar ValidatorResult = helpers.ValidatorResult;\nvar ValidatorResultError = helpers.ValidatorResultError;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n//var anonymousBase = 'vnd.jsonschema:///';\nvar anonymousBase = '/';\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator () {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema (schema, base) {\n  var self = this;\n  if (!schema) {\n    return null;\n  }\n  var scan = scanSchema(base||anonymousBase, schema);\n  var ourUri = base || schema.$id || schema.id;\n  for(var uri in scan.id){\n    this.schemas[uri] = scan.id[uri];\n  }\n  for(var uri in scan.ref){\n    // If this schema is already defined, it will be filtered out by the next step\n    this.unresolvedRefs.push(uri);\n  }\n  // Remove newly defined schemas from unresolvedRefs\n  this.unresolvedRefs = this.unresolvedRefs.filter(function(uri){\n    return typeof self.schemas[uri]==='undefined';\n  });\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if(!Array.isArray(schemas)) return;\n  for(var i=0; i<schemas.length; i++){\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if(!schemas || typeof schemas!='object') return;\n  for(var p in schemas){\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas (schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema (urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n  if((typeof schema !== 'boolean' && typeof schema !== 'object') || schema === null){\n    throw new SchemaError('Expected `schema` to be an object or boolean');\n  }\n  if (!options) {\n    options = {};\n  }\n  // This section indexes subschemas in the provided schema, so they don't need to be added with Validator#addSchema\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var id = schema.$id || schema.id;\n  var base = urilib.resolve(options.base||anonymousBase, id||'');\n  if(!ctx){\n    ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n    var found = scanSchema(base, schema);\n    for(var n in found.id){\n      var sch = found.id[n];\n      ctx.schemas[n] = sch;\n    }\n  }\n  if(options.required && instance===undefined){\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    result.addError('is required, but is undefined');\n    return result;\n  }\n  var result = this.validateSchema(instance, schema, options, ctx);\n  if (!result) {\n    throw new Error('Result undefined');\n  }else if(options.throwAll && result.errors.length){\n    throw new ValidatorResultError(result);\n  }\n  return result;\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = (typeof schema === 'string') ? schema : schema.$ref;\n  if (typeof ref=='string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  // Support for the true/false schemas\n  if(typeof schema==='boolean') {\n    if(schema===true){\n      // `true` is always valid\n      schema = {};\n    }else if(schema===false){\n      // `false` is always invalid\n      schema = {type: []};\n    }\n  }else if(!schema){\n    // This might be a string\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (Array.isArray(schema['extends'])) {\n      var schemaobj = {schema: schema, ctx: ctx};\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  // If passed a string argument, load that schema URI\n  var switchSchema = shouldResolve(schema);\n  if (switchSchema) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve (schema, ctx) {\n  var ref = shouldResolve(schema);\n  if(ref) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n};\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if(subschema===undefined){\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {subschema: subschema, switchSchema: switchSchema};\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n  if(type===undefined){\n    return;\n  }else if(type===null){\n    throw new SchemaError('Unexpected null in \"type\" keyword');\n  }\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\ntypes.string = function testString (instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber (instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger (instance) {\n  return (typeof instance == 'number') && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean (instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray (instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull (instance) {\n  return instance === null;\n};\ntypes.date = function testDate (instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny (instance) {\n  return true;\n};\ntypes.object = function testObject (instance) {\n  // TODO: fix this - see #15\n  return instance && (typeof instance === 'object') && !(Array.isArray(instance)) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}