{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseTransaction = void 0;\nconst common_1 = require(\"@ethereumjs/common\");\nconst util_1 = require(\"@ethereumjs/util\");\nconst types_1 = require(\"./types\");\nconst util_2 = require(\"./util\");\n/**\n * This base class will likely be subject to further\n * refactoring along the introduction of additional tx types\n * on the Ethereum network.\n *\n * It is therefore not recommended to use directly.\n */\nclass BaseTransaction {\n  constructor(txData, opts) {\n    this.cache = {\n      hash: undefined,\n      dataFee: undefined\n    };\n    /**\n     * List of tx type defining EIPs,\n     * e.g. 1559 (fee market) and 2930 (access lists)\n     * for FeeMarketEIP1559Transaction objects\n     */\n    this.activeCapabilities = [];\n    /**\n     * The default chain the tx falls back to if no Common\n     * is provided and if the chain can't be derived from\n     * a passed in chainId (only EIP-2718 typed txs) or\n     * EIP-155 signature (legacy txs).\n     *\n     * @hidden\n     */\n    this.DEFAULT_CHAIN = common_1.Chain.Mainnet;\n    /**\n     * The default HF if the tx type is active on that HF\n     * or the first greater HF where the tx is active.\n     *\n     * @hidden\n     */\n    this.DEFAULT_HARDFORK = common_1.Hardfork.Merge;\n    const {\n      nonce,\n      gasLimit,\n      to,\n      value,\n      data,\n      v,\n      r,\n      s,\n      type\n    } = txData;\n    this._type = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(type)));\n    this.txOptions = opts;\n    const toB = (0, util_1.toBuffer)(to === '' ? '0x' : to);\n    const vB = (0, util_1.toBuffer)(v === '' ? '0x' : v);\n    const rB = (0, util_1.toBuffer)(r === '' ? '0x' : r);\n    const sB = (0, util_1.toBuffer)(s === '' ? '0x' : s);\n    this.nonce = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(nonce === '' ? '0x' : nonce));\n    this.gasLimit = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(gasLimit === '' ? '0x' : gasLimit));\n    this.to = toB.length > 0 ? new util_1.Address(toB) : undefined;\n    this.value = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(value === '' ? '0x' : value));\n    this.data = (0, util_1.toBuffer)(data === '' ? '0x' : data);\n    this.v = vB.length > 0 ? (0, util_1.bufferToBigInt)(vB) : undefined;\n    this.r = rB.length > 0 ? (0, util_1.bufferToBigInt)(rB) : undefined;\n    this.s = sB.length > 0 ? (0, util_1.bufferToBigInt)(sB) : undefined;\n    this._validateCannotExceedMaxInteger({\n      value: this.value,\n      r: this.r,\n      s: this.s\n    });\n    // geth limits gasLimit to 2^64-1\n    this._validateCannotExceedMaxInteger({\n      gasLimit: this.gasLimit\n    }, 64);\n    // EIP-2681 limits nonce to 2^64-1 (cannot equal 2^64-1)\n    this._validateCannotExceedMaxInteger({\n      nonce: this.nonce\n    }, 64, true);\n    const createContract = this.to === undefined || this.to === null;\n    const allowUnlimitedInitCodeSize = opts.allowUnlimitedInitCodeSize ?? false;\n    const common = opts.common ?? this._getCommon();\n    if (createContract && common.isActivatedEIP(3860) && allowUnlimitedInitCodeSize === false) {\n      (0, util_2.checkMaxInitCodeSize)(common, this.data.length);\n    }\n  }\n  /**\n   * Returns the transaction type.\n   *\n   * Note: legacy txs will return tx type `0`.\n   */\n  get type() {\n    return this._type;\n  }\n  /**\n   * Checks if a tx type defining capability is active\n   * on a tx, for example the EIP-1559 fee market mechanism\n   * or the EIP-2930 access list feature.\n   *\n   * Note that this is different from the tx type itself,\n   * so EIP-2930 access lists can very well be active\n   * on an EIP-1559 tx for example.\n   *\n   * This method can be useful for feature checks if the\n   * tx type is unknown (e.g. when instantiated with\n   * the tx factory).\n   *\n   * See `Capabilites` in the `types` module for a reference\n   * on all supported capabilities.\n   */\n  supports(capability) {\n    return this.activeCapabilities.includes(capability);\n  }\n  validate(stringError = false) {\n    const errors = [];\n    if (this.getBaseFee() > this.gasLimit) {\n      errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);\n    }\n    if (this.isSigned() && !this.verifySignature()) {\n      errors.push('Invalid Signature');\n    }\n    return stringError ? errors : errors.length === 0;\n  }\n  _validateYParity() {\n    const {\n      v\n    } = this;\n    if (v !== undefined && v !== BigInt(0) && v !== BigInt(1)) {\n      const msg = this._errorMsg('The y-parity of the transaction should either be 0 or 1');\n      throw new Error(msg);\n    }\n  }\n  /**\n   * EIP-2: All transaction signatures whose s-value is greater than secp256k1n/2are considered invalid.\n   * Reasoning: https://ethereum.stackexchange.com/a/55728\n   */\n  _validateHighS() {\n    const {\n      s\n    } = this;\n    if (this.common.gteHardfork('homestead') && s !== undefined && s > util_1.SECP256K1_ORDER_DIV_2) {\n      const msg = this._errorMsg('Invalid Signature: s-values greater than secp256k1n/2 are considered invalid');\n      throw new Error(msg);\n    }\n  }\n  /**\n   * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)\n   */\n  getBaseFee() {\n    const txFee = this.common.param('gasPrices', 'tx');\n    let fee = this.getDataFee();\n    if (txFee) fee += txFee;\n    if (this.common.gteHardfork('homestead') && this.toCreationAddress()) {\n      const txCreationFee = this.common.param('gasPrices', 'txCreation');\n      if (txCreationFee) fee += txCreationFee;\n    }\n    return fee;\n  }\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee() {\n    const txDataZero = this.common.param('gasPrices', 'txDataZero');\n    const txDataNonZero = this.common.param('gasPrices', 'txDataNonZero');\n    let cost = BigInt(0);\n    for (let i = 0; i < this.data.length; i++) {\n      this.data[i] === 0 ? cost += txDataZero : cost += txDataNonZero;\n    }\n    if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {\n      const dataLength = BigInt(Math.ceil(this.data.length / 32));\n      const initCodeCost = this.common.param('gasPrices', 'initCodeWordCost') * dataLength;\n      cost += initCodeCost;\n    }\n    return cost;\n  }\n  /**\n   * If the tx's `to` is to the creation address\n   */\n  toCreationAddress() {\n    return this.to === undefined || this.to.buf.length === 0;\n  }\n  isSigned() {\n    const {\n      v,\n      r,\n      s\n    } = this;\n    if (v === undefined || r === undefined || s === undefined) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n  /**\n   * Determines if the signature is valid\n   */\n  verifySignature() {\n    try {\n      // Main signature verification is done in `getSenderPublicKey()`\n      const publicKey = this.getSenderPublicKey();\n      return (0, util_1.unpadBuffer)(publicKey).length !== 0;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Returns the sender's address\n   */\n  getSenderAddress() {\n    return new util_1.Address((0, util_1.publicToAddress)(this.getSenderPublicKey()));\n  }\n  /**\n   * Signs a transaction.\n   *\n   * Note that the signed tx is returned as a new object,\n   * use as follows:\n   * ```javascript\n   * const signedTx = tx.sign(privateKey)\n   * ```\n   */\n  sign(privateKey) {\n    if (privateKey.length !== 32) {\n      const msg = this._errorMsg('Private key must be 32 bytes in length.');\n      throw new Error(msg);\n    }\n    // Hack for the constellation that we have got a legacy tx after spuriousDragon with a non-EIP155 conforming signature\n    // and want to recreate a signature (where EIP155 should be applied)\n    // Leaving this hack lets the legacy.spec.ts -> sign(), verifySignature() test fail\n    // 2021-06-23\n    let hackApplied = false;\n    if (this.type === 0 && this.common.gteHardfork('spuriousDragon') && !this.supports(types_1.Capability.EIP155ReplayProtection)) {\n      this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);\n      hackApplied = true;\n    }\n    const msgHash = this.getMessageToSign(true);\n    const {\n      v,\n      r,\n      s\n    } = (0, util_1.ecsign)(msgHash, privateKey);\n    const tx = this._processSignature(v, r, s);\n    // Hack part 2\n    if (hackApplied) {\n      const index = this.activeCapabilities.indexOf(types_1.Capability.EIP155ReplayProtection);\n      if (index > -1) {\n        this.activeCapabilities.splice(index, 1);\n      }\n    }\n    return tx;\n  }\n  /**\n   * Does chain ID checks on common and returns a common\n   * to be used on instantiation\n   * @hidden\n   *\n   * @param common - {@link Common} instance from tx options\n   * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)\n   */\n  _getCommon(common, chainId) {\n    // Chain ID provided\n    if (chainId !== undefined) {\n      const chainIdBigInt = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(chainId));\n      if (common) {\n        if (common.chainId() !== chainIdBigInt) {\n          const msg = this._errorMsg('The chain ID does not match the chain ID of Common');\n          throw new Error(msg);\n        }\n        // Common provided, chain ID does match\n        // -> Return provided Common\n        return common.copy();\n      } else {\n        if (common_1.Common.isSupportedChainId(chainIdBigInt)) {\n          // No Common, chain ID supported by Common\n          // -> Instantiate Common with chain ID\n          return new common_1.Common({\n            chain: chainIdBigInt,\n            hardfork: this.DEFAULT_HARDFORK\n          });\n        } else {\n          // No Common, chain ID not supported by Common\n          // -> Instantiate custom Common derived from DEFAULT_CHAIN\n          return common_1.Common.custom({\n            name: 'custom-chain',\n            networkId: chainIdBigInt,\n            chainId: chainIdBigInt\n          }, {\n            baseChain: this.DEFAULT_CHAIN,\n            hardfork: this.DEFAULT_HARDFORK\n          });\n        }\n      }\n    } else {\n      // No chain ID provided\n      // -> return Common provided or create new default Common\n      return common?.copy() ?? new common_1.Common({\n        chain: this.DEFAULT_CHAIN,\n        hardfork: this.DEFAULT_HARDFORK\n      });\n    }\n  }\n  /**\n   * Validates that an object with BigInt values cannot exceed the specified bit limit.\n   * @param values Object containing string keys and BigInt values\n   * @param bits Number of bits to check (64 or 256)\n   * @param cannotEqual Pass true if the number also cannot equal one less the maximum value\n   */\n  _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {\n    for (const [key, value] of Object.entries(values)) {\n      switch (bits) {\n        case 64:\n          if (cannotEqual) {\n            if (value !== undefined && value >= util_1.MAX_UINT64) {\n              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);\n              throw new Error(msg);\n            }\n          } else {\n            if (value !== undefined && value > util_1.MAX_UINT64) {\n              const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);\n              throw new Error(msg);\n            }\n          }\n          break;\n        case 256:\n          if (cannotEqual) {\n            if (value !== undefined && value >= util_1.MAX_INTEGER) {\n              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);\n              throw new Error(msg);\n            }\n          } else {\n            if (value !== undefined && value > util_1.MAX_INTEGER) {\n              const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);\n              throw new Error(msg);\n            }\n          }\n          break;\n        default:\n          {\n            const msg = this._errorMsg('unimplemented bits value');\n            throw new Error(msg);\n          }\n      }\n    }\n  }\n  static _validateNotArray(values) {\n    const txDataKeys = ['nonce', 'gasPrice', 'gasLimit', 'to', 'value', 'data', 'v', 'r', 's', 'type', 'baseFee', 'maxFeePerGas', 'chainId'];\n    for (const [key, value] of Object.entries(values)) {\n      if (txDataKeys.includes(key)) {\n        if (Array.isArray(value)) {\n          throw new Error(`${key} cannot be an array`);\n        }\n      }\n    }\n  }\n  /**\n   * Returns the shared error postfix part for _error() method\n   * tx type implementations.\n   */\n  _getSharedErrorPostfix() {\n    let hash = '';\n    try {\n      hash = this.isSigned() ? (0, util_1.bufferToHex)(this.hash()) : 'not available (unsigned)';\n    } catch (e) {\n      hash = 'error';\n    }\n    let isSigned = '';\n    try {\n      isSigned = this.isSigned().toString();\n    } catch (e) {\n      hash = 'error';\n    }\n    let hf = '';\n    try {\n      hf = this.common.hardfork();\n    } catch (e) {\n      hf = 'error';\n    }\n    let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `;\n    postfix += `signed=${isSigned} hf=${hf}`;\n    return postfix;\n  }\n}\nexports.BaseTransaction = BaseTransaction;","map":{"version":3,"names":["common_1","require","util_1","types_1","util_2","BaseTransaction","constructor","txData","opts","cache","hash","undefined","dataFee","activeCapabilities","DEFAULT_CHAIN","Chain","Mainnet","DEFAULT_HARDFORK","Hardfork","Merge","nonce","gasLimit","to","value","data","v","r","s","type","_type","Number","bufferToBigInt","toBuffer","txOptions","toB","vB","rB","sB","length","Address","_validateCannotExceedMaxInteger","createContract","allowUnlimitedInitCodeSize","common","_getCommon","isActivatedEIP","checkMaxInitCodeSize","supports","capability","includes","validate","stringError","errors","getBaseFee","push","isSigned","verifySignature","_validateYParity","BigInt","msg","_errorMsg","Error","_validateHighS","gteHardfork","SECP256K1_ORDER_DIV_2","txFee","param","fee","getDataFee","toCreationAddress","txCreationFee","txDataZero","txDataNonZero","cost","i","dataLength","Math","ceil","initCodeCost","buf","publicKey","getSenderPublicKey","unpadBuffer","e","getSenderAddress","publicToAddress","sign","privateKey","hackApplied","Capability","EIP155ReplayProtection","msgHash","getMessageToSign","ecsign","tx","_processSignature","index","indexOf","splice","chainId","chainIdBigInt","copy","Common","isSupportedChainId","chain","hardfork","custom","name","networkId","baseChain","values","bits","cannotEqual","key","Object","entries","MAX_UINT64","MAX_INTEGER","_validateNotArray","txDataKeys","Array","isArray","_getSharedErrorPostfix","bufferToHex","toString","hf","postfix","exports"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@ethereumjs/tx/src/baseTransaction.ts"],"sourcesContent":["import { Chain, Common, Hardfork } from '@ethereumjs/common'\nimport {\n  Address,\n  MAX_INTEGER,\n  MAX_UINT64,\n  SECP256K1_ORDER_DIV_2,\n  bufferToBigInt,\n  bufferToHex,\n  ecsign,\n  publicToAddress,\n  toBuffer,\n  unpadBuffer,\n} from '@ethereumjs/util'\n\nimport { Capability } from './types'\nimport { checkMaxInitCodeSize } from './util'\n\nimport type {\n  AccessListEIP2930TxData,\n  AccessListEIP2930ValuesArray,\n  FeeMarketEIP1559TxData,\n  FeeMarketEIP1559ValuesArray,\n  JsonTx,\n  TxData,\n  TxOptions,\n  TxValuesArray,\n} from './types'\nimport type { BigIntLike } from '@ethereumjs/util'\n\ninterface TransactionCache {\n  hash: Buffer | undefined\n  dataFee?: {\n    value: bigint\n    hardfork: string | Hardfork\n  }\n}\n\n/**\n * This base class will likely be subject to further\n * refactoring along the introduction of additional tx types\n * on the Ethereum network.\n *\n * It is therefore not recommended to use directly.\n */\nexport abstract class BaseTransaction<TransactionObject> {\n  private readonly _type: number\n\n  public readonly nonce: bigint\n  public readonly gasLimit: bigint\n  public readonly to?: Address\n  public readonly value: bigint\n  public readonly data: Buffer\n\n  public readonly v?: bigint\n  public readonly r?: bigint\n  public readonly s?: bigint\n\n  public readonly common!: Common\n\n  protected cache: TransactionCache = {\n    hash: undefined,\n    dataFee: undefined,\n  }\n\n  protected readonly txOptions: TxOptions\n\n  /**\n   * List of tx type defining EIPs,\n   * e.g. 1559 (fee market) and 2930 (access lists)\n   * for FeeMarketEIP1559Transaction objects\n   */\n  protected activeCapabilities: number[] = []\n\n  /**\n   * The default chain the tx falls back to if no Common\n   * is provided and if the chain can't be derived from\n   * a passed in chainId (only EIP-2718 typed txs) or\n   * EIP-155 signature (legacy txs).\n   *\n   * @hidden\n   */\n  protected DEFAULT_CHAIN = Chain.Mainnet\n\n  /**\n   * The default HF if the tx type is active on that HF\n   * or the first greater HF where the tx is active.\n   *\n   * @hidden\n   */\n  protected DEFAULT_HARDFORK: string | Hardfork = Hardfork.Merge\n\n  constructor(txData: TxData | AccessListEIP2930TxData | FeeMarketEIP1559TxData, opts: TxOptions) {\n    const { nonce, gasLimit, to, value, data, v, r, s, type } = txData\n    this._type = Number(bufferToBigInt(toBuffer(type)))\n\n    this.txOptions = opts\n\n    const toB = toBuffer(to === '' ? '0x' : to)\n    const vB = toBuffer(v === '' ? '0x' : v)\n    const rB = toBuffer(r === '' ? '0x' : r)\n    const sB = toBuffer(s === '' ? '0x' : s)\n\n    this.nonce = bufferToBigInt(toBuffer(nonce === '' ? '0x' : nonce))\n    this.gasLimit = bufferToBigInt(toBuffer(gasLimit === '' ? '0x' : gasLimit))\n    this.to = toB.length > 0 ? new Address(toB) : undefined\n    this.value = bufferToBigInt(toBuffer(value === '' ? '0x' : value))\n    this.data = toBuffer(data === '' ? '0x' : data)\n\n    this.v = vB.length > 0 ? bufferToBigInt(vB) : undefined\n    this.r = rB.length > 0 ? bufferToBigInt(rB) : undefined\n    this.s = sB.length > 0 ? bufferToBigInt(sB) : undefined\n\n    this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s })\n\n    // geth limits gasLimit to 2^64-1\n    this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64)\n\n    // EIP-2681 limits nonce to 2^64-1 (cannot equal 2^64-1)\n    this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true)\n\n    const createContract = this.to === undefined || this.to === null\n    const allowUnlimitedInitCodeSize = opts.allowUnlimitedInitCodeSize ?? false\n    const common = opts.common ?? this._getCommon()\n    if (createContract && common.isActivatedEIP(3860) && allowUnlimitedInitCodeSize === false) {\n      checkMaxInitCodeSize(common, this.data.length)\n    }\n  }\n\n  /**\n   * Returns the transaction type.\n   *\n   * Note: legacy txs will return tx type `0`.\n   */\n  get type() {\n    return this._type\n  }\n\n  /**\n   * Checks if a tx type defining capability is active\n   * on a tx, for example the EIP-1559 fee market mechanism\n   * or the EIP-2930 access list feature.\n   *\n   * Note that this is different from the tx type itself,\n   * so EIP-2930 access lists can very well be active\n   * on an EIP-1559 tx for example.\n   *\n   * This method can be useful for feature checks if the\n   * tx type is unknown (e.g. when instantiated with\n   * the tx factory).\n   *\n   * See `Capabilites` in the `types` module for a reference\n   * on all supported capabilities.\n   */\n  supports(capability: Capability) {\n    return this.activeCapabilities.includes(capability)\n  }\n\n  /**\n   * Checks if the transaction has the minimum amount of gas required\n   * (DataFee + TxFee + Creation Fee).\n   */\n  validate(): boolean\n  validate(stringError: false): boolean\n  validate(stringError: true): string[]\n  validate(stringError: boolean = false): boolean | string[] {\n    const errors = []\n\n    if (this.getBaseFee() > this.gasLimit) {\n      errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`)\n    }\n\n    if (this.isSigned() && !this.verifySignature()) {\n      errors.push('Invalid Signature')\n    }\n\n    return stringError ? errors : errors.length === 0\n  }\n\n  protected _validateYParity() {\n    const { v } = this\n    if (v !== undefined && v !== BigInt(0) && v !== BigInt(1)) {\n      const msg = this._errorMsg('The y-parity of the transaction should either be 0 or 1')\n      throw new Error(msg)\n    }\n  }\n\n  /**\n   * EIP-2: All transaction signatures whose s-value is greater than secp256k1n/2are considered invalid.\n   * Reasoning: https://ethereum.stackexchange.com/a/55728\n   */\n  protected _validateHighS() {\n    const { s } = this\n    if (this.common.gteHardfork('homestead') && s !== undefined && s > SECP256K1_ORDER_DIV_2) {\n      const msg = this._errorMsg(\n        'Invalid Signature: s-values greater than secp256k1n/2 are considered invalid'\n      )\n      throw new Error(msg)\n    }\n  }\n\n  /**\n   * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)\n   */\n  getBaseFee(): bigint {\n    const txFee = this.common.param('gasPrices', 'tx')\n    let fee = this.getDataFee()\n    if (txFee) fee += txFee\n    if (this.common.gteHardfork('homestead') && this.toCreationAddress()) {\n      const txCreationFee = this.common.param('gasPrices', 'txCreation')\n      if (txCreationFee) fee += txCreationFee\n    }\n    return fee\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    const txDataZero = this.common.param('gasPrices', 'txDataZero')\n    const txDataNonZero = this.common.param('gasPrices', 'txDataNonZero')\n\n    let cost = BigInt(0)\n    for (let i = 0; i < this.data.length; i++) {\n      this.data[i] === 0 ? (cost += txDataZero) : (cost += txDataNonZero)\n    }\n\n    if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {\n      const dataLength = BigInt(Math.ceil(this.data.length / 32))\n      const initCodeCost = this.common.param('gasPrices', 'initCodeWordCost') * dataLength\n      cost += initCodeCost\n    }\n\n    return cost\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  abstract getUpfrontCost(): bigint\n\n  /**\n   * If the tx's `to` is to the creation address\n   */\n  toCreationAddress(): boolean {\n    return this.to === undefined || this.to.buf.length === 0\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of this transaction, in order.\n   *\n   * Use {@link BaseTransaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link BaseTransaction.getMessageToSign}.\n   */\n  abstract raw(): TxValuesArray | AccessListEIP2930ValuesArray | FeeMarketEIP1559ValuesArray\n\n  /**\n   * Returns the encoding of the transaction.\n   */\n  abstract serialize(): Buffer\n\n  // Returns the unsigned tx (hashed or raw), which is used to sign the transaction.\n  //\n  // Note: do not use code docs here since VS Studio is then not able to detect the\n  // comments from the inherited methods\n  abstract getMessageToSign(hashMessage: false): Buffer | Buffer[]\n  abstract getMessageToSign(hashMessage?: true): Buffer\n\n  abstract hash(): Buffer\n\n  abstract getMessageToVerifySignature(): Buffer\n\n  public isSigned(): boolean {\n    const { v, r, s } = this\n    if (v === undefined || r === undefined || s === undefined) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * Determines if the signature is valid\n   */\n  verifySignature(): boolean {\n    try {\n      // Main signature verification is done in `getSenderPublicKey()`\n      const publicKey = this.getSenderPublicKey()\n      return unpadBuffer(publicKey).length !== 0\n    } catch (e: any) {\n      return false\n    }\n  }\n\n  /**\n   * Returns the sender's address\n   */\n  getSenderAddress(): Address {\n    return new Address(publicToAddress(this.getSenderPublicKey()))\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  abstract getSenderPublicKey(): Buffer\n\n  /**\n   * Signs a transaction.\n   *\n   * Note that the signed tx is returned as a new object,\n   * use as follows:\n   * ```javascript\n   * const signedTx = tx.sign(privateKey)\n   * ```\n   */\n  sign(privateKey: Buffer): TransactionObject {\n    if (privateKey.length !== 32) {\n      const msg = this._errorMsg('Private key must be 32 bytes in length.')\n      throw new Error(msg)\n    }\n\n    // Hack for the constellation that we have got a legacy tx after spuriousDragon with a non-EIP155 conforming signature\n    // and want to recreate a signature (where EIP155 should be applied)\n    // Leaving this hack lets the legacy.spec.ts -> sign(), verifySignature() test fail\n    // 2021-06-23\n    let hackApplied = false\n    if (\n      this.type === 0 &&\n      this.common.gteHardfork('spuriousDragon') &&\n      !this.supports(Capability.EIP155ReplayProtection)\n    ) {\n      this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n      hackApplied = true\n    }\n\n    const msgHash = this.getMessageToSign(true)\n    const { v, r, s } = ecsign(msgHash, privateKey)\n    const tx = this._processSignature(v, r, s)\n\n    // Hack part 2\n    if (hackApplied) {\n      const index = this.activeCapabilities.indexOf(Capability.EIP155ReplayProtection)\n      if (index > -1) {\n        this.activeCapabilities.splice(index, 1)\n      }\n    }\n\n    return tx\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  abstract toJSON(): JsonTx\n\n  // Accept the v,r,s values from the `sign` method, and convert this into a TransactionObject\n  protected abstract _processSignature(v: bigint, r: Buffer, s: Buffer): TransactionObject\n\n  /**\n   * Does chain ID checks on common and returns a common\n   * to be used on instantiation\n   * @hidden\n   *\n   * @param common - {@link Common} instance from tx options\n   * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)\n   */\n  protected _getCommon(common?: Common, chainId?: BigIntLike) {\n    // Chain ID provided\n    if (chainId !== undefined) {\n      const chainIdBigInt = bufferToBigInt(toBuffer(chainId))\n      if (common) {\n        if (common.chainId() !== chainIdBigInt) {\n          const msg = this._errorMsg('The chain ID does not match the chain ID of Common')\n          throw new Error(msg)\n        }\n        // Common provided, chain ID does match\n        // -> Return provided Common\n        return common.copy()\n      } else {\n        if (Common.isSupportedChainId(chainIdBigInt)) {\n          // No Common, chain ID supported by Common\n          // -> Instantiate Common with chain ID\n          return new Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK })\n        } else {\n          // No Common, chain ID not supported by Common\n          // -> Instantiate custom Common derived from DEFAULT_CHAIN\n          return Common.custom(\n            {\n              name: 'custom-chain',\n              networkId: chainIdBigInt,\n              chainId: chainIdBigInt,\n            },\n            { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK }\n          )\n        }\n      }\n    } else {\n      // No chain ID provided\n      // -> return Common provided or create new default Common\n      return (\n        common?.copy() ?? new Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK })\n      )\n    }\n  }\n\n  /**\n   * Validates that an object with BigInt values cannot exceed the specified bit limit.\n   * @param values Object containing string keys and BigInt values\n   * @param bits Number of bits to check (64 or 256)\n   * @param cannotEqual Pass true if the number also cannot equal one less the maximum value\n   */\n  protected _validateCannotExceedMaxInteger(\n    values: { [key: string]: bigint | undefined },\n    bits = 256,\n    cannotEqual = false\n  ) {\n    for (const [key, value] of Object.entries(values)) {\n      switch (bits) {\n        case 64:\n          if (cannotEqual) {\n            if (value !== undefined && value >= MAX_UINT64) {\n              const msg = this._errorMsg(\n                `${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          } else {\n            if (value !== undefined && value > MAX_UINT64) {\n              const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`)\n              throw new Error(msg)\n            }\n          }\n          break\n        case 256:\n          if (cannotEqual) {\n            if (value !== undefined && value >= MAX_INTEGER) {\n              const msg = this._errorMsg(\n                `${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          } else {\n            if (value !== undefined && value > MAX_INTEGER) {\n              const msg = this._errorMsg(\n                `${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          }\n          break\n        default: {\n          const msg = this._errorMsg('unimplemented bits value')\n          throw new Error(msg)\n        }\n      }\n    }\n  }\n\n  protected static _validateNotArray(values: { [key: string]: any }) {\n    const txDataKeys = [\n      'nonce',\n      'gasPrice',\n      'gasLimit',\n      'to',\n      'value',\n      'data',\n      'v',\n      'r',\n      's',\n      'type',\n      'baseFee',\n      'maxFeePerGas',\n      'chainId',\n    ]\n    for (const [key, value] of Object.entries(values)) {\n      if (txDataKeys.includes(key)) {\n        if (Array.isArray(value)) {\n          throw new Error(`${key} cannot be an array`)\n        }\n      }\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public abstract errorStr(): string\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected abstract _errorMsg(msg: string): string\n\n  /**\n   * Returns the shared error postfix part for _error() method\n   * tx type implementations.\n   */\n  protected _getSharedErrorPostfix() {\n    let hash = ''\n    try {\n      hash = this.isSigned() ? bufferToHex(this.hash()) : 'not available (unsigned)'\n    } catch (e: any) {\n      hash = 'error'\n    }\n    let isSigned = ''\n    try {\n      isSigned = this.isSigned().toString()\n    } catch (e: any) {\n      hash = 'error'\n    }\n    let hf = ''\n    try {\n      hf = this.common.hardfork()\n    } catch (e: any) {\n      hf = 'error'\n    }\n\n    let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `\n    postfix += `signed=${isSigned} hf=${hf}`\n\n    return postfix\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}