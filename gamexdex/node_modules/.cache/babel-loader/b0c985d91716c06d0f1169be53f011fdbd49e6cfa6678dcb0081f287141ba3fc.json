{"ast":null,"code":"import { CHAIN_NAMESPACES, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, WalletInitializationError, ADAPTER_EVENTS, log, Web3AuthError, WalletLoginError, WalletOperationsError } from '@web3auth/base';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport SignClient from '@walletconnect/sign-client';\nimport { getSdkError, isValidArray } from '@walletconnect/utils';\nimport { BaseEvmAdapter } from '@web3auth/base-evm-adapter';\nimport { WalletConnectV2Provider } from '@web3auth/ethereum-provider';\nimport merge from 'lodash.merge';\nconst WALLET_CONNECT_EXTENSION_ADAPTERS = [{\n  name: \"Argent\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-argent.svg\",\n  mobile: {\n    native: \"argent://\",\n    universal: \"https://www.argent.xyz/app\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}, {\n  name: \"Trust Wallet\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-trust.svg\",\n  mobile: {\n    native: \"trust:\",\n    universal: \"https://link.trustwallet.com\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}, {\n  name: \"Zerion\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-zerion.svg\",\n  mobile: {\n    native: \"zerion://\",\n    universal: \"https://wallet.zerion.io\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}];\nvar DEFAULT_EIP155_METHODS;\n(function (DEFAULT_EIP155_METHODS) {\n  DEFAULT_EIP155_METHODS[\"ETH_SEND_TRANSACTION\"] = \"eth_sendTransaction\";\n  DEFAULT_EIP155_METHODS[\"ETH_SIGN\"] = \"eth_sign\";\n  DEFAULT_EIP155_METHODS[\"PERSONAL_SIGN\"] = \"personal_sign\";\n  DEFAULT_EIP155_METHODS[\"ETH_SIGN_TYPED_DATA\"] = \"eth_signTypedData\";\n})(DEFAULT_EIP155_METHODS || (DEFAULT_EIP155_METHODS = {}));\nvar DEFAULT_EIP_155_EVENTS;\n(function (DEFAULT_EIP_155_EVENTS) {\n  DEFAULT_EIP_155_EVENTS[\"ETH_CHAIN_CHANGED\"] = \"chainChanged\";\n  DEFAULT_EIP_155_EVENTS[\"ETH_ACCOUNTS_CHANGED\"] = \"accountsChanged\";\n})(DEFAULT_EIP_155_EVENTS || (DEFAULT_EIP_155_EVENTS = {}));\n/**\n * Extracts a name for the site from the DOM\n */\nconst getSiteName = window => {\n  const {\n    document\n  } = window;\n  const siteName = document.querySelector('head > meta[property=\"og:site_name\"]');\n  if (siteName) {\n    return siteName.content;\n  }\n  const metaTitle = document.querySelector('head > meta[name=\"title\"]');\n  if (metaTitle) {\n    return metaTitle.content;\n  }\n  if (document.title && document.title.length > 0) {\n    return document.title;\n  }\n  return window.location.hostname;\n};\n/**\n * Returns whether the given image URL exists\n * @param url - the url of the image\n * @returns - whether the image exists\n */\nfunction imgExists(url) {\n  return new Promise((resolve, reject) => {\n    try {\n      const img = document.createElement(\"img\");\n      img.onload = () => resolve(true);\n      img.onerror = () => resolve(false);\n      img.src = url;\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n/**\n * Extracts an icon for the site from the DOM\n */\nasync function getSiteIcon(window) {\n  const {\n    document\n  } = window;\n  // Use the site's favicon if it exists\n  let icon = document.querySelector('head > link[rel=\"shortcut icon\"]');\n  if (icon && (await imgExists(icon.href))) {\n    return icon.href;\n  }\n  // Search through available icons in no particular order\n  icon = Array.from(document.querySelectorAll('head > link[rel=\"icon\"]')).find(_icon => Boolean(_icon.href)) || null;\n  if (icon && (await imgExists(icon.href))) {\n    return icon.href;\n  }\n  return null;\n}\n/**\n * Gets site metadata and returns it\n *\n */\nconst getSiteMetadata = async () => ({\n  name: getSiteName(window),\n  icon: await getSiteIcon(window)\n});\nconst getNamespacesFromChains = chains => {\n  const supportedNamespaces = [];\n  chains.forEach(chainId => {\n    const [namespace] = chainId.split(\":\");\n    if (!supportedNamespaces.includes(namespace)) {\n      supportedNamespaces.push(namespace);\n    }\n  });\n  return supportedNamespaces;\n};\nconst getSupportedMethodsByNamespace = namespace => {\n  switch (namespace) {\n    case CHAIN_NAMESPACES.EIP155:\n      return Object.values(DEFAULT_EIP155_METHODS);\n    default:\n      throw new Error(`No default methods for namespace: ${namespace}`);\n  }\n};\nconst getSupportedEventsByNamespace = namespace => {\n  switch (namespace) {\n    case CHAIN_NAMESPACES.EIP155:\n      return Object.values(DEFAULT_EIP_155_EVENTS);\n    default:\n      throw new Error(`No default events for namespace: ${namespace}`);\n  }\n};\nconst getRequiredNamespaces = chains => {\n  const selectedNamespaces = getNamespacesFromChains(chains);\n  return Object.fromEntries(selectedNamespaces.map(namespace => [namespace, {\n    methods: getSupportedMethodsByNamespace(namespace),\n    chains: chains.filter(chain => chain.startsWith(namespace)),\n    events: getSupportedEventsByNamespace(namespace)\n  }]));\n};\nconst getWalletConnectV2Settings = async (namespace, chainIds, projectID) => {\n  if (namespace === CHAIN_NAMESPACES.EIP155) {\n    const appMetadata = await getSiteMetadata();\n    const adapterSettings = {\n      walletConnectInitOptions: {\n        projectId: projectID,\n        relayUrl: \"wss://relay.walletconnect.com\",\n        metadata: {\n          name: appMetadata.name,\n          description: appMetadata.name,\n          url: window.location.origin,\n          icons: [appMetadata.icon || \"\"]\n        }\n      }\n    };\n    const chainNamespaces = chainIds.map(chainId => {\n      return `${namespace}:${chainId}`;\n    });\n    const loginSettings = {\n      requiredNamespaces: getRequiredNamespaces(chainNamespaces)\n    };\n    return {\n      adapterSettings,\n      loginSettings\n    };\n  }\n  throw new Error(`Unsupported chain namespace: ${namespace}`);\n};\nconst isChainIdSupported = (chainNamespace, chainID, loginSettings) => {\n  var _supportedNamespaces$, _supportedNamespaces$2;\n  const supportedNamespaces = (loginSettings === null || loginSettings === void 0 ? void 0 : loginSettings.requiredNamespaces) || {};\n  const wcChainNamespace = `${chainNamespace}:${chainID}`;\n  if (!supportedNamespaces[chainNamespace].chains || ((_supportedNamespaces$ = supportedNamespaces[chainNamespace].chains) === null || _supportedNamespaces$ === void 0 ? void 0 : _supportedNamespaces$.length) === 0) {\n    return false;\n  }\n  const isSupported = (_supportedNamespaces$2 = supportedNamespaces[chainNamespace].chains) === null || _supportedNamespaces$2 === void 0 ? void 0 : _supportedNamespaces$2.includes(wcChainNamespace);\n  return !!isSupported;\n};\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass WalletConnectV2Adapter extends BaseEvmAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V2);\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n    _defineProperty(this, \"adapterOptions\", void 0);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\",\n      extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n    });\n    _defineProperty(this, \"connector\", null);\n    _defineProperty(this, \"activeSession\", null);\n    _defineProperty(this, \"wcProvider\", null);\n    this.adapterOptions = _objectSpread({}, options);\n  }\n  get connected() {\n    return !!this.activeSession;\n  }\n  get provider() {\n    if (this.status !== ADAPTER_STATUS.NOT_READY && this.wcProvider) {\n      return this.wcProvider.provider;\n    }\n    return null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init(options) {\n    var _this$adapterOptions$, _this$chainConfig, _this$chainConfig2;\n    await super.init();\n    super.checkInitializationRequirements();\n    const projectId = (_this$adapterOptions$ = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$ === void 0 || (_this$adapterOptions$ = _this$adapterOptions$.walletConnectInitOptions) === null || _this$adapterOptions$ === void 0 ? void 0 : _this$adapterOptions$.projectId;\n    if (!projectId) {\n      throw WalletInitializationError.invalidParams(\"Wallet connect project id is required in wallet connect v2 adapter\");\n    }\n    const wc2Settings = await getWalletConnectV2Settings((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainNamespace, [parseInt((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId, 16)], projectId);\n    if (!this.adapterOptions.loginSettings) {\n      this.adapterOptions.loginSettings = wc2Settings.loginSettings;\n    }\n    this.adapterOptions.adapterSettings = merge(wc2Settings.adapterSettings, this.adapterOptions.adapterSettings);\n    const {\n      adapterSettings\n    } = this.adapterOptions;\n    this.connector = await SignClient.init(adapterSettings === null || adapterSettings === void 0 ? void 0 : adapterSettings.walletConnectInitOptions);\n    this.wcProvider = new WalletConnectV2Provider({\n      config: {\n        chainConfig: this.chainConfig\n      },\n      connector: this.connector\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V2);\n    this.status = ADAPTER_STATUS.READY;\n    log.debug(\"initializing wallet connect v2 adapter\");\n    if (options.autoConnect) {\n      await this.checkForPersistedSession();\n      if (this.connected) {\n        this.rehydrated = true;\n        try {\n          await this.onConnectHandler();\n        } catch (error) {\n          log.error(\"wallet auto connect\", error);\n          this.emit(ADAPTER_EVENTS.ERRORED, error);\n        }\n      } else {\n        this.status = ADAPTER_STATUS.NOT_READY;\n        this.emit(ADAPTER_EVENTS.CACHE_CLEAR);\n      }\n    }\n  }\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    try {\n      // if already connected\n      if (this.connected) {\n        await this.onConnectHandler();\n        return this.provider;\n      }\n      if (this.status !== ADAPTER_STATUS.CONNECTING) {\n        await this.createNewSession();\n      }\n      return this.provider;\n    } catch (error) {\n      log.error(\"Wallet connect v2 adapter error while connecting\", error);\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = true;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      const finalError = error instanceof Web3AuthError ? error : WalletLoginError.connectionError(`Failed to login with wallet connect: ${(error === null || error === void 0 ? void 0 : error.message) || \"\"}`);\n      throw finalError;\n    }\n  }\n  async addChain(chainConfig) {\n    var _this$wcProvider;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkAddChainRequirements(chainConfig, init);\n    if (!isChainIdSupported(this.currentChainNamespace, parseInt(chainConfig.chainId, 16), this.adapterOptions.loginSettings)) {\n      throw WalletOperationsError.chainIDNotAllowed(`Unsupported chainID: ${chainConfig.chainId}`);\n    }\n    await ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.addChain(chainConfig));\n    this.addChainConfig(chainConfig);\n  }\n  async switchChain(params) {\n    var _this$wcProvider2;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.checkSwitchChainRequirements(params, init);\n    if (!isChainIdSupported(this.currentChainNamespace, parseInt(params.chainId, 16), this.adapterOptions.loginSettings)) {\n      throw WalletOperationsError.chainIDNotAllowed(`Unsupported chainID: ${params.chainId}`);\n    }\n    await ((_this$wcProvider2 = this.wcProvider) === null || _this$wcProvider2 === void 0 ? void 0 : _this$wcProvider2.switchChain({\n      chainId: params.chainId\n    }));\n    this.setAdapterSettings({\n      chainConfig: this.getChainConfig(params.chainId)\n    });\n  }\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n  async disconnect() {\n    var _this$activeSession, _this$activeSession2;\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    await super.disconnectSession();\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected || !((_this$activeSession = this.activeSession) !== null && _this$activeSession !== void 0 && _this$activeSession.topic)) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.disconnect({\n      topic: (_this$activeSession2 = this.activeSession) === null || _this$activeSession2 === void 0 ? void 0 : _this$activeSession2.topic,\n      reason: getSdkError(\"USER_DISCONNECTED\")\n    });\n    this.rehydrated = false;\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n    this.activeSession = null;\n    await super.disconnect();\n  }\n  cleanupPendingPairings() {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const inactivePairings = this.connector.pairing.getAll({\n      active: false\n    });\n    if (!isValidArray(inactivePairings)) return;\n    inactivePairings.forEach(pairing => {\n      if (this.connector) {\n        this.connector.pairing.delete(pairing.topic, getSdkError(\"USER_DISCONNECTED\"));\n      }\n    });\n  }\n  async checkForPersistedSession() {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (this.connector.session.length) {\n      const lastKeyIndex = this.connector.session.keys.length - 1;\n      this.activeSession = this.connector.session.get(this.connector.session.keys[lastKeyIndex]);\n    }\n    return this.activeSession;\n  }\n  async createNewSession() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    try {\n      var _this$activeSession3, _this$adapterOptions;\n      if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n      if (!this.adapterOptions.loginSettings) throw WalletInitializationError.notReady(\"login settings are not set yet\");\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V2\n      });\n      if (opts.forceNewSession && (_this$activeSession3 = this.activeSession) !== null && _this$activeSession3 !== void 0 && _this$activeSession3.topic) {\n        var _this$activeSession4;\n        await this.connector.disconnect({\n          topic: (_this$activeSession4 = this.activeSession) === null || _this$activeSession4 === void 0 ? void 0 : _this$activeSession4.topic,\n          reason: getSdkError(\"USER_DISCONNECTED\")\n        });\n      }\n      log.debug(\"creating new session for web3auth wallet connect\");\n      const {\n        uri,\n        approval\n      } = await this.connector.connect(this.adapterOptions.loginSettings);\n      const qrcodeModal = (_this$adapterOptions = this.adapterOptions) === null || _this$adapterOptions === void 0 || (_this$adapterOptions = _this$adapterOptions.adapterSettings) === null || _this$adapterOptions === void 0 ? void 0 : _this$adapterOptions.qrcodeModal;\n      // Open QRCode modal if a URI was returned (i.e. we're not connecting with an existing pairing).\n      if (uri) {\n        if (qrcodeModal) {\n          qrcodeModal.open(uri, () => {\n            log.debug(\"EVENT\", \"QR Code Modal closed\");\n            this.status = ADAPTER_STATUS.READY;\n            this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V2);\n          });\n        } else {\n          this.updateAdapterData({\n            uri,\n            extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n          });\n        }\n      }\n      // Await session approval from the wallet.\n      const session = await approval();\n      this.activeSession = session;\n      // Handle the returned session (e.g. update UI to \"connected\" state).\n      await this.onConnectHandler();\n      if (qrcodeModal) {\n        qrcodeModal.close();\n      }\n    } catch (error) {\n      log.error(\"error while creating new wallet connect session\", error);\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw error;\n    }\n  }\n  async onConnectHandler() {\n    var _this$adapterOptions$2;\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    if ((_this$adapterOptions$2 = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$2 !== void 0 && _this$adapterOptions$2.qrcodeModal) {\n      this.wcProvider = new WalletConnectV2Provider({\n        config: {\n          chainConfig: this.chainConfig,\n          skipLookupNetwork: true\n        },\n        connector: this.connector\n      });\n    }\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents();\n    this.cleanupPendingPairings();\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V2,\n      reconnected: this.rehydrated\n    });\n  }\n  subscribeEvents() {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    this.connector.on(\"session_update\", _ref => {\n      let {\n        topic,\n        params\n      } = _ref;\n      if (!this.connector) return;\n      const {\n        namespaces\n      } = params;\n      const _session = this.connector.session.get(topic);\n      // Overwrite the `namespaces` of the existing session with the incoming one.\n      const updatedSession = _objectSpread(_objectSpread({}, _session), {}, {\n        namespaces\n      });\n      // Integrate the updated session state into your dapp state.\n      this.activeSession = updatedSession;\n    });\n    this.connector.events.on(\"session_delete\", () => {\n      // Session was deleted -> reset the dapp state, clean up from user session, etc.\n      this.disconnect();\n    });\n  }\n}\nexport { DEFAULT_EIP155_METHODS, DEFAULT_EIP_155_EVENTS, WALLET_CONNECT_EXTENSION_ADAPTERS, WalletConnectV2Adapter, getNamespacesFromChains, getRequiredNamespaces, getSupportedEventsByNamespace, getSupportedMethodsByNamespace, getWalletConnectV2Settings };","map":{"version":3,"names":["WALLET_CONNECT_EXTENSION_ADAPTERS","name","chains","CHAIN_NAMESPACES","EIP155","logo","mobile","native","universal","desktop","DEFAULT_EIP155_METHODS","DEFAULT_EIP_155_EVENTS","getSiteName","window","document","siteName","querySelector","content","metaTitle","title","length","location","hostname","imgExists","url","Promise","resolve","reject","img","createElement","onload","onerror","src","e","getSiteIcon","icon","href","Array","from","querySelectorAll","find","_icon","Boolean","getSiteMetadata","getNamespacesFromChains","supportedNamespaces","forEach","chainId","namespace","split","includes","push","getSupportedMethodsByNamespace","Object","values","Error","getSupportedEventsByNamespace","getRequiredNamespaces","selectedNamespaces","fromEntries","map","methods","filter","chain","startsWith","events","getWalletConnectV2Settings","chainIds","projectID","appMetadata","adapterSettings","walletConnectInitOptions","projectId","relayUrl","metadata","description","origin","icons","chainNamespaces","loginSettings","requiredNamespaces","isChainIdSupported","chainNamespace","chainID","_supportedNamespaces$","_supportedNamespaces$2","wcChainNamespace","isSupported","WalletConnectV2Adapter","BaseEvmAdapter","constructor","options","arguments","undefined","_defineProperty","WALLET_ADAPTERS","WALLET_CONNECT_V2","ADAPTER_NAMESPACES","ADAPTER_CATEGORY","EXTERNAL","ADAPTER_STATUS","NOT_READY","uri","extensionAdapters","adapterOptions","_objectSpread","connected","activeSession","provider","status","wcProvider","_","init","_this$adapterOptions$","_this$chainConfig","_this$chainConfig2","checkInitializationRequirements","WalletInitializationError","invalidParams","wc2Settings","chainConfig","parseInt","merge","connector","SignClient","WalletConnectV2Provider","config","emit","ADAPTER_EVENTS","READY","log","debug","autoConnect","checkForPersistedSession","rehydrated","onConnectHandler","error","ERRORED","CACHE_CLEAR","connect","checkConnectionRequirements","notReady","CONNECTING","createNewSession","finalError","Web3AuthError","WalletLoginError","connectionError","message","addChain","_this$wcProvider","checkAddChainRequirements","currentChainNamespace","WalletOperationsError","chainIDNotAllowed","addChainConfig","switchChain","params","_this$wcProvider2","checkSwitchChainRequirements","setAdapterSettings","getChainConfig","getUserInfo","notConnectedError","disconnect","_this$activeSession","_this$activeSession2","cleanup","disconnectSession","topic","reason","getSdkError","cleanupPendingPairings","inactivePairings","pairing","getAll","active","isValidArray","delete","session","lastKeyIndex","keys","get","opts","forceNewSession","_this$activeSession3","_this$adapterOptions","adapter","_this$activeSession4","approval","qrcodeModal","open","updateAdapterData","close","_this$adapterOptions$2","skipLookupNetwork","setupProvider","subscribeEvents","CONNECTED","reconnected","on","_ref","namespaces","_session","updatedSession"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/wallet-connect-v2-adapter/src/config.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/wallet-connect-v2-adapter/src/utils.ts","/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@web3auth/wallet-connect-v2-adapter/src/walletConnectV2adapter.ts"],"sourcesContent":["import type { EngineTypes, ProposalTypes } from \"@walletconnect/types\";\nimport { CHAIN_NAMESPACES, ChainNamespaceType, IWalletConnectExtensionAdapter } from \"@web3auth/base\";\n\nimport { IAdapterSettings } from \"./interface\";\n\nexport const WALLET_CONNECT_EXTENSION_ADAPTERS: IWalletConnectExtensionAdapter[] = [\n  {\n    name: \"Argent\",\n    chains: [CHAIN_NAMESPACES.EIP155],\n    logo: \"https://images.web3auth.io/login-argent.svg\",\n    mobile: {\n      native: \"argent://\",\n      universal: \"https://www.argent.xyz/app\",\n    },\n    desktop: {\n      native: \"\",\n      universal: \"\",\n    },\n  },\n  {\n    name: \"Trust Wallet\",\n    chains: [CHAIN_NAMESPACES.EIP155],\n    logo: \"https://images.web3auth.io/login-trust.svg\",\n    mobile: {\n      native: \"trust:\",\n      universal: \"https://link.trustwallet.com\",\n    },\n    desktop: {\n      native: \"\",\n      universal: \"\",\n    },\n  },\n  {\n    name: \"Zerion\",\n    chains: [CHAIN_NAMESPACES.EIP155],\n    logo: \"https://images.web3auth.io/login-zerion.svg\",\n    mobile: {\n      native: \"zerion://\",\n      universal: \"https://wallet.zerion.io\",\n    },\n    desktop: {\n      native: \"\",\n      universal: \"\",\n    },\n  },\n];\n\nexport enum DEFAULT_EIP155_METHODS {\n  ETH_SEND_TRANSACTION = \"eth_sendTransaction\",\n  ETH_SIGN = \"eth_sign\",\n  PERSONAL_SIGN = \"personal_sign\",\n  ETH_SIGN_TYPED_DATA = \"eth_signTypedData\",\n}\n\nexport enum DEFAULT_EIP_155_EVENTS {\n  ETH_CHAIN_CHANGED = \"chainChanged\",\n  ETH_ACCOUNTS_CHANGED = \"accountsChanged\",\n}\n\n/**\n * Extracts a name for the site from the DOM\n */\nconst getSiteName = (window: Window) => {\n  const { document } = window;\n\n  const siteName = document.querySelector<HTMLMetaElement>('head > meta[property=\"og:site_name\"]');\n  if (siteName) {\n    return siteName.content;\n  }\n\n  const metaTitle = document.querySelector<HTMLMetaElement>('head > meta[name=\"title\"]');\n  if (metaTitle) {\n    return metaTitle.content;\n  }\n\n  if (document.title && document.title.length > 0) {\n    return document.title;\n  }\n\n  return window.location.hostname;\n};\n\n/**\n * Returns whether the given image URL exists\n * @param url - the url of the image\n * @returns - whether the image exists\n */\nfunction imgExists(url: string): Promise<boolean> {\n  return new Promise((resolve, reject) => {\n    try {\n      const img = document.createElement(\"img\");\n      img.onload = () => resolve(true);\n      img.onerror = () => resolve(false);\n      img.src = url;\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n/**\n * Extracts an icon for the site from the DOM\n */\nasync function getSiteIcon(window: Window): Promise<string | null> {\n  const { document } = window;\n\n  // Use the site's favicon if it exists\n  let icon = document.querySelector<HTMLLinkElement>('head > link[rel=\"shortcut icon\"]');\n  if (icon && (await imgExists(icon.href))) {\n    return icon.href;\n  }\n\n  // Search through available icons in no particular order\n  icon = Array.from(document.querySelectorAll<HTMLLinkElement>('head > link[rel=\"icon\"]')).find((_icon) => Boolean(_icon.href)) || null;\n  if (icon && (await imgExists(icon.href))) {\n    return icon.href;\n  }\n\n  return null;\n}\n\n/**\n * Gets site metadata and returns it\n *\n */\nconst getSiteMetadata = async () => ({\n  name: getSiteName(window),\n  icon: await getSiteIcon(window),\n});\n\nexport const getNamespacesFromChains = (chains: string[]) => {\n  const supportedNamespaces: string[] = [];\n  chains.forEach((chainId) => {\n    const [namespace] = chainId.split(\":\");\n    if (!supportedNamespaces.includes(namespace)) {\n      supportedNamespaces.push(namespace);\n    }\n  });\n\n  return supportedNamespaces;\n};\n\nexport const getSupportedMethodsByNamespace = (namespace: string) => {\n  switch (namespace) {\n    case CHAIN_NAMESPACES.EIP155:\n      return Object.values(DEFAULT_EIP155_METHODS);\n    default:\n      throw new Error(`No default methods for namespace: ${namespace}`);\n  }\n};\n\nexport const getSupportedEventsByNamespace = (namespace: string) => {\n  switch (namespace) {\n    case CHAIN_NAMESPACES.EIP155:\n      return Object.values(DEFAULT_EIP_155_EVENTS);\n    default:\n      throw new Error(`No default events for namespace: ${namespace}`);\n  }\n};\nexport const getRequiredNamespaces = (chains: string[]): ProposalTypes.RequiredNamespaces => {\n  const selectedNamespaces = getNamespacesFromChains(chains);\n\n  return Object.fromEntries(\n    selectedNamespaces.map((namespace) => [\n      namespace,\n      {\n        methods: getSupportedMethodsByNamespace(namespace),\n        chains: chains.filter((chain) => chain.startsWith(namespace)),\n        events: getSupportedEventsByNamespace(namespace) as any[],\n      },\n    ])\n  );\n};\n\nexport const getWalletConnectV2Settings = async (\n  namespace: ChainNamespaceType,\n  chainIds: number[],\n  projectID: string\n): Promise<{\n  adapterSettings: IAdapterSettings;\n  loginSettings: EngineTypes.ConnectParams;\n}> => {\n  if (namespace === CHAIN_NAMESPACES.EIP155) {\n    const appMetadata = await getSiteMetadata();\n    const adapterSettings: IAdapterSettings = {\n      walletConnectInitOptions: {\n        projectId: projectID,\n        relayUrl: \"wss://relay.walletconnect.com\",\n        metadata: {\n          name: appMetadata.name,\n          description: appMetadata.name,\n          url: window.location.origin,\n          icons: [appMetadata.icon || \"\"],\n        },\n      },\n    };\n\n    const chainNamespaces = chainIds.map((chainId) => {\n      return `${namespace}:${chainId}`;\n    });\n\n    const loginSettings: EngineTypes.ConnectParams = {\n      requiredNamespaces: getRequiredNamespaces(chainNamespaces),\n    };\n    return {\n      adapterSettings,\n      loginSettings,\n    };\n  }\n  throw new Error(`Unsupported chain namespace: ${namespace}`);\n};\n","import type { EngineTypes } from \"@walletconnect/types\";\nimport type { ChainNamespaceType } from \"@web3auth/base\";\n\nexport const isChainIdSupported = (chainNamespace: ChainNamespaceType, chainID: number, loginSettings: EngineTypes.ConnectParams | undefined) => {\n  const supportedNamespaces = loginSettings?.requiredNamespaces || {};\n  const wcChainNamespace = `${chainNamespace}:${chainID}`;\n\n  if (!supportedNamespaces[chainNamespace].chains || supportedNamespaces[chainNamespace].chains?.length === 0) {\n    return false;\n  }\n  const isSupported = supportedNamespaces[chainNamespace].chains?.includes(wcChainNamespace);\n  return !!isSupported;\n};\n","import SignClient from \"@walletconnect/sign-client\";\nimport { SessionTypes } from \"@walletconnect/types\";\nimport { getSdkError, isValidArray } from \"@walletconnect/utils\";\nimport {\n  ADAPTER_CATEGORY,\n  ADAPTER_CATEGORY_TYPE,\n  ADAPTER_EVENTS,\n  ADAPTER_NAMESPACES,\n  ADAPTER_STATUS,\n  ADAPTER_STATUS_TYPE,\n  AdapterInitOptions,\n  AdapterNamespaceType,\n  CHAIN_NAMESPACES,\n  ChainNamespaceType,\n  CONNECTED_EVENT_DATA,\n  CustomChainConfig,\n  log,\n  SafeEventEmitterProvider,\n  UserInfo,\n  WALLET_ADAPTERS,\n  WalletConnectV2Data,\n  WalletInitializationError,\n  WalletLoginError,\n  WalletOperationsError,\n  Web3AuthError,\n} from \"@web3auth/base\";\nimport { BaseEvmAdapter } from \"@web3auth/base-evm-adapter\";\nimport { WalletConnectV2Provider } from \"@web3auth/ethereum-provider\";\nimport merge from \"lodash.merge\";\n\nimport { getWalletConnectV2Settings, WALLET_CONNECT_EXTENSION_ADAPTERS } from \"./config\";\nimport { WalletConnectV2AdapterOptions } from \"./interface\";\nimport { isChainIdSupported } from \"./utils\";\n\nclass WalletConnectV2Adapter extends BaseEvmAdapter<void> {\n  readonly name: string = WALLET_ADAPTERS.WALLET_CONNECT_V2;\n\n  readonly adapterNamespace: AdapterNamespaceType = ADAPTER_NAMESPACES.EIP155;\n\n  readonly currentChainNamespace: ChainNamespaceType = CHAIN_NAMESPACES.EIP155;\n\n  readonly type: ADAPTER_CATEGORY_TYPE = ADAPTER_CATEGORY.EXTERNAL;\n\n  readonly adapterOptions: WalletConnectV2AdapterOptions;\n\n  public status: ADAPTER_STATUS_TYPE = ADAPTER_STATUS.NOT_READY;\n\n  public adapterData: WalletConnectV2Data = {\n    uri: \"\",\n    extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS,\n  };\n\n  public connector: SignClient | null = null;\n\n  public activeSession: SessionTypes.Struct | null = null;\n\n  private wcProvider: WalletConnectV2Provider | null = null;\n\n  constructor(options: WalletConnectV2AdapterOptions = {}) {\n    super(options);\n    this.adapterOptions = { ...options };\n  }\n\n  get connected(): boolean {\n    return !!this.activeSession;\n  }\n\n  get provider(): SafeEventEmitterProvider | null {\n    if (this.status !== ADAPTER_STATUS.NOT_READY && this.wcProvider) {\n      return this.wcProvider.provider;\n    }\n    return null;\n  }\n\n  set provider(_: SafeEventEmitterProvider | null) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options: AdapterInitOptions): Promise<void> {\n    await super.init();\n    super.checkInitializationRequirements();\n    const projectId = this.adapterOptions.adapterSettings?.walletConnectInitOptions?.projectId;\n    if (!projectId) {\n      throw WalletInitializationError.invalidParams(\"Wallet connect project id is required in wallet connect v2 adapter\");\n    }\n\n    const wc2Settings = await getWalletConnectV2Settings(\n      this.chainConfig?.chainNamespace as ChainNamespaceType,\n      [parseInt(this.chainConfig?.chainId as string, 16)],\n      projectId\n    );\n    if (!this.adapterOptions.loginSettings) {\n      this.adapterOptions.loginSettings = wc2Settings.loginSettings;\n    }\n\n    this.adapterOptions.adapterSettings = merge(wc2Settings.adapterSettings, this.adapterOptions.adapterSettings);\n\n    const { adapterSettings } = this.adapterOptions;\n\n    this.connector = await SignClient.init(adapterSettings?.walletConnectInitOptions);\n    this.wcProvider = new WalletConnectV2Provider({ config: { chainConfig: this.chainConfig as CustomChainConfig }, connector: this.connector });\n\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V2);\n    this.status = ADAPTER_STATUS.READY;\n    log.debug(\"initializing wallet connect v2 adapter\");\n    if (options.autoConnect) {\n      await this.checkForPersistedSession();\n\n      if (this.connected) {\n        this.rehydrated = true;\n        try {\n          await this.onConnectHandler();\n        } catch (error) {\n          log.error(\"wallet auto connect\", error);\n          this.emit(ADAPTER_EVENTS.ERRORED, error);\n        }\n      } else {\n        this.status = ADAPTER_STATUS.NOT_READY;\n        this.emit(ADAPTER_EVENTS.CACHE_CLEAR);\n      }\n    }\n  }\n\n  async connect(): Promise<SafeEventEmitterProvider | null> {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    try {\n      // if already connected\n      if (this.connected) {\n        await this.onConnectHandler();\n        return this.provider;\n      }\n\n      if (this.status !== ADAPTER_STATUS.CONNECTING) {\n        await this.createNewSession();\n      }\n      return this.provider;\n    } catch (error) {\n      log.error(\"Wallet connect v2 adapter error while connecting\", error);\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = true;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n\n      const finalError =\n        error instanceof Web3AuthError\n          ? error\n          : WalletLoginError.connectionError(`Failed to login with wallet connect: ${(error as Error)?.message || \"\"}`);\n      throw finalError;\n    }\n  }\n\n  public async addChain(chainConfig: CustomChainConfig, init = false): Promise<void> {\n    super.checkAddChainRequirements(chainConfig, init);\n    if (!isChainIdSupported(this.currentChainNamespace, parseInt(chainConfig.chainId, 16), this.adapterOptions.loginSettings)) {\n      throw WalletOperationsError.chainIDNotAllowed(`Unsupported chainID: ${chainConfig.chainId}`);\n    }\n    await this.wcProvider?.addChain(chainConfig);\n    this.addChainConfig(chainConfig);\n  }\n\n  public async switchChain(params: { chainId: string }, init = false): Promise<void> {\n    super.checkSwitchChainRequirements(params, init);\n    if (!isChainIdSupported(this.currentChainNamespace, parseInt(params.chainId, 16), this.adapterOptions.loginSettings)) {\n      throw WalletOperationsError.chainIDNotAllowed(`Unsupported chainID: ${params.chainId}`);\n    }\n    await this.wcProvider?.switchChain({ chainId: params.chainId });\n    this.setAdapterSettings({ chainConfig: this.getChainConfig(params.chainId) as CustomChainConfig });\n  }\n\n  async getUserInfo(): Promise<Partial<UserInfo>> {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async disconnect(options: { cleanup: boolean } = { cleanup: false }): Promise<void> {\n    await super.disconnectSession();\n    const { cleanup } = options;\n    if (!this.connector || !this.connected || !this.activeSession?.topic) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.disconnect({ topic: this.activeSession?.topic, reason: getSdkError(\"USER_DISCONNECTED\") });\n    this.rehydrated = false;\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n    this.activeSession = null;\n    await super.disconnect();\n  }\n\n  private cleanupPendingPairings(): void {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const inactivePairings = this.connector.pairing.getAll({ active: false });\n\n    if (!isValidArray(inactivePairings)) return;\n\n    inactivePairings.forEach((pairing) => {\n      if (this.connector) {\n        this.connector.pairing.delete(pairing.topic, getSdkError(\"USER_DISCONNECTED\"));\n      }\n    });\n  }\n\n  private async checkForPersistedSession(): Promise<SessionTypes.Struct | null> {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (this.connector.session.length) {\n      const lastKeyIndex = this.connector.session.keys.length - 1;\n      this.activeSession = this.connector.session.get(this.connector.session.keys[lastKeyIndex]);\n    }\n    return this.activeSession;\n  }\n\n  private async createNewSession(opts: { forceNewSession: boolean } = { forceNewSession: false }): Promise<void> {\n    try {\n      if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n      if (!this.adapterOptions.loginSettings) throw WalletInitializationError.notReady(\"login settings are not set yet\");\n\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, { adapter: WALLET_ADAPTERS.WALLET_CONNECT_V2 });\n      if (opts.forceNewSession && this.activeSession?.topic) {\n        await this.connector.disconnect({ topic: this.activeSession?.topic, reason: getSdkError(\"USER_DISCONNECTED\") });\n      }\n\n      log.debug(\"creating new session for web3auth wallet connect\");\n      const { uri, approval } = await this.connector.connect(this.adapterOptions.loginSettings);\n      const qrcodeModal = this.adapterOptions?.adapterSettings?.qrcodeModal;\n      // Open QRCode modal if a URI was returned (i.e. we're not connecting with an existing pairing).\n      if (uri) {\n        if (qrcodeModal) {\n          qrcodeModal.open(uri, () => {\n            log.debug(\"EVENT\", \"QR Code Modal closed\");\n            this.status = ADAPTER_STATUS.READY;\n            this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V2);\n          });\n        } else {\n          this.updateAdapterData({ uri, extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS } as WalletConnectV2Data);\n        }\n      }\n\n      // Await session approval from the wallet.\n      const session = await approval();\n      this.activeSession = session;\n      // Handle the returned session (e.g. update UI to \"connected\" state).\n      await this.onConnectHandler();\n      if (qrcodeModal) {\n        qrcodeModal.close();\n      }\n    } catch (error) {\n      log.error(\"error while creating new wallet connect session\", error);\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw error;\n    }\n  }\n\n  private async onConnectHandler() {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    if (this.adapterOptions.adapterSettings?.qrcodeModal) {\n      this.wcProvider = new WalletConnectV2Provider({\n        config: {\n          chainConfig: this.chainConfig as CustomChainConfig,\n          skipLookupNetwork: true,\n        },\n        connector: this.connector,\n      });\n    }\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents();\n    this.cleanupPendingPairings();\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, { adapter: WALLET_ADAPTERS.WALLET_CONNECT_V2, reconnected: this.rehydrated } as CONNECTED_EVENT_DATA);\n  }\n\n  private subscribeEvents(): void {\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    this.connector.on(\"session_update\", ({ topic, params }) => {\n      if (!this.connector) return;\n      const { namespaces } = params;\n      const _session = this.connector.session.get(topic);\n      // Overwrite the `namespaces` of the existing session with the incoming one.\n      const updatedSession = { ..._session, namespaces };\n      // Integrate the updated session state into your dapp state.\n      this.activeSession = updatedSession;\n    });\n\n    this.connector.events.on(\"session_delete\", () => {\n      // Session was deleted -> reset the dapp state, clean up from user session, etc.\n\n      this.disconnect();\n    });\n  }\n}\n\nexport { WalletConnectV2Adapter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}