{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { BaseSessionManager } from '@toruslabs/base-session-manager';\nimport { generatePrivate, getPublic, sign } from '@toruslabs/eccrypto';\nimport { encryptData, keccak256, decryptData } from '@toruslabs/metadata-helpers';\nconst DEFAULT_SESSION_TIMEOUT = 86400;\nclass OpenloginSessionManager extends BaseSessionManager {\n  constructor() {\n    let {\n      sessionServerBaseUrl,\n      sessionNamespace,\n      sessionTime,\n      sessionId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    _defineProperty(this, \"sessionServerBaseUrl\", \"https://broadcast-server.tor.us\");\n    _defineProperty(this, \"sessionNamespace\", void 0);\n    _defineProperty(this, \"sessionTime\", DEFAULT_SESSION_TIMEOUT);\n    _defineProperty(this, \"sessionId\", void 0);\n    if (sessionServerBaseUrl) {\n      this.sessionServerBaseUrl = sessionServerBaseUrl;\n    }\n    if (sessionNamespace) this.sessionNamespace = sessionNamespace;\n    if (sessionTime) this.sessionTime = sessionTime;\n    if (sessionId) this.sessionId = sessionId;\n  }\n  get sessionKey() {\n    var _this$sessionId;\n    return ((_this$sessionId = this.sessionId) === null || _this$sessionId === void 0 ? void 0 : _this$sessionId.padStart(64, \"0\")) || \"\";\n  }\n  set sessionKey(value) {\n    if (!value) throw new Error(\"Session key is required\");\n    this.sessionId = value.padStart(64, \"0\");\n  }\n  static generateRandomSessionKey() {\n    return generatePrivate().toString(\"hex\").padStart(64, \"0\");\n  }\n  async createSession(data) {\n    const privKey = Buffer.from(this.sessionKey, \"hex\");\n    const pubKey = getPublic(privKey).toString(\"hex\");\n    const encData = await encryptData(this.sessionKey, data);\n    const signature = (await sign(privKey, keccak256(Buffer.from(encData, \"utf8\")))).toString(\"hex\");\n    const body = {\n      key: pubKey,\n      data: encData,\n      signature,\n      namespace: this.sessionNamespace,\n      timeout: this.sessionTime\n    };\n    await super.request({\n      method: \"POST\",\n      url: `${this.sessionServerBaseUrl}/store/set`,\n      data: body\n    });\n    return this.sessionKey;\n  }\n  async authorizeSession() {\n    super.checkSessionParams(this.sessionKey);\n    const pubkey = getPublic(Buffer.from(this.sessionKey, \"hex\")).toString(\"hex\");\n    const url = new URL(`${this.sessionServerBaseUrl}/store/get`);\n    url.searchParams.append(\"key\", pubkey);\n    if (this.sessionNamespace) url.searchParams.append(\"namespace\", this.sessionNamespace);\n    const result = await super.request({\n      url: url.toString()\n    });\n    if (!result.message) {\n      throw new Error(\"Session Expired or Invalid public key\");\n    }\n    const response = await decryptData(this.sessionKey, result.message);\n    if (response.error) {\n      throw new Error(\"There was an error decrypting data.\");\n    }\n    return response;\n  }\n  async updateSession(data) {\n    super.checkSessionParams(this.sessionKey);\n    const privKey = Buffer.from(this.sessionKey, \"hex\");\n    const pubKey = getPublic(privKey).toString(\"hex\");\n    const encData = await encryptData(this.sessionKey, data);\n    const signature = (await sign(privKey, keccak256(Buffer.from(encData, \"utf8\")))).toString(\"hex\");\n    const body = {\n      key: pubKey,\n      data: encData,\n      signature,\n      namespace: this.sessionNamespace\n    };\n    await super.request({\n      method: \"PUT\",\n      url: `${this.sessionServerBaseUrl}/store/update`,\n      data: body\n    });\n  }\n  async invalidateSession() {\n    super.checkSessionParams(this.sessionKey);\n    const privKey = Buffer.from(this.sessionKey, \"hex\");\n    const pubKey = getPublic(privKey).toString(\"hex\");\n    const encData = await encryptData(this.sessionKey, {});\n    const signature = (await sign(privKey, keccak256(Buffer.from(encData, \"utf8\")))).toString(\"hex\");\n    const data = {\n      key: pubKey,\n      data: encData,\n      signature,\n      namespace: this.sessionNamespace,\n      timeout: 1\n    };\n    await super.request({\n      method: \"POST\",\n      url: `${this.sessionServerBaseUrl}/store/set`,\n      data\n    });\n    this.sessionId = \"\";\n    return true;\n  }\n}\nexport { OpenloginSessionManager };","map":{"version":3,"names":["DEFAULT_SESSION_TIMEOUT","OpenloginSessionManager","BaseSessionManager","constructor","sessionServerBaseUrl","sessionNamespace","sessionTime","sessionId","arguments","length","undefined","_defineProperty","sessionKey","_this$sessionId","padStart","value","Error","generateRandomSessionKey","generatePrivate","toString","createSession","data","privKey","Buffer","from","pubKey","getPublic","encData","encryptData","signature","sign","keccak256","body","key","namespace","timeout","request","method","url","authorizeSession","checkSessionParams","pubkey","URL","searchParams","append","result","message","response","decryptData","error","updateSession","invalidateSession"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@toruslabs/openlogin-session-manager/src/openloginSessionManager.ts"],"sourcesContent":["import { BaseSessionManager } from \"@toruslabs/base-session-manager\";\nimport { generatePrivate, getPublic, sign } from \"@toruslabs/eccrypto\";\nimport { decryptData, encryptData, keccak256 } from \"@toruslabs/metadata-helpers\";\n\nimport { OpenloginSessionManagerOptions, SessionApiResponse, SessionRequestBody } from \"./interfaces\";\n\nconst DEFAULT_SESSION_TIMEOUT = 86400;\nexport class OpenloginSessionManager<T> extends BaseSessionManager<T> {\n  sessionServerBaseUrl = \"https://broadcast-server.tor.us\";\n\n  sessionNamespace: string;\n\n  sessionTime: number = DEFAULT_SESSION_TIMEOUT;\n\n  private sessionId: string;\n\n  constructor({ sessionServerBaseUrl, sessionNamespace, sessionTime, sessionId }: OpenloginSessionManagerOptions = {}) {\n    super();\n\n    if (sessionServerBaseUrl) {\n      this.sessionServerBaseUrl = sessionServerBaseUrl;\n    }\n    if (sessionNamespace) this.sessionNamespace = sessionNamespace;\n    if (sessionTime) this.sessionTime = sessionTime;\n    if (sessionId) this.sessionId = sessionId;\n  }\n\n  get sessionKey(): string {\n    return this.sessionId?.padStart(64, \"0\") || \"\";\n  }\n\n  set sessionKey(value: string) {\n    if (!value) throw new Error(\"Session key is required\");\n    this.sessionId = value.padStart(64, \"0\");\n  }\n\n  static generateRandomSessionKey(): string {\n    return generatePrivate().toString(\"hex\").padStart(64, \"0\");\n  }\n\n  async createSession(data: T): Promise<string> {\n    const privKey = Buffer.from(this.sessionKey, \"hex\");\n    const pubKey = getPublic(privKey).toString(\"hex\");\n    const encData = await encryptData(this.sessionKey, data);\n    const signature = (await sign(privKey, keccak256(Buffer.from(encData, \"utf8\")))).toString(\"hex\");\n\n    const body: SessionRequestBody = {\n      key: pubKey,\n      data: encData,\n      signature,\n      namespace: this.sessionNamespace,\n      timeout: this.sessionTime,\n    };\n\n    await super.request({ method: \"POST\", url: `${this.sessionServerBaseUrl}/store/set`, data: body });\n\n    return this.sessionKey;\n  }\n\n  async authorizeSession(): Promise<T> {\n    super.checkSessionParams(this.sessionKey);\n    const pubkey = getPublic(Buffer.from(this.sessionKey, \"hex\")).toString(\"hex\");\n    const url = new URL(`${this.sessionServerBaseUrl}/store/get`);\n    url.searchParams.append(\"key\", pubkey);\n    if (this.sessionNamespace) url.searchParams.append(\"namespace\", this.sessionNamespace);\n\n    const result = await super.request<SessionApiResponse>({ url: url.toString() });\n    if (!result.message) {\n      throw new Error(\"Session Expired or Invalid public key\");\n    }\n\n    const response = await decryptData<T & { error?: string }>(this.sessionKey, result.message);\n    if (response.error) {\n      throw new Error(\"There was an error decrypting data.\");\n    }\n\n    return response;\n  }\n\n  async updateSession(data: Partial<T>): Promise<void> {\n    super.checkSessionParams(this.sessionKey);\n    const privKey = Buffer.from(this.sessionKey, \"hex\");\n    const pubKey = getPublic(privKey).toString(\"hex\");\n    const encData = await encryptData(this.sessionKey, data);\n    const signature = (await sign(privKey, keccak256(Buffer.from(encData, \"utf8\")))).toString(\"hex\");\n\n    const body: SessionRequestBody = {\n      key: pubKey,\n      data: encData,\n      signature,\n      namespace: this.sessionNamespace,\n    };\n\n    await super.request({ method: \"PUT\", url: `${this.sessionServerBaseUrl}/store/update`, data: body });\n  }\n\n  async invalidateSession(): Promise<boolean> {\n    super.checkSessionParams(this.sessionKey);\n    const privKey = Buffer.from(this.sessionKey, \"hex\");\n    const pubKey = getPublic(privKey).toString(\"hex\");\n    const encData = await encryptData(this.sessionKey, {});\n    const signature = (await sign(privKey, keccak256(Buffer.from(encData, \"utf8\")))).toString(\"hex\");\n\n    const data: SessionRequestBody = {\n      key: pubKey,\n      data: encData,\n      signature,\n      namespace: this.sessionNamespace,\n      timeout: 1,\n    };\n\n    await super.request({ method: \"POST\", url: `${this.sessionServerBaseUrl}/store/set`, data });\n    this.sessionId = \"\";\n    return true;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}