{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseGethGenesis = void 0;\nconst util_1 = require(\"@ethereumjs/util\");\nconst enums_1 = require(\"./enums\");\n/**\n * Transforms Geth formatted nonce (i.e. hex string) to 8 byte 0x-prefixed string used internally\n * @param nonce string parsed from the Geth genesis file\n * @returns nonce as a 0x-prefixed 8 byte string\n */\nfunction formatNonce(nonce) {\n  if (!nonce || nonce === '0x0') {\n    return '0x0000000000000000';\n  }\n  if ((0, util_1.isHexPrefixed)(nonce)) {\n    return '0x' + (0, util_1.stripHexPrefix)(nonce).padStart(16, '0');\n  }\n  return '0x' + nonce.padStart(16, '0');\n}\n/**\n * Converts Geth genesis parameters to an EthereumJS compatible `CommonOpts` object\n * @param json object representing the Geth genesis file\n * @param optional mergeForkIdPostMerge which clarifies the placement of MergeForkIdTransition\n * hardfork, which by default is post merge as with the merged eth networks but could also come\n * before merge like in kiln genesis\n * @returns genesis parameters in a `CommonOpts` compliant object\n */\nfunction parseGethParams(json, mergeForkIdPostMerge = true) {\n  const {\n    name,\n    config,\n    difficulty,\n    mixHash,\n    gasLimit,\n    coinbase,\n    baseFeePerGas\n  } = json;\n  let {\n    extraData,\n    timestamp,\n    nonce\n  } = json;\n  const genesisTimestamp = Number(timestamp);\n  const {\n    chainId\n  } = config;\n  // geth is not strictly putting empty fields with a 0x prefix\n  if (extraData === '') {\n    extraData = '0x';\n  }\n  // geth may use number for timestamp\n  if (!(0, util_1.isHexPrefixed)(timestamp)) {\n    timestamp = (0, util_1.intToHex)(parseInt(timestamp));\n  }\n  // geth may not give us a nonce strictly formatted to an 8 byte hex string\n  if (nonce.length !== 18) {\n    nonce = formatNonce(nonce);\n  }\n  // EIP155 and EIP158 are both part of Spurious Dragon hardfork and must occur at the same time\n  // but have different configuration parameters in geth genesis parameters\n  if (config.eip155Block !== config.eip158Block) {\n    throw new Error('EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork');\n  }\n  const params = {\n    name,\n    chainId,\n    networkId: chainId,\n    genesis: {\n      timestamp,\n      gasLimit: parseInt(gasLimit),\n      difficulty: parseInt(difficulty),\n      nonce,\n      extraData,\n      mixHash,\n      coinbase,\n      baseFeePerGas\n    },\n    hardfork: undefined,\n    hardforks: [],\n    bootstrapNodes: [],\n    consensus: config.clique !== undefined ? {\n      type: 'poa',\n      algorithm: 'clique',\n      clique: {\n        // The recent geth genesis seems to be using blockperiodseconds\n        // and epochlength for clique specification\n        // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ\n        period: config.clique.period ?? config.clique.blockperiodseconds,\n        epoch: config.clique.epoch ?? config.clique.epochlength\n      }\n    } : {\n      type: 'pow',\n      algorithm: 'ethash',\n      ethash: {}\n    }\n  };\n  const forkMap = {\n    [enums_1.Hardfork.Homestead]: {\n      name: 'homesteadBlock'\n    },\n    [enums_1.Hardfork.Dao]: {\n      name: 'daoForkBlock'\n    },\n    [enums_1.Hardfork.TangerineWhistle]: {\n      name: 'eip150Block'\n    },\n    [enums_1.Hardfork.SpuriousDragon]: {\n      name: 'eip155Block'\n    },\n    [enums_1.Hardfork.Byzantium]: {\n      name: 'byzantiumBlock'\n    },\n    [enums_1.Hardfork.Constantinople]: {\n      name: 'constantinopleBlock'\n    },\n    [enums_1.Hardfork.Petersburg]: {\n      name: 'petersburgBlock'\n    },\n    [enums_1.Hardfork.Istanbul]: {\n      name: 'istanbulBlock'\n    },\n    [enums_1.Hardfork.MuirGlacier]: {\n      name: 'muirGlacierBlock'\n    },\n    [enums_1.Hardfork.Berlin]: {\n      name: 'berlinBlock'\n    },\n    [enums_1.Hardfork.London]: {\n      name: 'londonBlock'\n    },\n    [enums_1.Hardfork.MergeForkIdTransition]: {\n      name: 'mergeForkBlock',\n      postMerge: mergeForkIdPostMerge\n    },\n    [enums_1.Hardfork.Shanghai]: {\n      name: 'shanghaiTime',\n      postMerge: true,\n      isTimestamp: true\n    },\n    [enums_1.Hardfork.ShardingForkDev]: {\n      name: 'shardingForkTime',\n      postMerge: true,\n      isTimestamp: true\n    }\n  };\n  // forkMapRev is the map from config field name to Hardfork\n  const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {\n    acc[forkMap[elem].name] = elem;\n    return acc;\n  }, {});\n  const configHardforkNames = Object.keys(config).filter(key => forkMapRev[key] !== undefined && config[key] !== undefined && config[key] !== null);\n  params.hardforks = configHardforkNames.map(nameBlock => ({\n    name: forkMapRev[nameBlock],\n    block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== 'number' ? null : config[nameBlock],\n    timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === 'number' ? config[nameBlock] : undefined\n  })).filter(fork => fork.block !== null || fork.timestamp !== undefined);\n  params.hardforks.sort(function (a, b) {\n    return (a.block ?? Infinity) - (b.block ?? Infinity);\n  });\n  params.hardforks.sort(function (a, b) {\n    return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp);\n  });\n  if (config.terminalTotalDifficulty !== undefined) {\n    // Following points need to be considered for placement of merge hf\n    // - Merge hardfork can't be placed at genesis\n    // - Place merge hf before any hardforks that require CL participation for e.g. withdrawals\n    // - Merge hardfork has to be placed just after genesis if any of the genesis hardforks make CL\n    //   necessary for e.g. withdrawals\n    const mergeConfig = {\n      name: enums_1.Hardfork.Merge,\n      ttd: config.terminalTotalDifficulty,\n      block: null\n    };\n    // Merge hardfork has to be placed before first hardfork that is dependent on merge\n    const postMergeIndex = params.hardforks.findIndex(hf => forkMap[hf.name]?.postMerge === true);\n    if (postMergeIndex !== -1) {\n      params.hardforks.splice(postMergeIndex, 0, mergeConfig);\n    } else {\n      params.hardforks.push(mergeConfig);\n    }\n  }\n  const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined;\n  params.hardfork = latestHardfork?.name;\n  params.hardforks.unshift({\n    name: enums_1.Hardfork.Chainstart,\n    block: 0\n  });\n  return params;\n}\n/**\n * Parses a genesis.json exported from Geth into parameters for Common instance\n * @param json representing the Geth genesis file\n * @param name optional chain name\n * @returns parsed params\n */\nfunction parseGethGenesis(json, name, mergeForkIdPostMerge) {\n  try {\n    if (['config', 'difficulty', 'gasLimit', 'alloc'].some(field => !(field in json))) {\n      throw new Error('Invalid format, expected geth genesis fields missing');\n    }\n    if (name !== undefined) {\n      json.name = name;\n    }\n    return parseGethParams(json, mergeForkIdPostMerge);\n  } catch (e) {\n    throw new Error(`Error parsing parameters file: ${e.message}`);\n  }\n}\nexports.parseGethGenesis = parseGethGenesis;","map":{"version":3,"names":["util_1","require","enums_1","formatNonce","nonce","isHexPrefixed","stripHexPrefix","padStart","parseGethParams","json","mergeForkIdPostMerge","name","config","difficulty","mixHash","gasLimit","coinbase","baseFeePerGas","extraData","timestamp","genesisTimestamp","Number","chainId","intToHex","parseInt","length","eip155Block","eip158Block","Error","params","networkId","genesis","hardfork","undefined","hardforks","bootstrapNodes","consensus","clique","type","algorithm","period","blockperiodseconds","epoch","epochlength","ethash","forkMap","Hardfork","Homestead","Dao","TangerineWhistle","SpuriousDragon","Byzantium","Constantinople","Petersburg","Istanbul","MuirGlacier","Berlin","London","MergeForkIdTransition","postMerge","Shanghai","isTimestamp","ShardingForkDev","forkMapRev","Object","keys","reduce","acc","elem","configHardforkNames","filter","key","map","nameBlock","block","fork","sort","a","b","Infinity","terminalTotalDifficulty","mergeConfig","Merge","ttd","postMergeIndex","findIndex","hf","splice","push","latestHardfork","slice","unshift","Chainstart","parseGethGenesis","some","field","e","message","exports"],"sources":["/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/node_modules/@ethereumjs/common/src/utils.ts"],"sourcesContent":["import { intToHex, isHexPrefixed, stripHexPrefix } from '@ethereumjs/util'\n\nimport { Hardfork } from './enums'\n\ntype ConfigHardfork =\n  | { name: string; block: null; timestamp: number }\n  | { name: string; block: number; timestamp?: number }\n/**\n * Transforms Geth formatted nonce (i.e. hex string) to 8 byte 0x-prefixed string used internally\n * @param nonce string parsed from the Geth genesis file\n * @returns nonce as a 0x-prefixed 8 byte string\n */\nfunction formatNonce(nonce: string): string {\n  if (!nonce || nonce === '0x0') {\n    return '0x0000000000000000'\n  }\n  if (isHexPrefixed(nonce)) {\n    return '0x' + stripHexPrefix(nonce).padStart(16, '0')\n  }\n  return '0x' + nonce.padStart(16, '0')\n}\n\n/**\n * Converts Geth genesis parameters to an EthereumJS compatible `CommonOpts` object\n * @param json object representing the Geth genesis file\n * @param optional mergeForkIdPostMerge which clarifies the placement of MergeForkIdTransition\n * hardfork, which by default is post merge as with the merged eth networks but could also come\n * before merge like in kiln genesis\n * @returns genesis parameters in a `CommonOpts` compliant object\n */\nfunction parseGethParams(json: any, mergeForkIdPostMerge: boolean = true) {\n  const {\n    name,\n    config,\n    difficulty,\n    mixHash,\n    gasLimit,\n    coinbase,\n    baseFeePerGas,\n  }: {\n    name: string\n    config: any\n    difficulty: string\n    mixHash: string\n    gasLimit: string\n    coinbase: string\n    baseFeePerGas: string\n  } = json\n  let { extraData, timestamp, nonce }: { extraData: string; timestamp: string; nonce: string } =\n    json\n  const genesisTimestamp = Number(timestamp)\n  const { chainId }: { chainId: number } = config\n\n  // geth is not strictly putting empty fields with a 0x prefix\n  if (extraData === '') {\n    extraData = '0x'\n  }\n  // geth may use number for timestamp\n  if (!isHexPrefixed(timestamp)) {\n    timestamp = intToHex(parseInt(timestamp))\n  }\n  // geth may not give us a nonce strictly formatted to an 8 byte hex string\n  if (nonce.length !== 18) {\n    nonce = formatNonce(nonce)\n  }\n\n  // EIP155 and EIP158 are both part of Spurious Dragon hardfork and must occur at the same time\n  // but have different configuration parameters in geth genesis parameters\n  if (config.eip155Block !== config.eip158Block) {\n    throw new Error(\n      'EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork'\n    )\n  }\n\n  const params = {\n    name,\n    chainId,\n    networkId: chainId,\n    genesis: {\n      timestamp,\n      gasLimit: parseInt(gasLimit), // geth gasLimit and difficulty are hex strings while ours are `number`s\n      difficulty: parseInt(difficulty),\n      nonce,\n      extraData,\n      mixHash,\n      coinbase,\n      baseFeePerGas,\n    },\n    hardfork: undefined as string | undefined,\n    hardforks: [] as ConfigHardfork[],\n    bootstrapNodes: [],\n    consensus:\n      config.clique !== undefined\n        ? {\n            type: 'poa',\n            algorithm: 'clique',\n            clique: {\n              // The recent geth genesis seems to be using blockperiodseconds\n              // and epochlength for clique specification\n              // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ\n              period: config.clique.period ?? config.clique.blockperiodseconds,\n              epoch: config.clique.epoch ?? config.clique.epochlength,\n            },\n          }\n        : {\n            type: 'pow',\n            algorithm: 'ethash',\n            ethash: {},\n          },\n  }\n\n  const forkMap: { [key: string]: { name: string; postMerge?: boolean; isTimestamp?: boolean } } = {\n    [Hardfork.Homestead]: { name: 'homesteadBlock' },\n    [Hardfork.Dao]: { name: 'daoForkBlock' },\n    [Hardfork.TangerineWhistle]: { name: 'eip150Block' },\n    [Hardfork.SpuriousDragon]: { name: 'eip155Block' },\n    [Hardfork.Byzantium]: { name: 'byzantiumBlock' },\n    [Hardfork.Constantinople]: { name: 'constantinopleBlock' },\n    [Hardfork.Petersburg]: { name: 'petersburgBlock' },\n    [Hardfork.Istanbul]: { name: 'istanbulBlock' },\n    [Hardfork.MuirGlacier]: { name: 'muirGlacierBlock' },\n    [Hardfork.Berlin]: { name: 'berlinBlock' },\n    [Hardfork.London]: { name: 'londonBlock' },\n    [Hardfork.MergeForkIdTransition]: { name: 'mergeForkBlock', postMerge: mergeForkIdPostMerge },\n    [Hardfork.Shanghai]: { name: 'shanghaiTime', postMerge: true, isTimestamp: true },\n    [Hardfork.ShardingForkDev]: { name: 'shardingForkTime', postMerge: true, isTimestamp: true },\n  }\n\n  // forkMapRev is the map from config field name to Hardfork\n  const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {\n    acc[forkMap[elem].name] = elem\n    return acc\n  }, {} as { [key: string]: string })\n  const configHardforkNames = Object.keys(config).filter(\n    (key) => forkMapRev[key] !== undefined && config[key] !== undefined && config[key] !== null\n  )\n\n  params.hardforks = configHardforkNames\n    .map((nameBlock) => ({\n      name: forkMapRev[nameBlock],\n      block:\n        forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== 'number'\n          ? null\n          : config[nameBlock],\n      timestamp:\n        forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === 'number'\n          ? config[nameBlock]\n          : undefined,\n    }))\n    .filter((fork) => fork.block !== null || fork.timestamp !== undefined) as ConfigHardfork[]\n\n  params.hardforks.sort(function (a: ConfigHardfork, b: ConfigHardfork) {\n    return (a.block ?? Infinity) - (b.block ?? Infinity)\n  })\n\n  params.hardforks.sort(function (a: ConfigHardfork, b: ConfigHardfork) {\n    return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp)\n  })\n\n  if (config.terminalTotalDifficulty !== undefined) {\n    // Following points need to be considered for placement of merge hf\n    // - Merge hardfork can't be placed at genesis\n    // - Place merge hf before any hardforks that require CL participation for e.g. withdrawals\n    // - Merge hardfork has to be placed just after genesis if any of the genesis hardforks make CL\n    //   necessary for e.g. withdrawals\n    const mergeConfig = {\n      name: Hardfork.Merge,\n      ttd: config.terminalTotalDifficulty,\n      block: null,\n    }\n\n    // Merge hardfork has to be placed before first hardfork that is dependent on merge\n    const postMergeIndex = params.hardforks.findIndex(\n      (hf: any) => forkMap[hf.name]?.postMerge === true\n    )\n    if (postMergeIndex !== -1) {\n      params.hardforks.splice(postMergeIndex, 0, mergeConfig as unknown as ConfigHardfork)\n    } else {\n      params.hardforks.push(mergeConfig as unknown as ConfigHardfork)\n    }\n  }\n\n  const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined\n  params.hardfork = latestHardfork?.name\n  params.hardforks.unshift({ name: Hardfork.Chainstart, block: 0 })\n\n  return params\n}\n\n/**\n * Parses a genesis.json exported from Geth into parameters for Common instance\n * @param json representing the Geth genesis file\n * @param name optional chain name\n * @returns parsed params\n */\nexport function parseGethGenesis(json: any, name?: string, mergeForkIdPostMerge?: boolean) {\n  try {\n    if (['config', 'difficulty', 'gasLimit', 'alloc'].some((field) => !(field in json))) {\n      throw new Error('Invalid format, expected geth genesis fields missing')\n    }\n    if (name !== undefined) {\n      json.name = name\n    }\n    return parseGethParams(json, mergeForkIdPostMerge)\n  } catch (e: any) {\n    throw new Error(`Error parsing parameters file: ${e.message}`)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}