{
  "manifest": {
    "name": "jayson",
    "version": "4.1.0",
    "description": "JSON-RPC 1.0/2.0 compliant server and client",
    "license": "MIT",
    "keywords": [
      "jsonrpc",
      "json-rpc",
      "rpc",
      "json",
      "jsonrpc-2.0",
      "jsonrpc-1.0",
      "middleware",
      "connect",
      "express",
      "fork",
      "distributed",
      "relay",
      "http",
      "tcp",
      "https",
      "tls",
      "api"
    ],
    "author": {
      "name": "Tedde Lundgren",
      "email": "mail@tedeh.net",
      "url": "https://tedeh.net"
    },
    "maintainers": "Tedde Lundgren <mail@tedeh.net> (https://tedeh.net)",
    "bin": {
      "jayson": "bin/jayson.js"
    },
    "repository": {
      "type": "git",
      "url": "git://github.com/tedeh/jayson.git"
    },
    "homepage": "https://jayson.tedeh.net/",
    "bugs": {
      "url": "https://github.com/tedeh/jayson/issues"
    },
    "contributors": [
      {
        "name": "Tedde Lundgren",
        "email": "mail@tedeh.net",
        "url": "https://tedeh.net"
      },
      {
        "name": "Daniel Vicory",
        "email": "dvicory@gmail.com",
        "url": "http://bzfx.net"
      },
      {
        "name": "Jonathan Liu",
        "email": "net147@gmail.com"
      }
    ],
    "scripts": {
      "test": "mocha",
      "test-ci": "mocha -w -R min",
      "test-tsc": "tsc --strict --lib es6 --esModuleInterop typescript/test.ts",
      "coverage": "nyc mocha",
      "coveralls": "mocha && nyc report --reporter=text-lcov | coveralls",
      "docs": "jsdoc -t node_modules/ink-docstrap/template -R README.md -c ./jsdoc.conf.json",
      "docs_clear": "rm -rf ./docs/jayson/*; exit 0",
      "docs_refresh": "npm run docs_clear && npm run docs",
      "docs_deploy": "rsync --delete -r docs/jayson/* tedeh.net:/var/www/jayson.tedeh.net; exit 0",
      "lint": "jshint lib/*.js lib/**/*.js promise/*.js promise/**/*.js; exit 0"
    },
    "dependencies": {
      "@types/connect": "^3.4.33",
      "@types/node": "^12.12.54",
      "@types/ws": "^7.4.4",
      "commander": "^2.20.3",
      "delay": "^5.0.0",
      "es6-promisify": "^5.0.0",
      "eyes": "^0.1.8",
      "isomorphic-ws": "^4.0.1",
      "json-stringify-safe": "^5.0.1",
      "JSONStream": "^1.3.5",
      "uuid": "^8.3.2",
      "ws": "^7.4.5"
    },
    "devDependencies": {
      "@types/express-serve-static-core": "^4.17.30",
      "body-parser": "^1.19.0",
      "connect": "^3.7.0",
      "coveralls": "^3.1.0",
      "es6-promise": "^4.2.8",
      "express": "^4.17.1",
      "ink-docstrap": "github:docstrap/docstrap#pull/345/head",
      "jsdoc": "^4.0.2",
      "jshint": "^2.12.0",
      "mocha": "^10.2.0",
      "node-fetch": "^2.6.7",
      "nyc": "^14.1.1",
      "pass-stream": "^1.0.0",
      "should": "^13.2.3",
      "superagent": "^3.8.3",
      "typescript": "^4.7.4"
    },
    "engines": {
      "node": ">=8"
    },
    "_registry": "npm",
    "_loc": "/Users/Einpunk Community/Documents/Brownie/brownie_gamex_vault/web3-auth/Library/Caches/Yarn/v6/npm-jayson-4.1.0-60dc946a85197317f2b1439d672a8b0a99cea2f9-integrity/node_modules/jayson/package.json",
    "readmeFilename": "README.md",
    "readme": "# Jayson\n\nJayson is a [JSON-RPC 2.0][jsonrpc-spec] and [1.0][jsonrpc1-spec] compliant server and client written in JavaScript for [node.js][node.js] that aims to be as simple as possible to use.\n\n[jsonrpc-spec]: http://jsonrpc.org/spec.html \n[jsonrpc1-spec]: http://json-rpc.org/wiki/specification\n[node.js]: http://nodejs.org/\n[jayson-npm]: https://www.npmjs.com/package/jayson\n[badge-npm]: https://img.shields.io/npm/v/jayson.svg\n[badge-downloads-month]: https://img.shields.io/npm/dm/jayson.svg\n\n[![Coverage Status](https://coveralls.io/repos/github/tedeh/jayson/badge.svg?branch=master)](https://coveralls.io/github/tedeh/jayson?branch=master)\n![GitHub issues](https://img.shields.io/github/issues/tedeh/jayson)\n![Dependents (via libraries.io)](https://img.shields.io/librariesio/dependents/npm/jayson)\n![node-current](https://img.shields.io/node/v/jayson)\n![Libraries.io dependency status for latest release](https://img.shields.io/librariesio/release/npm/jayson)\n[![npm version][badge-npm]][jayson-npm]\n[![npm][badge-downloads-month]][jayson-npm]\n![npm bundle size](https://img.shields.io/bundlephobia/min/jayson)\n![npm bundle size](https://img.shields.io/bundlephobia/minzip/jayson)\n[![Known Vulnerabilities](https://snyk.io/test/npm/jayson/badge.svg)](https://snyk.io/test/npm/jayson)\n\n## Table of contents\n\n- [Features](#features)\n- [Example](#example)\n- [Installation](#installation)\n- [Changelog](#changelog-only-notable-milestoneschanges)\n- [Requirements](#requirements)\n- [Class Documentation](#class-documentation)\n- [Running tests](#running-tests)\n- [Typescript](#typescript)\n- [Usage](#usage)\n  - [Client](#client)\n     - [Interface description](#client-interface-description)\n     - [Browser usage](#clientbrowser)\n     - [Notifications](#notifications)\n     - [Batches](#batches)\n     - [Callback syntactic sugar](#client-callback-syntactic-sugar)\n     - [Events](#client-events)\n  - [Server](#server)\n     - [Interface description](#server-interface-description)\n     - [Many interfaces at the same time](#many-interfaces-at-the-same-time)\n     - [Using the server as a relay](#using-the-server-as-a-relay)\n     - [Method routing](#method-routing)\n     - [Method definition](#method-definition)\n     - [Events](#server-events)\n     - [Errors](#server-errors)\n     - [CORS](#server-cors)\n     - [Context](#server-context)\n- [Revivers and replacers](#revivers-and-replacers)\n- [Named parameters](#named-parameters)\n- [Promises](#promises)\n  - [Batches](#promise-batches)\n  - [Browser client](#promise-browser-client)\n- [FAQ](#faq)\n- [Recommended usage](#what-is-the-recommended-way-to-use-jayson)\n- [Contributing](#contributing)\n\n## Features\n\n* [Servers that can listen to several interfaces at the same time](#many-interfaces-at-the-same-time)\n* Supports both HTTP and TCP client and server connections\n* [Server-side method routing](#method-routing)\n* [Relaying of requests to other servers](#using-the-server-as-a-relay)\n* [JSON reviving and replacing for transparent serialization of complex objects](#revivers-and-replacers)\n* [CLI client](#cli-client)\n* [Promises](#promises)\n* Fully tested to comply with the [official JSON-RPC 2.0 specification][jsonrpc-spec]\n* Also supports [JSON-RPC 1.0][jsonrpc1-spec]\n\n## Example\n\nA basic JSON-RPC 2.0 server via HTTP:\n\nServer example in [examples/simple_example/server.js](examples/simple_example/server.js):\n\n```javascript\nconst jayson = require('jayson');\n\n// create a server\nconst server = new jayson.Server({\n  add: function(args, callback) {\n    callback(null, args[0] + args[1]);\n  }\n});\n\nserver.http().listen(3000);\n```\n\nClient example in [examples/simple_example/client.js](examples/simple_example/client.js) invoking `add` on the above server:\n\n```javascript\nconst jayson = require('jayson');\n\n// create a client\nconst client = jayson.Client.http({\n  port: 3000\n});\n\n// invoke \"add\"\nclient.request('add', [1, 1], function(err, response) {\n  if(err) throw err;\n  console.log(response.result); // 2\n});\n```\n\n## Installation\n\nInstall the latest version of _jayson_ from [npm](https://www.npmjs.com) by executing `npm install jayson` in your shell. Do a global install with `npm install --global jayson` if you want the `jayson` client CLI in your PATH.\n\n## Changelog (only notable milestones/changes)\n\n- *4.1.0*\n  - New server option `maxBatchLength`\n- *4.0.0*\n  - Remove `lodash` dependency which should halve bundle size. There might be minor incompatibilities if you pass funky object or array types to jayson methods.\n- *3.6.4*\n  - Websocket client and server support\n- *3.6.1*\n  - JSON-RPC 2.0 notifications no longer have id property unless overridden\n- *3.3.3*\n  - Promise support for browser client\n  - TypeScript declaration for promise browser client\n  - TypeScript declaration for browser client\n- *3.3.0*\n  - Remove URL parsing when passing a string option to the TLS and TCP client, string options are instead treated as an IPC path\n- *3.0.0*\n  - Can pass a [context object](#server-context) to handlers\n  - _Breaking_: `collect` option removed from `jayson.Server/Method`. JSON-RPC params to handlers are now **always** in the first argument.\n- *2.1.0*\n  - Experimental typescript support\n- *2.0.6*\n  - Clarified how to use [in the browser](#clientbrowser)\n- *2.0.0*\n  - Added [support for promises](#promises)\n  - _Breaking_: `collect: true` is now the default option for a new `jayson.Server` and `jayson.Method`\n- *1.2.0*\n  - Greatly improved [server method definition](#method-definition)\n- *1.1.1*\n  - More http server events\n  - Remove fork server and client\n  - Add server routing\n- *1.0.11*\n  Add support for a HTTPS client\n- *1.0.9*\n  Add support for TCP servers and clients\n\n### CLI client\n\nThere is a basic CLI client in `bin/jayson.js` and it should be available as `jayson` in your shell if you installed the package globally. Run `jayson --help` to see how it works.\n\n## Requirements\n\nJayson does not have any special dependencies that cannot be resolved with a simple `npm install` or `yarn install`.\n\n## Class documentation\n\nIn addition to this document, a comprehensive class documentation made with [jsdoc][jsdoc-spec] is available at [jayson.tedeh.net](http://jayson.tedeh.net).\n\n[jsdoc-spec]: http://usejsdoc.org/\n\n## Running tests\n\n- Change directory to the repository root\n- Install the development packages by executing `npm install --dev`\n- Run the tests with `npm run test`\n- Run the typescript tests with `npm run test-tsc`\n- Run the coverage tests with `npm run coverage`\n\n## Typescript\n\nSince `v2.1.0` there is typescript support available with jayson.\n\nIf you encounter any problems with the type definitions, see the [Contributing](#contributing) section.\n\n## Usage\n\n### Client\n\nThe client is available as the `Client` or `client` property of `require('jayson')`.\n\n#### Client interface description\n\n| Name               | Description         |\n|--------------------|---------------------|\n| `Client`           | Base class          |\n| `Client.tcp`       | TCP sub-class       |\n| `Client.tls`       | TLS sub-class       |\n| `Client.http`      | HTTP sub-class      |\n| `Client.https`     | HTTPS sub-class     |\n| `Client.browser`   | Standalone class    |\n| `Client.websocket` | Websocket sub-class |\n\nEvery client supports these options:\n\n| Option               | Default                            | Type       | Description                                                                              |\n|----------------------|------------------------------------|------------|------------------------------------------------------------------------------------------|\n| `reviver`            | `undefined`                        | `Function` | `JSON.parse` reviver                                                                     |\n| `replacer`           | `undefined`                        | `Function` | `JSON.stringify` replacer                                                                |\n| `generator`          | [RFC4122][rfc_4122_spec] generator | `Function` | Generates a `String` for request ID.                                                     |\n| `version`            | 2                                  | `Number`   | JSON-RPC version to support (1 or 2)                                                     |\n| `notificationIdNull` | `false`                            | `Boolean`  | *Since 3.6.1*. When true \"id\" property of a request will be set to null when version 2.  |\n\n[rfc_4122_spec]: http://www.ietf.org/rfc/rfc4122.txt\n\n##### Client.http\n\nUses the same options as [http.request][nodejs_docs_http_request] in addition to these options:\n\n| Option     \t| Default \t  | Type     \t| Description                    \t        |\n|------------\t|------------ |----------\t|---------------------------------------- |\n| `encoding` \t| `utf8`  \t  | `String` \t| Determines the encoding to use \t        |\n| `headers` \t| `undefined` | `Object` \t| Extend the headers sent by the client \t|\n\n###### Client.http Events\n\nThe HTTP client will emit the following events:\n\n| Event           \t| When                              \t| Arguments                                                                 \t| Notes                                     \t|\n|-----------------\t|-----------------------------------\t|---------------------------------------------------------------------------\t|-------------------------------------------\t|\n| `http request`  \t| Created an HTTP request           \t| 1. Instance of `http.ClientRequest`                                       \t|                                           \t|\n| `http response` \t| Received an HTTP response         \t| 1. Instance of `http.IncomingMessage` 2. Instance of `http.ClientRequest` \t|                                           \t|\n| `http error`    \t| Underlying stream emits `error`   \t| 1. Error                                                                  \t|                                           \t|\n| `http timeout`  \t| Underlying stream emits `timeout` \t|                                                                           \t| Automatically causes the request to abort \t|\n\nIt is possible to pass a string URL as the first argument. The URL will be run through [url.parse][nodejs_docs_url_parse]. Example:\n\n```javascript\nconst jayson = require('jayson');\nconst client = jayson.Client.http('http://localhost:3000');\n// client.options is now the result of url.parse\n```\n\n[nodejs_docs_http_request]: http://nodejs.org/docs/latest/api/http.html#http_http_request_options_callback\n[nodejs_docs_url_parse]: http://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost\n\n##### Client.https\n\nUses the same options as [https.request][nodejs_docs_https_request] in addition _to the same options as `Client.http`_. This means it is also possible\nto pass a string URL as the first argument and have it interpreted by [url.parse][nodejs_docs_url_parse].\n\nWill emit the [same custom events](#clienthttp-events) as `Client.http`.\n\n[nodejs_docs_https_request]: http://nodejs.org/api/all.html#all_https_request_options_callback\n\n##### Client.tcp\n\nUses the same options as [net.connect][nodejs_docs_net_connect].\n\n###### Client.tcp Events\n\n*Since version 3.5.1*\n\nThe TCP client will emit the following events:\n\n| Event      | When                   | Arguments                     | Notes                         |\n|------------|------------------------|-------------------------------|-------------------------------|\n| tcp socket | TCP socket is opened   | 1. `net.Socket`               | Can be used to setup timeouts |\n| tcp error  | TCP socket emits error | 1. Error emit by `net.Socket` |                               |\n\n[nodejs_docs_net_connect]: https://nodejs.org/api/net.html#net_net_connect\n\n##### Client.tls\n\nUses the same options as [tls.connect][nodejs_docs_tls_connect].\n\n###### Client.tls Events\n\n*Since version 3.5.1*\n\nThe TLS client will emit the following events:\n\n| Event      | When                   | Arguments                     | Notes                         |\n|------------|------------------------|-------------------------------|-------------------------------|\n| tcp socket | TCP socket is opened   | 1. `net.Socket`               | Can be used to setup timeouts |\n| tcp error  | TCP socket emits error | 1. Error emit by `net.Socket` |                               |\n\n[nodejs_docs_tls_connect]: https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n\n##### Client.browser\n\nThe browser client is a simplified version of the regular client for use browser-side. It does not have any dependencies on node.js core libraries, but does depend on the `uuid` package for generating request ids. It also does not know how to \"send\" a request to a server like the other clients.\n\nBecause it does not depend on any core libraries, the browser client is **not** an instance of `JaysonClient` or `EventEmitter` and therefore does **not** emit any of the normal request events that the other clients do.\n\nTo use the browser client, `require('jayson/lib/client/browser')` and pass a calling/transport function as the first argument. The transport function receives a JSON-RPC string request and is expected to callback with a string response received from the server (not JSON) or an error (not a JSON-RPC error).\n\nThe reason for dealing with strings is to support the `reviver` and `replacer` options like the other clients.\n\nThis client example in [examples/browser_client/client.js](examples/browser_client/client.js) below uses [node-fetch](https://github.com/bitinn/node-fetch) in the transport function, but a dropin replacement for use in an *actual* browser could instead use [whatwg-fetch](https://github.com/github/fetch/issues/184).\n\nThe browser client has a separate TypeScript type declaration available in `jayson/lib/client/browser/index.d.ts` which depends on the main Jayson type declaration.\n\n```javascript\n'use strict';\n\nconst jaysonBrowserClient = require('jayson/lib/client/browser');\nconst fetch = require('node-fetch');\n\nconst callServer = function(request, callback) {\n  const options = {\n    method: 'POST',\n    body: request,\n    headers: {\n      'Content-Type': 'application/json',\n    }\n  };\n\n  fetch('http://localhost:3000', options)\n    .then(function(res) { return res.text(); })\n    .then(function(text) { callback(null, text); })\n    .catch(function(err) { callback(err); });\n};\n\nconst client = new jaysonBrowserClient(callServer, {\n  // other options go here\n});\n\nclient.request('multiply', [5, 5], function(err, error, result) {\n  if(err) throw err;\n  console.log(result); // 25\n});\n```\n\n##### Client.websocket\n\n*Since v3.6.4*\n\nExperimental websocket client that wraps around an `isomorphic-ws` instance. Will listen to every received (JSON) message and see if it matches any of the currently outstanding requests made, in which case the callback of that outstanding request will fire. If you do not provide the `timeout` option it will wait forever. Has a promise-based equivalent receiving the same options, and a [companion jayson server](#serverwebsocket) where you can find an example.\n\nHas the following options:\n\n| Option    | Default     | Type                                | Description                                                          |\n|-----------|-------------|-------------------------------------|----------------------------------------------------------------------|\n| `url`     | `undefined` | `String`                            | First argument to `require('isomorphic-ws')` if `options.ws` not set |\n| `ws`      | `undefined` | `require('isomorphic-ws')` instance | WebSocket instance                                                   |\n| `timeout` | `undefined` | `Number`                            | Timeout in ms before callbacking with an error                       |\n\nIf you want to \"unwrap\" the `isomorphic-ws` instance you can use the `Client.websocket.prototype.unlisten` which stops listening for messages on the `isomorphic-ws` instance.\n\n- [isomorphic-ws docs](https://github.com/heineiuo/isomorphic-ws)\n\n#### Notifications\n\nNotification requests are for cases where the reply from the server is not important and should be ignored. This is accomplished by setting the `id` property of a request object to `null`.\n\nClient example in [examples/notifications/client.js](examples/notifications/client.js) doing a notification request:\n\n```javascript\nconst jayson = require('jayson');\n\nconst client = jayson.Client.http({\n  port: 3000\n});\n\n// the third parameter is set to \"null\" to indicate a notification\nclient.request('ping', [], null, function(err) {\n  if(err) throw err;\n  console.log('ok'); // request was received successfully\n});\n```\n\nServer example in [examples/notifications/server.js](examples/notifications/server.js):\n\n```javascript\nconst jayson = require('jayson');\n\nconst server = new jayson.Server({\n  ping: function(args, callback) {\n    // do something, do nothing\n    callback();\n  }\n});\n\nserver.http().listen(3000);\n```\n\n##### Notes\n\n* Any value that the server returns will be discarded when doing a notification request.\n* Omitting the third argument `null` to `Client.prototype.request` does not generate a notification request. This argument has to be set explicitly to `null` for this to happen.\n* Network errors and the like will still reach the callback. When the callback is invoked (with or without error) one can be certain that the server has received the request.\n* See the [Official JSON-RPC 2.0 Specification][jsonrpc-spec] for additional information on how Jayson handles notifications that are erroneous.\n* *Since 3.6.1* When making a JSON-RPC 2.0 notification request the \"id\" property will be omitted in the request object. In previous versions it was set to `null` against the recommendation of the official specification. This behaviour can be overridden with the `notificationIdNull` option.\n\n\n#### Batches\n\nA batch request is an array of individual requests that are sent to the server as one. Doing a batch request is very simple in Jayson and consists of constructing an array of individual requests (created by not passing a callback to `Client.prototype.request`) that is then itself passed to `Client.prototype.request`. \n\nCombined server/client example in [examples/batch_request/index.js](examples/batch_request/index.js):\n\n```javascript\nconst jayson = require('jayson');\n\nconst server = new jayson.Server({\n  add: function(args, callback) {\n    callback(null, args[0] + args[1]);\n  }\n});\n\nconst client = new jayson.Client(server);\n\nconst batch = [\n  client.request('does_not_exist', [10, 5]),\n  client.request('add', [1, 1]),\n  client.request('add', [0, 0], null) // a notification\n];\n\nclient.request(batch, function(err, errors, successes) {\n  if(err) throw err;\n  console.log('errors', errors); // array of requests that errored\n  console.log('successes', successes); // array of requests that succeeded\n});\n\nclient.request(batch, function(err, responses) {\n  if(err) throw err;\n  console.log('responses', responses); // all responses together\n});\n```\n\n##### Notes\n\n* See the [Official JSON-RPC 2.0 Specification][jsonrpc-spec] for additional information on how Jayson handles different types of batches, mainly with regards to notifications, request errors and so forth.\n* There is no guarantee that the results will be in the same order as request Array `request`. To find the right result, compare the ID from the request with the ID in the result yourself.\n\n#### Client callback syntactic sugar\n\nWhen the length (number of arguments) of a client callback function is either 2 or 3 it receives slightly different values when invoked.\n\n* 2 arguments: first argument is an error or `null`, second argument is the response object as returned (containing _either_ a `result` or a `error` property) or `null` for notifications.\n* 3 arguments: first argument is an error or null, second argument is a JSON-RPC `error` property or `null` (if success), third argument is a JSON-RPC `result` property or `null` (if error).\n\nWhen doing a batch request with a 3-length callback, the second argument will be an array of requests with a `error` property and the third argument will be an array of requests with a `result` property.\n\n#### Client events\n\nA client will emit the following events (in addition to any special ones emitted by a specific interface):\n\n| Event      \t| When                        \t| Arguments                                     \t| Notes \t|\n|------------\t|-----------------------------\t|-----------------------------------------------\t|-------\t|\n| `request`  \t| About to dispatch a request \t| 1: Request object                             \t|       \t|\n| `response` \t| Received a response         \t| 1: Request object 2: Response object received \t|       \t|\n\n### Server\n\nThe server classes are available as the `Server` or `server` property of `require('jayson')`.\n\nThe server also sports several interfaces that can be accessed as properties of an instance of `Server`.\n\n#### Server interface description\n\n| Name                \t| Description                                                                                \t|\n|---------------------\t|--------------------------------------------------------------------------------------------\t|\n| `Server`            \t| Base interface for a server that supports receiving JSON-RPC requests                      \t|\n| `Server.tcp`        \t| TCP server that inherits from [net.Server][nodejs_doc_net_server]                          \t|\n| `Server.tls`        \t| TLS server that inherits from [tls.Server][nodejs_doc_tls_server]                          \t|\n| `Server.http`       \t| HTTP server that inherits from [http.Server][nodejs_doc_http_server]                       \t|\n| `Server.https`      \t| HTTPS server that inherits from [https.Server][nodejs_doc_https_server]                    \t|\n| `Server.websocket`   \t| Websocket server that uses [isomorphic-ws Server][isomorphic-ws-docs]                     \t|\n| `Server.middleware` \t| Method that returns a [Connect][connect]/[Express][express] compatible middleware function \t|\n\n[isomorphic-ws-docs]: https://github.com/heineiuo/isomorphic-ws\n[nodejs_doc_net_server]: http://nodejs.org/docs/latest/api/net.html#net_class_net_server\n[nodejs_doc_http_server]: http://nodejs.org/docs/latest/api/http.html#http_class_http_server\n[nodejs_doc_https_server]: http://nodejs.org/docs/latest/api/https.html#https_class_https_server\n[nodejs_doc_tls_server]: https://nodejs.org/api/tls.html#tls_class_tls_server\n[connect]: http://www.senchalabs.org/connect/\n[express]: http://expressjs.com/\n\nServers supports these options:\n\n| Option              \t| Default         \t| Type                \t| Description                                               \t|\n|---------------------\t|-----------------\t|---------------------\t|-----------------------------------------------------------\t|\n| `reviver`           \t| `null`          \t| `Function`          \t| `JSON.parse` reviver                                      \t|\n| `replacer`          \t| `null `         \t| `Function`          \t| `JSON.stringify` replacer                                 \t|\n| `router`            \t| `null `         \t| `Function`          \t| Return the function for [method routing](#method-routing) \t|\n| `useContext`         \t| `false`          \t| `Boolean`           \t| Passed to `methodConstructor` options                     \t|\n| `params`            \t| `undefined`     \t| `Array/Object/null` \t| Passed to `methodConstructor` options                     \t|\n| `methodConstructor` \t| `jayson.Method` \t| `Function`          \t| Server functions are made an instance of this class       \t|\n| `version`           \t| 2               \t| `Number`            \t| JSON-RPC version to support (1 or 2)                      \t|\n| `maxBatchLength`     \t| Infinity         \t| `Number`            \t| Maximum batch requests allowed                                |\n\n##### Server.tcp\n\nUses the same options as the base class. Inherits from [net.Server][nodejs_doc_net_server].\n\n##### Server.tls\n\nUses the same options as the base class. Inherits from [tls.Server][nodejs_doc_tls_server].\n\n##### Server.http\n\nUses the same options as the base class. Inherits from [http.Server][nodejs_doc_http_server].\n\n###### Server.http Events\n\n| Event           \t| When                          \t| Arguments                                                                    \t| Notes \t|\n|-----------------\t|-------------------------------\t|------------------------------------------------------------------------------\t|-------\t|\n| `http request`  \t| Incoming HTTP request         \t| 1. Instance of `http.IncomingMessage`                                        \t|       \t|\n| `http response` \t| About to send a HTTP response \t| 1. Instance of `http.ServerResponse` 2. Instance of `http. IncomingMessage ` \t|       \t|\n\n##### Server.https\n\nUses the same options as the base class. Inherits from [https.Server][nodejs_doc_https_server] and `jayson.Server.http`. For information on how to configure certificates, [see the documentation on https.Server][nodejs_doc_https_server].\n\nWill emit the [same custom events](#serverhttp-events) as `Server.http`.\n\n##### Server.middleware\n\nUses the same options as the base class. Returns a function that is compatible with [Connect][connect] or [Express][express]. Will expect the request to be `req.body`, meaning that the request body must be parsed (typically using `connect.bodyParser`) before the middleware is invoked.\n\nThe middleware supports the following options:\n\n| Option \t| Default \t| Type      \t| Description                                                                               \t|\n|--------\t|---------\t|-----------\t|-------------------------------------------------------------------------------------------\t|\n| `end`  \t| `true`  \t| `Boolean` \t| If set to `false` causes the middleware to `next()` instead of `res.end()` when finished. \t|\n\nMiddleware example in [examples/middleware/server.js](examples/middleware/server.js):\n\n```javascript\nconst jayson = require('jayson');\nconst jsonParser = require('body-parser').json;\nconst connect = require('connect');\nconst app = connect();\n\nconst server = new jayson.Server({\n  add: function(args, callback) {\n    callback(null, args[0] + args[1]);\n  }\n});\n\n// parse request body before the jayson middleware\napp.use(jsonParser());\napp.use(server.middleware());\n\napp.listen(3000);\n```\n\n##### Server.websocket\n\nWebsocket server that either wraps around a provided `require('isomorphic-ws').Server` instance or creates one from scratch. Expects **every** incoming message on every connection to be a valid JSON-RPC call.\n\nThe websocket server supports the following options in addition to the base class:\n\n| Option | Default     | Type                              | Description                     |\n|--------|-------------|-----------------------------------|---------------------------------|\n| `wss`  | `undefined` | `require('isomorphic-ws').Server` | If not provided will be created |\n\n\nWebsocket server example in [examples/websocket/server.js](examples/websocket/server.js):\n\n```javascript\nconst jayson = require('jayson');\n\nconst server = new jayson.Server({\n  add: function (args, done) {\n    const sum = args.reduce((sum, val) => sum + val, 0);\n    done(null, sum);\n  },\n});\n\nconst wss = server.websocket({\n  port: 12345,\n});\n```\n\nWebsocket client example in [examples/websocket/client.js](examples/websocket/client.js):\n\n```javascript\nconst jayson = require('jayson');\n\nconst client = jayson.Client.websocket({\n  url: 'ws://localhost:12345',\n});\n\nclient.ws.on('open', function () {\n  client.request('add', [1,2,3,4], function (err, result) {\n    console.log(err, result);\n    client.ws.close();\n  });\n});\n```\n\n#### Many interfaces at the same time\n\nA Jayson server can use many interfaces at the same time.\n\nServer example in [examples/many_interfaces/server.js](examples/many_interfaces/server.js) that listens to both `http` and a `https` requests:\n\n```javascript\nconst jayson = require('jayson');\n\nconst server = new jayson.Server();\n\n// \"http\" will be an instance of require('http').Server\nconst http = server.http();\n\n// \"https\" will be an instance of require('https').Server\nconst https = server.https({\n  //cert: require('fs').readFileSync('cert.pem'),\n  //key require('fs').readFileSync('key.pem')\n});\n\nhttp.listen(80, function() {\n  console.log('Listening on *:80');\n});\n\nhttps.listen(443, function() {\n  console.log('Listening on *:443');\n});\n```\n\n#### Using the server as a relay\n\nPassing an instance of a client as a method to the server makes the server relay incoming requests to wherever the client is pointing to. This might be used to delegate computationally expensive functions into a separate server or to abstract a cluster of servers behind a common interface.\n\nFrontend server example in [examples/relay/server_public.js](examples/relay/server_public.js) listening on `*:3000`:\n\n```javascript\nconst jayson = require('jayson');\n\n// create a server where \"add\" will relay a localhost-only server\nconst server = new jayson.Server({\n  add: jayson.Client.http({\n    port: 3001\n  })\n});\n\n// let the frontend server listen to *:3000\nserver.http().listen(3000);\n```\n\nBackend server example in [examples/relay/server_private.js](examples/relay/server_private.js) listening on `*:3001`:\n\n```javascript\nconst jayson = require('jayson');\n\nconst server = new jayson.Server({\n  add: function(args, callback) {\n    callback(null, args[0] + args[1]);\n  }\n});\n\n// let the backend listen to *:3001\nserver.http().listen(3001);\n```\n\nEvery request to `add` on the public server will now relay the request to the private server. See the client example in [examples/relay/client.js](examples/relay/client.js).\n\n#### Method routing\n\nPassing a property named `router` in the server options will enable you to write your own logic for routing requests to specific functions. \n\nServer example with custom routing logic in [examples/method_routing/server.js](examples/method_routing/server.js):\n\n```javascript\nconst jayson = require('jayson');\n\nconst methods = {\n  add: function(args, callback) {\n    callback(null, args[0] + args[1]);\n  }\n};\n\nconst server = new jayson.Server(methods, {\n  router: function(method, params) {\n    // regular by-name routing first\n    if(typeof(this._methods[method]) === 'function') return this._methods[method];\n    if(method === 'add_2') {\n      const fn = server.getMethod('add').getHandler();\n      return new jayson.Method(function(args, done) {\n        args.unshift(2);\n        fn(args, done);\n      });\n    }\n  }\n});\n\nserver.http().listen(3000);\n```\n\nClient example in [examples/method_routing/client.js](examples/method_routing/client.js) invoking `add_2` on the above server:\n\n```javascript\nconst jayson = require('jayson');\n\n// create a client\nconst client = jayson.Client.http({\n  port: 3000\n});\n\n// invoke \"add_2\"\nclient.request('add_2', [3], function(err, response) {\n  if(err) throw err;\n  console.log(response.result); // 5!\n});\n```\n\nServer example of nested routes where each property is separated by a dot (you do not need to use the router option for this):\n\n```javascript\nconst jayson = require('jayson');\n\nconst methods = {\n  foo: {\n    bar: function(callback) {\n      callback(null, 'ping pong');\n    }\n  },\n  math: {\n    add: function(args, callback) {\n      callback(null, args[0] + args[1]);\n    }\n  }\n};\n\n// this reduction produces an object like this: {'foo.bar': [Function], 'math.add': [Function]}\nconst map = Object.keys(methods).reduce(collapse('', '.', methods), {});\nconst server = new jayson.Server(map);\n\nfunction collapse(stem, sep, obj) {\n  return function(map, key) {\n    const prop = stem ? stem + sep + key : key;\n    const value = obj[key];\n    if(typeof value === 'function') map[prop] = value;\n    else if(typeof value === 'object' && value !== null) map = Object.keys(value).reduce(collapse(prop, sep, value), map);\n    return map;\n  }\n}\n```\n\n##### Notes\n\n* If `router` does not return anything, the server will respond with a `Method Not Found` error.\n* The `Server.prototype` methods `method`, `methods`, `removeMethod` and `hasMethod` will not use the `router` method, but will operate on the internal `Server.prototype._methods` map.\n* The `router` method is expected to return instances of `jayson.Method` (>=1.2.0)\n\n#### Method definition\n\nYou can also define server methods inside a wrapping object named `jayson.Method`. This allows additional options about the method to be specified. Using this wrapper - explicitly or implicitly (via server options) - makes it trivial to have your method accept a variable amount of arguments.\n\nThe method class is available as the `Method` or `method` property of  `require('jayson')`. It supports these options:\n\n| Option    \t| Default                        \t| Type                \t| Description                                                            \t|\n|-----------\t|--------------------------------\t|---------------------\t|------------------------------------------------------------------------\t|\n| `handler` \t|                                \t| `Function`          \t| The actual function that will handle a JSON-RPC request to this method \t|\n| `useContext` \t| false \t| `Boolean`           \t| When true, the handler will receive a context object as the second argument\n| `params`  \t| null                           \t| `Array\\|Object\\|null` \t| Force JSON-RPC parameters to be of a certain type                      \t|\n\nServer example showcasing most features and options in [examples/method_definitions/server.js](examples/method_definitions/server.js):\n\n```javascript\nconst jayson = require('jayson');\n\nconst methods = {\n\n  // this function will be wrapped in jayson.Method with options given to the server\n  sum: function(args, done) {\n    done(null, sum(args));\n  },\n\n  // this function always receives a context object as second arg\n  // it can be overriden on the server level\n  context: jayson.Method(function(args, context, done) {\n    done(null, context);\n  }, {useContext: true}),\n\n  // specifies some default values (alternate definition too)\n  sumDefault: jayson.Method(function(args, done) {\n    const total = sum(args);\n    done(null, total);\n  }, {\n    params: {a: 2, b: 5} // map of defaults\n  }),\n\n  // this method returns true when it gets an array (which it always does)\n  isArray: new jayson.Method({\n    handler: function(args, done) {\n      const result = Array.isArray(args);\n      done(null, result);\n    },\n    params: Array // could also be \"Object\"\n  })\n\n};\n\nconst server = new jayson.Server(methods, {\n  // these options are given as options to jayson.Method when adding the method \"sum\".\n  // this is because it is not wrapped in jayson.Method like the others.\n  useContext: false,\n  params: Array\n});\n\nserver.http().listen(3000);\n\n// sums all numbers in an array or object\nfunction sum(list) {\n  return Object.keys(list).reduce(function(sum, key) { return sum + list[key]; }, 0);\n}\n```\n\nClient example in [examples/method_definitions/client.js](examples/method_definitions/client.js):\n\n```javascript\nconst jayson = require('jayson');\n\nconst client = jayson.Client.http({\n  port: 3000\n});\n\n// invoke \"sum\" with array\nclient.request('sum', [3, 5, 9, 11], function(err, response) {\n  if(err) throw err;\n  console.log(response.result); // 28\n});\n\n// invoke \"sum\" with an object\nclient.request('sum', {a: 2, b: 3, c: 4}, function(err, response) {\n  if(err) throw err;\n  console.log(response.result); // 9\n});\n\n// invoke \"sumDefault\" with object missing some defined members\nclient.request('sumDefault', {b: 10}, function(err, response) {\n  if(err) throw err;\n  console.log(response.result); // 12\n});\n\n// invoke \"isArray\" with an Object\nclient.request('isArray', {a: 5, b: 2, c: 9}, function(err, response) {\n  if(err) throw err;\n  console.log(response.result); // true\n});\n\n// invoke \"context\"\nclient.request('context', {hello: 'world'}, function(err, response) {\n  if(err) throw err;\n  console.log(response.result); // {} - just an empty object\n});\n```\n\n#### Server events\n\nIn addition to events that are specific to certain interfaces, all servers will emit the following events:\n\n| Event      \t| When                                     \t| Arguments                            \t| Notes                          \t|\n|------------\t|------------------------------------------\t|--------------------------------------\t|--------------------------------\t|\n| `request`  \t| Interpretable non-batch request received \t| 1: Request object                    \t|                                \t|\n| `response` \t| Returning a response                     \t| 1: Request object 2: Response object \t|                                \t|\n| `batch`    \t| Interpretable batch request received     \t| 1. Array of requests                 \t| Emits `request` for every part \t|\n\n#### Server Errors\n\nIf you should like to return an error from an method request to indicate a failure, remember that the [JSON-RPC 2.0][jsonrpc-spec] specification requires the error to be an `Object` with a `code (Integer/Number)` to be regarded as valid. You can also provide a `message (String)` and a `data (Object)` with additional information. Example: \n\n```javascript\nconst jayson = require('jayson');\n\nconst server = new jayson.Server({\n  i_cant_find_anything: function(args, callback) {\n    const error = {code: 404, message: 'Cannot find ' + args.id};\n    callback(error); // will return the error object as given\n  },\n  i_cant_return_a_valid_error: function(callback) {\n    callback({message: 'I forgot to enter a code'}); // will return a pre-defined \"Internal Error\"\n  }\n});\n```\n\n##### Predefined Errors\n\nIt is also possible to cause a method to return one of the predefined [JSON-RPC 2.0 error codes][jsonrpc-spec#error_object] using the server helper function `Server.prototype.error` inside of a server method. Example:\n\n[jsonrpc-spec#error_object]: http://jsonrpc.org/spec.html#error_object\n\n```javascript\nconst jayson = require('jayson');\n\nconst server = new jayson.Server({\n  invalid_params: function(args, callback) {\n    const error = this.error(-32602); // returns an error with the default properties set\n    callback(error);\n  }\n});\n```\n\nYou can even override the default messages:\n\n```javascript\nconst jayson = require('jayson');\n\nconst server = new jayson.Server({\n  error_giver_of_doom: function(callback) {\n    callback(true) // invalid error format, which causes an Internal Error to be returned instead\n  }\n});\n\n// Override the default message\nserver.errorMessages[Server.errors.INTERNAL_ERROR] = 'I has a sad. I cant do anything right';\n```\n\n#### Server CORS\n\nJayson does not include functionality for supporting CORS requests natively but it is easy to use a CORS-enabling middleware\nlike [cors](https://github.com/expressjs/cors). An example of this can be found in [examples/cors/server.js](examples/cors/server.js):\n\n```javascript\nconst jayson = require('jayson');\nconst cors = require('cors');\nconst connect = require('connect');\nconst jsonParser = require('body-parser').json;\nconst app = connect();\n\nconst server = new jayson.Server({\n  myNameIs: function(args, callback) {\n    callback(null, 'Your name is: ' + args.name);\n  }\n});\n\napp.use(cors({methods: ['POST']}));\napp.use(jsonParser());\napp.use(server.middleware());\n\napp.listen(3000);\n```\n\n#### Server Context\n\n*Since version 3.0.0*\n\nYou can provide an optional context object to JSON-RPC method handlers. This can be used to give extra data to a handler  such as request headers, authentication tokens, and so on.\n\nThis feature is unlocked by having `jayson.Method` accepts a boolean option called `useContext`. It always defaults to `false` for backwards compatibility. When it is set to `true` the method handler that `jayson.Method` wraps will **always** receive a context object as the second argument. The object can be given as the third argument to `jayson.Server.prototype.call`.\n\nServer example in [examples/context/server.js](examples/context/server.js):\n\n```javascript\nconst jayson = require('jayson');\nconst jsonParser = require('body-parser').json;\nconst express = require('express');\nconst app = express();\n\nconst server = new jayson.Server({\n\n  getHeaders: function(args, context, callback) {\n    callback(null, context.headers);\n  },\n\n  // old method not receiving a context object (here for reference)\n  oldMethod: new jayson.Method(function(args, callback) {\n    callback(null, {});\n  }, {\n    // this setting overrides the server option set below for this particular method only\n    useContext: false\n  })\n\n}, {\n  // all methods will receive a context object as the second arg\n  useContext: true\n});\n\napp.use(jsonParser());\napp.use(function(req, res, next) {\n  // prepare a context object passed into the JSON-RPC method\n  const context = {headers: req.headers};\n  server.call(req.body, context, function(err, result) {\n    if(err) return next(err);\n    res.send(result || {});\n  });\n});\n\napp.listen(3001);\n```\n\nClient example in [examples/context/client.js](examples/context/client.js):\n\n```javascript\nconst jayson = require('jayson');\n\n// create a client\nconst client = jayson.Client.http({\n  port: 3001\n});\n\n// invoke \"getHeaders\"\nclient.request('getHeaders', {}, function(err, response) {\n  if(err) throw err;\n  console.log(response.result);\n});\n```\n\n##### Notes\n\n- `jayson.Server` also accepts `useContext` as an option, and passes the value on to the `jayson.Method` constructor. This option can be overriden on a per-method basis as shown above.\n- Individual requests in a JSON-RPC batch will all receive the exact same context object in their handler - take care not to mutate it\n- If a falsy context value is given to `jayson.Server.prototype.call`, an empty object will be created\n- None of the current jayson server transports (http, https, tls, tcp, middleware) can make use of the context object. You will need to rig your own transport implementation, like the one above based on an `express` http server. See the [FAQ](#faq) for more info about this.\n\n### Revivers and Replacers\n\nJSON lacks support for representing types other than the simple ones defined in the [JSON specification][jsonrpc-spec]. Fortunately the JSON methods in JavaScript (`JSON.parse` and `JSON.stringify`) provide options for custom serialization/deserialization routines. Jayson allows you to pass your own routines as options to both clients and servers.\n\nSimple example transferring the state of an object between a client and a server:\n\nShared code between the server and the client in [examples/reviving_and_replacing/shared.js](examples/reviving_and_replacing/shared.js):\n\n```javascript\n'use strict';\n\nconst Counter = exports.Counter = function(value) {\n  this.count = value || 0;\n};\n\nCounter.prototype.increment = function() {\n  this.count += 1;\n};\n\nexports.replacer = function(key, value) {\n  if(value instanceof Counter) {\n    return {$class: 'counter', $props: {count: value.count}};\n  }\n  return value;\n};\n\nexports.reviver = function(key, value) {\n  if(value && value.$class === 'counter') {\n    const obj = new Counter();\n    for(const prop in value.$props) obj[prop] = value.$props[prop];\n    return obj;\n  }\n  return value;\n};\n```\n\nServer example in [examples/reviving_and_replacing/server.js](examples/reviving_and_replacing/server.js):\n\n```javascript\nconst jayson = require('jayson');\nconst shared = require('./shared');\n\n// Set the reviver/replacer options\nconst options = {\n  reviver: shared.reviver,\n  replacer: shared.replacer\n};\n\n// create a server\nconst server = new jayson.Server({\n  increment: function(args, callback) {\n    args.counter.increment();\n    callback(null, args.counter);\n  }\n}, options);\n\nserver.http().listen(3000);\n```\n\nA client example in [examples/reviving_and_replacing/client.js](examples/reviving_and_replacing/client.js) invoking \"increment\" on the server:\n\n```javascript\nconst jayson = require('jayson');\nconst shared = require('./shared');\n\nconst client = jayson.Client.http({\n  port: 3000,\n  reviver: shared.reviver,\n  replacer: shared.replacer\n});\n\n// create the object\nconst params = {\n  counter: new shared.Counter(2)\n};\n\n// invoke \"increment\"\nclient.request('increment', params, function(err, response) {\n  if(err) throw err;\n  const result = response.result;\n  console.log(\n    result instanceof shared.Counter, // true\n    result.count, // 3\n    params.counter === result // false - result is a new object\n  );\n});\n```\n\n#### Notes\n\n* Instead of using a replacer, it is possible to define a `toJSON` method for any JavaScript object. Unfortunately there is no corresponding method for reviving objects (that would not work, obviously), so the _reviver_ always has to be set up manually.\n\n### Named parameters\n\nIt is possible to specify named parameters when doing a client request by passing an Object instead of an Array.\n\nClient example in [examples/named_parameters/client.js](examples/named_parameters/client.js):\n\n```javascript\nconst jayson = require('jayson');\n\nconst client = jayson.Client.http({\n  port: 3000\n});\n\nclient.request('add', {b: 1, a: 2}, function(err, response) {\n  if(err) throw err;\n  console.log(response.result); // 3!\n});\n```\n\nServer example in [examples/named_parameters/server.js](examples/named_parameters/server.js):\n\n```javascript\nconst jayson = require('jayson');\n\nconst server = new jayson.Server({\n  add: function(params, callback) {\n    callback(null, params.a + params.b);\n  }\n});\n\nserver.http().listen(3000);\n```\n\n#### Notes\n\n* If requesting methods on a Jayson server, arguments left out will be `undefined`\n* Too many arguments or arguments with invalid names will be ignored\n* It is assumed that the last argument to a server method is the callback and it will not be filled with something else\n* Parsing a function signature and filling in arguments is generally *not recommended* and should be avoided\n\n## Promises\n\n[es6-promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n\n*Since version 2.0.0*\n\nA separate tree that does limited usage of the [ES6 Promise][es6-promise] object is available. The internal API remains callback based, with the addition that promises may be used for two things:\n\n* Returning a Promise when requesting a JSON-RPC method using a Client\n* Returning a Promise inside of a Server method\n\nTo use the separate tree, do a `require('jayson/promise')` instead of `require('jayson')`.\n\nServer example in [examples/promise/server.js](examples/promise/server.js) showing how to return a `Promise` in a server method:\n\n```javascript\nconst jayson = require('jayson/promise');\n\nconst server = new jayson.Server({\n\n  add: async function(args) {\n    const sum = Object.keys(args).reduce(function(sum, key) { return sum + args[key]; }, 0);\n    return sum;\n  },\n\n  // example on how to reject\n  rejection: async function(args) {\n    // server.error just returns {code: 501, message: 'not implemented'}\n    throw server.error(501, 'not implemented');\n  }\n\n});\n\nserver.http().listen(3000);\n```\n\nClient example in [examples/promise/client.js](examples/promise/client.js) showing how to do a request:\n\n```javascript\nconst jayson = require('jayson/promise');\n\nconst client = jayson.Client.http({\n  port: 3000\n});\n\nconst reqs = [\n  client.request('add', [1, 2, 3, 4, 5]),\n  client.request('rejection', [])\n];\n\nPromise.all(reqs).then(function(responses) {\n  console.log(responses[0].result);\n  console.log(responses[1].error);\n});\n```\n\n#### Notes\n\n* JSON-RPC errors will not result in rejection of the Promise. It is however possible that a future version will include a client setting to have JSON-RPC errors result in rejection. Please note that network errors and the like will result in rejection.\n* A `Promise` is considered to have been returned from a server method if the returned object has a property `then` that is a function.\n\n#### Promise Batches\n\n*Since version 2.0.5*\n\nSometimes you may want to return raw requests from a promise client. This needs to be handled differently, because `PromiseClient.prototype.request` would normally always be expected to *return a Promise* which we in this case don't want.\n\nTo solve this, we need to set the fourth parameter to `PromiseClient.prototype.request` explicitly to `false` in order to *not* return a Promise.\n\nClient example in [examples/promise_batches/client.js](examples/promise_batches/client.js) showing how to properly execute a batch request:\n\n```javascript\nconst jayson = require('jayson/promise');\n\nconst client = jayson.Client.http({\n  port: 3000\n});\n\nconst batch = [\n  client.request('add', [1, 2, 3, 4, 5], undefined, false),\n  client.request('add', [5, 6, 7, 8, 9], undefined, false),\n];\n\nclient.request(batch).then(function(responses) {\n  console.log(responses[0].result); // 15\n  console.log(responses[1].result); // 35\n});\n```\n\n##### Notes\n\n* The third parameter to `PromiseClient.prototype.request` above is explicitly set to `undefined` - this parameter would normally represent the desired ID of the call. Remember that `null` would mean a notification (which does not return a response) and other falsy values may actually be used as ids. Setting `undefined` ensures that the id is generated automatically.\n\n#### Promise Browser Client\n\nA browser client that has no dependencies on node.js core libraries is available too. It works similar to how the regular callback-style [Browser Client](#clientbrowser) works. Here is an example:\n\n```javascript\n'use strict';\n\nconst jaysonPromiseBrowserClient = require('jayson/promise/lib/client/browser');\nconst fetch = require('node-fetch');\n\nconst callServer = function(request) {\n  const options = {\n    method: 'POST',\n    body: request,\n    headers: {\n      'Content-Type': 'application/json',\n    }\n  };\n  return fetch('http://localhost:3000', options).then(res => res.text());\n};\n\nconst client = new jaysonPromiseBrowserClient(callServer, {\n  // other options go here\n});\n\nclient.request('multiply', [5, 5]).then(function(result) {\n  console.log(result);\n}, function(err) {\n  console.error(err);\n});\n```\n\nPlease refer to the [regular browser client](#clientbrowser) section of the README for more information.\n\n## FAQ\n\n### How can I pass HTTP headers/session/etc into my JSON-RPC request handler?\n\n*Support for method context added in version 3.0.0*\n\nSee [Server context](#server-context) section.\n\n### What is the recommended way to use jayson?\n\nUsing the provided clients and servers for http, https, tls, tcp and the express middleware is fine and works well for most use cases. However, sometimes issues like these crop up (quotes below are not directly from issue posters):\n\n- \"The (non-jayson) HTTP/TCP server I'm interacting with expects every call to terminate with `\\r\\n` but the jayson client does not\"\n- [\"How can my jayson TLS server support requests encoded such and such?\"](https://github.com/tedeh/jayson/issues/86)\n- [\"How can I make the jayson HTTP middleware accept GET requests?\"](https://github.com/tedeh/jayson/issues/70)\n- [\"My jayson client interacting with a (non-jayson) TLS server closes the connection after every sent request. I think this is wasteful!\"](https://github.com/tedeh/jayson/issues/92)\n\nThese are not issues with jayson, but stem from the fact that [JSON-RPC 2.0 specification][jsonrpc-spec] is **transport agnostic** and these kind of behaviours are **not defined** by that specification. The clients provided by jayson for http, https, tls, tcp are made to work and tested with their corresponding jayson server implementation. Any other compatibility with any other server or client is *accidental* when it comes to **details of the transport layer**. With that said, jayson is made to be 100 % compatible with the [JSON-RPC 2.0 specification][jsonrpc-spec] and compatibility with other non-jayson servers or clients when it comes to the *application layer* is pretty much guaranteed.\n\nThe library author [tedeh](https://github.com/tedeh) therefore recommends that if you have particular needs when it comes to the transport layer you create an implementation satisfying these details yourself. **Doing this is actually quite simple.**\n\nExample of a http server built with express in [examples/faq_recommended_http_server/server.js](examples/faq_recommended_http_server/server.js):\n\n```javascript\nconst jayson = require('jayson');\nconst jsonParser = require('body-parser').json;\nconst express = require('express');\nconst app = express();\n\n// create a plain jayson server\nconst server = new jayson.Server({\n  add: function(numbers, callback) {\n    const sum = Object.keys(numbers).reduce(function(sum, key) { return sum + numbers[key]; }, 0);\n    callback(null, sum);\n  }\n});\n\napp.use(jsonParser()); // <- here we can deal with maximum body sizes, etc\napp.use(function(req, res, next) {\n  const request = req.body;\n  // <- here we can check headers, modify the request, do logging, etc\n  server.call(request, function(err, response) {\n    if(err) {\n      // if err is an Error, err is NOT a json-rpc error\n      if(err instanceof Error) return next(err);\n      // <- deal with json-rpc errors here, typically caused by the user\n      res.status(400);\n      res.send(err);\n      return;\n    }\n    // <- here we can mutate the response, set response headers, etc\n    if(response) {\n      res.send(response);\n    } else {\n      // empty response (could be a notification)\n      res.status(204);\n      res.send('');\n    }\n  });\n});\n\napp.listen(3001);\n```\n\nUsing some of the utilities provided and exported by jayson, creating a client offering the same kind of flexibility is also simple. Example of a compatible http client built with superagent in [examples/faq_recommended_http_server/client.js](examples/faq_recommended_http_server/client.js):\n\n```javascript\nconst jayson = require('jayson');\nconst request = require('superagent');\n\n// generate a json-rpc version 2 compatible request (non-notification)\nconst requestBody = jayson.Utils.request('add', [1,2,3,4], undefined, {\n  version: 2, // generate a version 2 request\n});\n\nrequest.post('http://localhost:3001')\n  // <- here we can setup timeouts, set headers, cookies, etc\n  .timeout({response: 5000, deadline: 60000})\n  .send(requestBody)\n  .end(function(err, response) {\n    if(err) {\n      // superagent considers 300-499 status codes to be errors\n      // @see http://visionmedia.github.io/superagent/#error-handling\n      if(!err.status) throw err;\n      const body = err.response.body;\n      // body may be a JSON-RPC error, or something completely different\n      // it can be handled here\n      if(body && body.error && jayson.Utils.Response.isValidError(body.error, 2)) {\n        // the error body was a valid JSON-RPC version 2\n        // we may wish to deal with it differently\n        console.err(body.error);\n        return;\n      }\n      throw err; // error was something completely different\n    }\n\n    const body = response.body;\n\n    // check if we got a valid JSON-RPC 2.0 response\n    if(!jayson.Utils.Response.isValidResponse(body, 2)) {\n      console.err(body);\n    }\n\n    if(body.error) {\n      // we have a json-rpc error...\n      console.err(body.error); // 10!\n    } else {\n      // do something useful with the result\n      console.log(body.result); // 10!\n    }\n  });\n```\n\n## Contributing\n\nHighlighting [issues](https://github.com/tedeh/jayson/issues) or submitting pull\nrequests on [Github](https://github.com/tedeh/jayson) is most welcome.\n\nPlease make sure to follow the style of the project, and lint your code with `npm run lint` before submitting a patch.\n\n### Submitting issues or pull requests with the Typescript type definitions\n\nYou are required to provide an easily reproducible code sample of any errors with the Typescript type definitions so that they can be added to the typescript test file in [typescript/test.ts](typescript/test.ts). Better yet, issue a pull request adding a test there yourself that shows up when running the `package.json` script `test-tsc`.\n",
    "licenseText": "(The MIT License)\n\nCopyright (c) 2011-2012 Tedde Lundgren <mail@tedeh.net>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/jayson/-/jayson-4.1.0.tgz#60dc946a85197317f2b1439d672a8b0a99cea2f9",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/jayson/-/jayson-4.1.0.tgz",
    "hash": "60dc946a85197317f2b1439d672a8b0a99cea2f9",
    "integrity": "sha512-R6JlbyLN53Mjku329XoRT2zJAE6ZgOQ8f91ucYdMCD4nkGCF9kZSrcGXpHIU4jeKj58zUZke2p+cdQchU7Ly7A==",
    "registry": "npm",
    "packageName": "jayson",
    "cacheIntegrity": "sha512-R6JlbyLN53Mjku329XoRT2zJAE6ZgOQ8f91ucYdMCD4nkGCF9kZSrcGXpHIU4jeKj58zUZke2p+cdQchU7Ly7A== sha1-YNyUaoUZcxfysUOdZyqLCpnOovk="
  },
  "registry": "npm",
  "hash": "60dc946a85197317f2b1439d672a8b0a99cea2f9"
}